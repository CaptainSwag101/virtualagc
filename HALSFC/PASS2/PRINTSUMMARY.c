/*
  File PRINTSUMMARY.c generated by XCOM-I, 2024-08-08 04:32:26.
*/

#include "runtimeC.h"

int32_t
PRINTSUMMARY (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "PRINTSUMMARY");
  // CALL MONITOR(0, 3); (14321)
  MONITOR0 (3);
  // IF MAX_SEVERITY < 2 THEN (14322)
  if (1 & (xLT (COREHALFWORD (mMAX_SEVERITY), 2)))
    // DO; (14323)
    {
    rs1:;
      // IF CODE_LISTING_REQUESTED THEN (14324)
      if (1 & (bitToFixed (getBIT (1, mCODE_LISTING_REQUESTED))))
        // DO; (14325)
        {
        rs1s1:;
          // CALL SYT_DUMP; (14326)
          PRINTSUMMARYxSYT_DUMP (0);
          // CALL TEMPLATE_DUMP; (14327)
          PRINTSUMMARYxTEMPLATE_DUMP (0);
          // CALL ALIGN_DUMP; (14328)
          PRINTSUMMARYxALIGN_DUMP (0);
          // OUTPUT(1) = '-INSTRUCTION FREQUENCIES'; (14329)
          {
            descriptor_t *stringRHS;
            stringRHS = cToDescriptor (NULL, "-INSTRUCTION FREQUENCIES");
            OUTPUT (1, stringRHS);
            stringRHS->inUse = 0;
          }
          // OUTPUT(1) = '0INSN  COUNT'; (14330)
          {
            descriptor_t *stringRHS;
            stringRHS = cToDescriptor (NULL, "0INSN  COUNT");
            OUTPUT (1, stringRHS);
            stringRHS->inUse = 0;
          }
          // DO T = 0 TO OPMAX; (14331)
          {
            int32_t from138, to138, by138;
            from138 = 0;
            to138 = 205;
            by138 = 1;
            for (putFIXED (mPRINTSUMMARYxT, from138);
                 getFIXED (mPRINTSUMMARYxT) <= to138; putFIXED (
                     mPRINTSUMMARYxT, getFIXED (mPRINTSUMMARYxT) + by138))
              {
                // IF OPCOUNT(T) > 0 THEN (14332)
                if (1
                    & (xGT (COREHALFWORD (mOPCOUNT
                                          + 2 * getFIXED (mPRINTSUMMARYxT)),
                            0)))
                  // DO; (14333)
                  {
                  rs1s1s1s1:;
                    // IF T = 39 | T = 55 THEN (14334)
                    if (1
                        & (xOR (xEQ (getFIXED (mPRINTSUMMARYxT), 39),
                                xEQ (getFIXED (mPRINTSUMMARYxT), 55))))
                      // OPCOUNT(T+4)= OPCOUNT(T) + OPCOUNT(T+4); (14335)
                      {
                        int32_t numberRHS = (int32_t)(xadd (
                            COREHALFWORD (mOPCOUNT
                                          + 2 * getFIXED (mPRINTSUMMARYxT)),
                            COREHALFWORD (
                                mOPCOUNT
                                + 2 * xadd (getFIXED (mPRINTSUMMARYxT), 4))));
                        descriptor_t *bitRHS;
                        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                        putBIT (
                            16,
                            mOPCOUNT
                                + 2 * (xadd (getFIXED (mPRINTSUMMARYxT), 4)),
                            bitRHS);
                        bitRHS->inUse = 0;
                      }
                    // ELSE (14336)
                    else
                      // IF T = 135 THEN (14337)
                      if (1 & (xEQ (getFIXED (mPRINTSUMMARYxT), 135)))
                        // DO; (14338)
                        {
                        rs1s1s1s1s1:;
                          // IF BCB_COUNT > 0 THEN (14339)
                          if (1 & (xGT (COREHALFWORD (mBCB_COUNT), 0)))
                            // OUTPUT = 'BCB   '||X2||BCB_COUNT; (14340)
                            {
                              descriptor_t *stringRHS;
                              stringRHS = xsCAT (
                                  xsCAT (cToDescriptor (NULL, "BCB   "),
                                         getCHARACTER (mX2)),
                                  bitToCharacter (getBIT (16, mBCB_COUNT)));
                              OUTPUT (0, stringRHS);
                              stringRHS->inUse = 0;
                            }
                          // IF (OPCOUNT(T)-BCB_COUNT) > 0 THEN (14341)
                          if (1
                              & (xGT (
                                  xsubtract (
                                      COREHALFWORD (
                                          mOPCOUNT
                                          + 2 * getFIXED (mPRINTSUMMARYxT)),
                                      COREHALFWORD (mBCB_COUNT)),
                                  0)))
                            // OUTPUT = 'BCF   '||X2||(OPCOUNT(T)-BCB_COUNT);
                            // (14342)
                            {
                              descriptor_t *stringRHS;
                              stringRHS = xsCAT (
                                  xsCAT (cToDescriptor (NULL, "BCF   "),
                                         getCHARACTER (mX2)),
                                  fixedToCharacter (xsubtract (
                                      COREHALFWORD (
                                          mOPCOUNT
                                          + 2 * getFIXED (mPRINTSUMMARYxT)),
                                      COREHALFWORD (mBCB_COUNT))));
                              OUTPUT (0, stringRHS);
                              stringRHS->inUse = 0;
                            }
                          // OBJECT_INSTRUCTIONS = OBJECT_INSTRUCTIONS +
                          // OPCOUNT(T); (14343)
                          {
                            int32_t numberRHS = (int32_t)(xadd (
                                getFIXED (mCOMM + 4 * 21),
                                COREHALFWORD (
                                    mOPCOUNT
                                    + 2 * getFIXED (mPRINTSUMMARYxT))));
                            putFIXED (mCOMM + 4 * (21), numberRHS);
                          }
                        es1s1s1s1s1:;
                        } // End of DO block
                      // ELSE (14344)
                      else
                        // DO; (14345)
                        {
                        rs1s1s1s1s2:;
                          // OUTPUT = INSTRUCTION(T) || X2 || OPCOUNT(T);
                          // (14346)
                          {
                            descriptor_t *stringRHS;
                            stringRHS = xsCAT (
                                xsCAT (
                                    (putBITp (16, mINSTRUCTIONxOPCODE,
                                              fixedToBit (
                                                  32, (int32_t)(getFIXED (
                                                          mPRINTSUMMARYxT)))),
                                     INSTRUCTION (0)),
                                    getCHARACTER (mX2)),
                                bitToCharacter (getBIT (
                                    16,
                                    mOPCOUNT
                                        + 2 * getFIXED (mPRINTSUMMARYxT))));
                            OUTPUT (0, stringRHS);
                            stringRHS->inUse = 0;
                          }
                          // OBJECT_INSTRUCTIONS = OBJECT_INSTRUCTIONS +
                          // OPCOUNT(T); (14347)
                          {
                            int32_t numberRHS = (int32_t)(xadd (
                                getFIXED (mCOMM + 4 * 21),
                                COREHALFWORD (
                                    mOPCOUNT
                                    + 2 * getFIXED (mPRINTSUMMARYxT))));
                            putFIXED (mCOMM + 4 * (21), numberRHS);
                          }
                        es1s1s1s1s2:;
                        } // End of DO block
                  es1s1s1s1:;
                  } // End of DO block
              }
          } // End of DO for-loop block
        es1s1:;
        } // End of DO block
      // ELSE (14348)
      else
        // CALL STACK_DUMP; (14349)
        PRINTSUMMARYxSTACK_DUMP (0);
    es1:;
    } // End of DO block
  // OBJECT_MACHINE = 1; (14350)
  {
    int32_t numberRHS = (int32_t)(1);
    putFIXED (mCOMM + 4 * (20), numberRHS);
  }
  // OUTPUT(1) = '-       OPTIONAL TABLE SIZES'; (14351)
  {
    descriptor_t *stringRHS;
    stringRHS = cToDescriptor (NULL, "-       OPTIONAL TABLE SIZES");
    OUTPUT (1, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT(1) = '0NAME       REQUESTED    USED'; (14352)
  {
    descriptor_t *stringRHS;
    stringRHS = cToDescriptor (NULL, "0NAME       REQUESTED    USED");
    OUTPUT (1, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT(1) = '+____       _________    ____'; (14353)
  {
    descriptor_t *stringRHS;
    stringRHS = cToDescriptor (NULL, "+____       _________    ____");
    OUTPUT (1, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT = BLANK; (14354)
  {
    descriptor_t *stringRHS;
    stringRHS = getCHARACTER (mBLANK);
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT = FORM_UP('LITSTRINGS' ,LIT_CHAR_SIZE,LIT_CHAR_USED); (14355)
  {
    descriptor_t *stringRHS;
    stringRHS
        = (putCHARACTERp (mPRINTSUMMARYxFORM_UPxMSG,
                          cToDescriptor (NULL, "LITSTRINGS")),
           putFIXED (mPRINTSUMMARYxFORM_UPxVAL1,
                     getFIXED (getFIXED (mVALS) + 4 * 5)),
           putFIXED (mPRINTSUMMARYxFORM_UPxVAL2, getFIXED (mCOMM + 4 * 1)),
           PRINTSUMMARYxFORM_UP (0));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT = FORM_UP('LABELSIZE ', STATNOLIMIT, STATNO); (14356)
  {
    descriptor_t *stringRHS;
    stringRHS
        = (putCHARACTERp (mPRINTSUMMARYxFORM_UPxMSG,
                          cToDescriptor (NULL, "LABELSIZE ")),
           putFIXED (mPRINTSUMMARYxFORM_UPxVAL1, COREHALFWORD (mSTATNOLIMIT)),
           putFIXED (mPRINTSUMMARYxFORM_UPxVAL2, COREHALFWORD (mSTATNO)),
           PRINTSUMMARYxFORM_UP (0));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT=BLANK; (14357)
  {
    descriptor_t *stringRHS;
    stringRHS = getCHARACTER (mBLANK);
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // IF ERROR# > 0 THEN (14358)
  if (1 & (xGT (COREHALFWORD (mERRORp), 0)))
    // OUTPUT='***  '||ERROR#||' ERROR(S) DETECTED IN PHASE 2'; (14359)
    {
      descriptor_t *stringRHS;
      stringRHS
          = xsCAT (xsCAT (cToDescriptor (NULL, "***  "),
                          bitToCharacter (getBIT (16, mERRORp))),
                   cToDescriptor (NULL, " ERROR(S) DETECTED IN PHASE 2"));
      OUTPUT (0, stringRHS);
      stringRHS->inUse = 0;
    }
  // IF (TOGGLE& 128)=0 THEN (14360)
  if (1 & (xEQ (xAND (getFIXED (mCOMM + 4 * 6), 128), 0)))
    // DO; (14361)
    {
    rs2:;
      // IF MAX_SEVERITY~=0 THEN (14362)
      if (1 & (xNEQ (COREHALFWORD (mMAX_SEVERITY), 0)))
        // OUTPUT= '***  CONVERSION ERRORS INHIBITED OBJECT MODULE GENERATION';
        // (14363)
        {
          descriptor_t *stringRHS;
          stringRHS = cToDescriptor (
              NULL,
              "***  CONVERSION ERRORS INHIBITED OBJECT MODULE GENERATION");
          OUTPUT (0, stringRHS);
          stringRHS->inUse = 0;
        }
    es2:;
    } // End of DO block
  // ELSE (14364)
  else
    // DO; (14365)
    {
    rs3:;
      // MAX_SEVERITY=3; (14366)
      {
        int32_t numberRHS = (int32_t)(3);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mMAX_SEVERITY, bitRHS);
        bitRHS->inUse = 0;
      }
      // OUTPUT='***  PHASE 1 INHIBITED EXECUTION'; (14367)
      {
        descriptor_t *stringRHS;
        stringRHS = cToDescriptor (NULL, "***  PHASE 1 INHIBITED EXECUTION");
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
    es3:;
    } // End of DO block
  // IF MAX_SEVERITY = 0 THEN (14368)
  if (1 & (xEQ (COREHALFWORD (mMAX_SEVERITY), 0)))
    // DO; (14369)
    {
    rs4:;
      // OUTPUT=BLANK; (14370)
      {
        descriptor_t *stringRHS;
        stringRHS = getCHARACTER (mBLANK);
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
      // OUTPUT=PP||' HALMAT OPERATORS CONVERTED'; (14371)
      {
        descriptor_t *stringRHS;
        stringRHS
            = xsCAT (fixedToCharacter (getFIXED (mPP)),
                     cToDescriptor (NULL, " HALMAT OPERATORS CONVERTED"));
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
      // OUTPUT = BLANK; (14372)
      {
        descriptor_t *stringRHS;
        stringRHS = getCHARACTER (mBLANK);
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
      // OUTPUT = OBJECT_INSTRUCTIONS || ' INSTRUCTIONS GENERATED'; (14373)
      {
        descriptor_t *stringRHS;
        stringRHS = xsCAT (fixedToCharacter (getFIXED (mCOMM + 4 * 21)),
                           cToDescriptor (NULL, " INSTRUCTIONS GENERATED"));
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
      // OUTPUT=BLANK; (14374)
      {
        descriptor_t *stringRHS;
        stringRHS = getCHARACTER (mBLANK);
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
      // OUTPUT = PROGCODE || ' HALFWORDS OF PROGRAM, ' ||
      // PROGDATA+PROGDATA(1)||' HALFWORDS OF DATA.'; (14375)
      {
        descriptor_t *stringRHS;
        stringRHS = xsCAT (
            xsCAT (xsCAT (fixedToCharacter (getFIXED (mPROGCODE)),
                          cToDescriptor (NULL, " HALFWORDS OF PROGRAM, ")),
                   fixedToCharacter (xadd (getFIXED (mPROGDATA),
                                           getFIXED (mPROGDATA + 4 * 1)))),
            cToDescriptor (NULL, " HALFWORDS OF DATA."));
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
    es4:;
    } // End of DO block
  // OUTPUT = BLANK; (14376)
  {
    descriptor_t *stringRHS;
    stringRHS = getCHARACTER (mBLANK);
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT='MAX. OPERAND STACK SIZE            ='||STACK_MAX; (14377)
  {
    descriptor_t *stringRHS;
    stringRHS
        = xsCAT (cToDescriptor (NULL, "MAX. OPERAND STACK SIZE            ="),
                 bitToCharacter (getBIT (16, mSTACK_MAX)));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // T=0; (14378)
  {
    int32_t numberRHS = (int32_t)(0);
    putFIXED (mPRINTSUMMARYxT, numberRHS);
  }
  // DO WHILE STACK_PTR~=0; (14379)
  while (1 & (xNEQ (COREHALFWORD (mSTACK_PTR), 0)))
    {
      // STACK_PTR = STACK_PTR(STACK_PTR); (14380)
      {
        descriptor_t *bitRHS
            = getBIT (16, mSTACK_PTR + 2 * COREHALFWORD (mSTACK_PTR));
        putBIT (16, mSTACK_PTR, bitRHS);
        bitRHS->inUse = 0;
      }
      // T=T+1; (14381)
      {
        int32_t numberRHS = (int32_t)(xadd (getFIXED (mPRINTSUMMARYxT), 1));
        putFIXED (mPRINTSUMMARYxT, numberRHS);
      }
      // IF T > STACK_SIZE THEN (14382)
      if (1 & (xGT (getFIXED (mPRINTSUMMARYxT), 100)))
        // DO; (14383)
        {
        rs5s1:;
          // CALL ERRORS(CLASS_BI,504); (14384)
          {
            putBITp (16, mERRORSxCLASS, getBIT (8, mCLASS_BI));
            putBITp (16, mERRORSxNUM, fixedToBit (32, (int32_t)(504)));
            ERRORS (0);
          }
          // STACK_PTR = 0; (14385)
          {
            int32_t numberRHS = (int32_t)(0);
            descriptor_t *bitRHS;
            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
            putBIT (16, mSTACK_PTR, bitRHS);
            bitRHS->inUse = 0;
          }
        es5s1:;
        } // End of DO block
    }     // End of DO WHILE block
  // OUTPUT='END  OPERAND STACK SIZE            ='||STACK_SIZE-T; (14386)
  {
    descriptor_t *stringRHS;
    stringRHS = xsCAT (
        cToDescriptor (NULL, "END  OPERAND STACK SIZE            ="),
        fixedToCharacter (xsubtract (100, getFIXED (mPRINTSUMMARYxT))));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT='MAX. STORAGE DESCRIPTOR STACK SIZE ='||FULLTEMP; (14387)
  {
    descriptor_t *stringRHS;
    stringRHS
        = xsCAT (cToDescriptor (NULL, "MAX. STORAGE DESCRIPTOR STACK SIZE ="),
                 bitToCharacter (getBIT (16, mFULLTEMP)));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // T = 0; (14388)
  {
    int32_t numberRHS = (int32_t)(0);
    putFIXED (mPRINTSUMMARYxT, numberRHS);
  }
  // DO FOR TMP = 0 TO FULLTEMP; (14389)
  {
    int32_t from139, to139, by139;
    from139 = 0;
    to139 = bitToFixed (getBIT (16, mFULLTEMP));
    by139 = 1;
    for (putFIXED (mTMP, from139); getFIXED (mTMP) <= to139;
         putFIXED (mTMP, getFIXED (mTMP) + by139))
      {
        // IF UPPER(TMP) > 0 THEN (14390)
        if (1 & (xGT (getFIXED (mUPPER + 4 * getFIXED (mTMP)), 0)))
          // T = T + 1; (14391)
          {
            int32_t numberRHS
                = (int32_t)(xadd (getFIXED (mPRINTSUMMARYxT), 1));
            putFIXED (mPRINTSUMMARYxT, numberRHS);
          }
      }
  } // End of DO for-loop block
  // CALL DOWNGRADE_SUMMARY; (14392)
  DOWNGRADE_SUMMARY (0);
  // OUTPUT='END  STORAGE DESCRIPTOR STACK SIZE ='||T; (14393)
  {
    descriptor_t *stringRHS;
    stringRHS
        = xsCAT (cToDescriptor (NULL, "END  STORAGE DESCRIPTOR STACK SIZE ="),
                 fixedToCharacter (getFIXED (mPRINTSUMMARYxT)));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT='NUMBER OF MINOR COMPACTIFIES       ='||COMPACTIFIES; (14394)
  {
    descriptor_t *stringRHS;
    stringRHS
        = xsCAT (cToDescriptor (NULL, "NUMBER OF MINOR COMPACTIFIES       ="),
                 bitToCharacter (getBIT (16, mCOMPACTIFIES)));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT='NUMBER OF MAJOR COMPACTIFIES       ='||COMPACTIFIES(1); (14395)
  {
    descriptor_t *stringRHS;
    stringRHS
        = xsCAT (cToDescriptor (NULL, "NUMBER OF MAJOR COMPACTIFIES       ="),
                 bitToCharacter (getBIT (16, mCOMPACTIFIES + 2 * 1)));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT = 'NUMBER OF REALLOCATIONS            ='||REALLOCATIONS; (14396)
  {
    descriptor_t *stringRHS;
    stringRHS
        = xsCAT (cToDescriptor (NULL, "NUMBER OF REALLOCATIONS            ="),
                 bitToCharacter (getBIT (16, mREALLOCATIONS)));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT='FREE STRING AREA                   ='||FREELIMIT-FREEBASE; (14397)
  {
    descriptor_t *stringRHS;
    stringRHS
        = xsCAT (cToDescriptor (NULL, "FREE STRING AREA                   ="),
                 fixedToCharacter (xsubtract (FREELIMIT (), FREEBASE ())));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT=BLANK; (14398)
  {
    descriptor_t *stringRHS;
    stringRHS = getCHARACTER (mBLANK);
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // T = MONITOR(18); (14399)
  {
    int32_t numberRHS = (int32_t)(MONITOR18 ());
    putFIXED (mPRINTSUMMARYxT, numberRHS);
  }
  // IF CLOCK(1) = 0 THEN (14400)
  if (1 & (xEQ (getFIXED (mCLOCK + 4 * 1), 0)))
    // CLOCK(1), CLOCK(2) = T; (14401)
    {
      int32_t numberRHS = (int32_t)(getFIXED (mPRINTSUMMARYxT));
      putFIXED (mCLOCK + 4 * (1), numberRHS);
      putFIXED (mCLOCK + 4 * (2), numberRHS);
    }
  // ELSE (14402)
  else
    // IF CLOCK(2) = 0 THEN (14403)
    if (1 & (xEQ (getFIXED (mCLOCK + 4 * 2), 0)))
      // CLOCK(2) = T; (14404)
      {
        int32_t numberRHS = (int32_t)(getFIXED (mPRINTSUMMARYxT));
        putFIXED (mCLOCK + 4 * (2), numberRHS);
      }
  // CALL PRINT_DATE_AND_TIME('END OF HAL/S PHASE 2 ',DATE,TIME); (14405)
  {
    putCHARACTERp (mPRINT_DATE_AND_TIMExMESSAGE,
                   cToDescriptor (NULL, "END OF HAL/S PHASE 2 "));
    putFIXED (mPRINT_DATE_AND_TIMExD, DATE ());
    putFIXED (mPRINT_DATE_AND_TIMExT, TIME ());
    PRINT_DATE_AND_TIME (0);
  }
  // CALL PRINT_TIME('TOTAL CPU TIME FOR PHASE 2       ', T-CLOCK); (14406)
  {
    putCHARACTERp (mPRINT_TIMExMESSAGE,
                   cToDescriptor (NULL, "TOTAL CPU TIME FOR PHASE 2       "));
    putFIXED (mPRINT_TIMExT,
              xsubtract (getFIXED (mPRINTSUMMARYxT), getFIXED (mCLOCK)));
    PRINT_TIME (0);
  }
  // CALL PRINT_TIME('CPU TIME FOR PHASE 2 SET UP      ', CLOCK(1)-CLOCK);
  // (14407)
  {
    putCHARACTERp (mPRINT_TIMExMESSAGE,
                   cToDescriptor (NULL, "CPU TIME FOR PHASE 2 SET UP      "));
    putFIXED (mPRINT_TIMExT,
              xsubtract (getFIXED (mCLOCK + 4 * 1), getFIXED (mCLOCK)));
    PRINT_TIME (0);
  }
  // CALL PRINT_TIME('CPU TIME FOR PHASE 2 GENERATION  ', CLOCK(2)-CLOCK(1));
  // (14408)
  {
    putCHARACTERp (mPRINT_TIMExMESSAGE,
                   cToDescriptor (NULL, "CPU TIME FOR PHASE 2 GENERATION  "));
    putFIXED (mPRINT_TIMExT, xsubtract (getFIXED (mCLOCK + 4 * 2),
                                        getFIXED (mCLOCK + 4 * 1)));
    PRINT_TIME (0);
  }
  // CALL PRINT_TIME('CPU TIME FOR PHASE 2 CLEAN UP    ', T-CLOCK(2)); (14409)
  {
    putCHARACTERp (mPRINT_TIMExMESSAGE,
                   cToDescriptor (NULL, "CPU TIME FOR PHASE 2 CLEAN UP    "));
    putFIXED (mPRINT_TIMExT, xsubtract (getFIXED (mPRINTSUMMARYxT),
                                        getFIXED (mCLOCK + 4 * 2)));
    PRINT_TIME (0);
  }
  {
    reentryGuard = 0;
    return 0;
  }
}
