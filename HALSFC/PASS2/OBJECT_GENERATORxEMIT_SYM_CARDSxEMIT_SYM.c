/*
  File OBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYM.c generated by XCOM-I,
  2024-08-08 04:32:26.
*/

#include "runtimeC.h"

int32_t
OBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYM (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard,
                               "OBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYM");
  // GO TO EMIT_SYM_START; (16057)
  goto EMIT_SYM_START;
// MVCSYM: (16058)
MVCSYM:
  { // (59) CALL INLINE( 210, 0, 0, 1, 0, 2, 0);
    {
      /*
       * File:      patch59p.c
       * For:       OBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYM.c
       * Notes:     1. Page references are from IBM "ESA/390 Principles of
       *               Operation", SA22-7201-08, Ninth Edition, June 2003.
       *            2. Labels are of the form p%d_%d, where the 1st number
       *               indicates the leading patch number of the block, and
       *               the 2nd is the byte offset of the instruction within
       *               within the block.
       *            3. Known-problematic translations are marked with the
       *               string  "* * * F I X M E * * *" (without spaces).
       * History:   2024-07-18 RSB  Auto-generated by XCOM-I --guess=....
       *                            Inspected.
       */

    p59_0:;
      // (59) MVCSYM:     CALL INLINE("D2", 0, 0, 1, 0, 2, 0);
      address360A = (GR[1] + 0) & 0xFFFFFF;
      address360B = (GR[2] + 0) & 0xFFFFFF;
      // Type SS, p. 7-83:		MVC	0(0,1),0(2)
      detailedInlineBefore (59, "MVC	0(0,1),0(2)");
      mvc (address360A, address360B, 0);
      detailedInlineAfter ();

    p59_6:;
    }
  }
// EMIT_SYM_START: (16060)
EMIT_SYM_START:
  // IF LENGTH(NAME) > 8 THEN (16061)
  if (1
      & (xGT (LENGTH (getCHARACTER (
                  mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxNAME)),
              8)))
    // NAME = SUBSTR(NAME,0,8); (16062)
    {
      descriptor_t *stringRHS;
      stringRHS = SUBSTR (
          getCHARACTER (mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxNAME), 0, 8);
      putCHARACTER (mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxNAME, stringRHS);
      stringRHS->inUse = 0;
    }
  // Q = 4 + LENGTH(NAME); (16063)
  {
    int32_t numberRHS = (int32_t)(xadd (
        4, LENGTH (getCHARACTER (
               mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxNAME))));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxQ, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF BYTES_REMAINING < Q+2 THEN (16064)
  if (1
      & (xLT (COREHALFWORD (mOBJECT_GENERATORxBYTES_REMAINING),
              xadd (COREHALFWORD (mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxQ),
                    2))))
    // CALL EMIT_SYM_CARD; (16065)
    OBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYM_CARD (0);
  // COLUMN(J) = FLAG + LENGTH(NAME) - 1; (16066)
  {
    int32_t numberRHS = (int32_t)(xsubtract (
        xadd (BYTE0 (mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxFLAG),
              LENGTH (getCHARACTER (
                  mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxNAME))),
        1));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (8,
            mOBJECT_GENERATORxCOLUMN
                + 1 * (COREHALFWORD (mOBJECT_GENERATORxEMIT_SYM_CARDSxJ)),
            bitRHS);
    bitRHS->inUse = 0;
  }
  // COLUMN(J+1) = SHR(VAL, 15); (16067)
  {
    int32_t numberRHS = (int32_t)(SHR (
        getFIXED (mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxVAL), 15));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (
        8,
        mOBJECT_GENERATORxCOLUMN
            + 1
                  * (xadd (COREHALFWORD (mOBJECT_GENERATORxEMIT_SYM_CARDSxJ),
                           1)),
        bitRHS);
    bitRHS->inUse = 0;
  }
  // COLUMN(J+2) = SHR(VAL, 7); (16068)
  {
    int32_t numberRHS = (int32_t)(SHR (
        getFIXED (mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxVAL), 7));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (
        8,
        mOBJECT_GENERATORxCOLUMN
            + 1
                  * (xadd (COREHALFWORD (mOBJECT_GENERATORxEMIT_SYM_CARDSxJ),
                           2)),
        bitRHS);
    bitRHS->inUse = 0;
  }
  // COLUMN(J+3) = SHL(VAL, 1); (16069)
  {
    int32_t numberRHS = (int32_t)(SHL (
        getFIXED (mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxVAL), 1));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (
        8,
        mOBJECT_GENERATORxCOLUMN
            + 1
                  * (xadd (COREHALFWORD (mOBJECT_GENERATORxEMIT_SYM_CARDSxJ),
                           3)),
        bitRHS);
    bitRHS->inUse = 0;
  }
  // TEMP = ADDR(COLUMN(J+4)); (16070)
  {
    int32_t numberRHS = (int32_t)(ADDR (
        NULL, 0, "OBJECT_GENERATORxCOLUMN",
        xadd (COREHALFWORD (mOBJECT_GENERATORxEMIT_SYM_CARDSxJ), 4)));
    putFIXED (mOBJECT_GENERATORxEMIT_SYM_CARDSxTEMP, numberRHS);
  }
  // TEMPL = ADDR(MVCSYM); (16071)
  {
    int32_t numberRHS = (int32_t)(-2);
    putFIXED (mOBJECT_GENERATORxEMIT_SYM_CARDSxTEMPL, numberRHS);
  }
  {   // (60) CALL INLINE( 88, 1, 0, TEMP);
    { /*
       * File:      patch60p.c
       * For:       OBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYM.c
       * Notes:     1. Page references are from IBM "ESA/390 Principles of
       *               Operation", SA22-7201-08, Ninth Edition, June 2003.
       *            2. Labels are of the form p%d_%d, where the 1st number
       *               indicates the leading patch number of the block, and
       *               the 2nd is the byte offset of the instruction within
       *               within the block.
       *            3. Known-problematic translations are marked with the
       *               string  "* * * F I X M E * * *" (without spaces).
       * History:   2024-07-18 RSB  Auto-generated by XCOM-I --guess=....
       *                            Fixed the FIXME EX.
       */

      p60_0:;
  // (60)             CALL INLINE("58", 1, 0, TEMP);
  address360B = (mOBJECT_GENERATORxEMIT_SYM_CARDSxTEMP)&0xFFFFFF;
  // Type RX, p. 7-7:		L
  // 1,mOBJECT_GENERATORxEMIT_SYM_CARDSxTEMP(0,0)
  detailedInlineBefore (60, "L	1,mOBJECT_GENERATORxEMIT_SYM_CARDSxTEMP(0,0)");
  GR[1] = COREWORD (address360B);
  detailedInlineAfter ();

p60_4:;
  // (61)             CALL INLINE("58", 2, 0, NAME);
  address360B = (mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxNAME)&0xFFFFFF;
  // Type RX, p. 7-7:		L
  // 2,mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxNAME(0,0)
  detailedInlineBefore (
      61, "L	2,mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxNAME(0,0)");
  GR[2] = COREWORD (address360B);
  detailedInlineAfter ();

p60_8:;
  // (62)             CALL INLINE("1B", 3, 3);
  // Type RR, p. 7-127:		SR	3,3
  detailedInlineBefore (62, "SR	3,3");
  scratch = (int64_t)GR[3] - (int64_t)GR[3];
  setCC ();
  GR[3] = (int32_t)scratch;
  detailedInlineAfter ();

p60_10:;
  // (63)             CALL INLINE("43", 3, 0, NAME);
  address360B = (mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxNAME)&0xFFFFFF;
  // Type RX, p. 7-76:		IC
  // 3,mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxNAME(0,0)
  detailedInlineBefore (
      63, "IC	3,mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxNAME(0,0)");
  GR[3] = memory[address360B] | (GR[3] & 0xFFFFFF00);
  detailedInlineAfter ();

p60_14:;
  // (64)             CALL INLINE("18", 0, 4);
  // Type RR, p. 7-77:		LR	0,4
  detailedInlineBefore (64, "LR	0,4");
  GR[0] = GR[4];
  detailedInlineAfter ();

p60_16:;
  // (65)             CALL INLINE("58", 4, 0, TEMPL);
  address360B = (mOBJECT_GENERATORxEMIT_SYM_CARDSxTEMPL)&0xFFFFFF;
  // Type RX, p. 7-7:		L
  // 4,mOBJECT_GENERATORxEMIT_SYM_CARDSxTEMPL(0,0)
  detailedInlineBefore (
      65, "L	4,mOBJECT_GENERATORxEMIT_SYM_CARDSxTEMPL(0,0)");
  GR[4] = COREWORD (address360B);
  detailedInlineAfter ();

p60_20:;
  // (66)             CALL INLINE("44", 3, 0, 4, 0);
  address360B = (GR[4] + 0) & 0xFFFFFF;
  // Type RX, p. 7-74:		EX	3,0(0,4)
  detailedInlineBefore (66, "EX	3,0(0,4)");
  // (59) MVCSYM:     CALL INLINE("D2", 0, 0, 1, 0, 2, 0);
  address360A = (GR[1] + 0) & 0xFFFFFF;
  address360B = (GR[2] + 0) & 0xFFFFFF;
  // Type SS, p. 7-83:          MVC     0(0,1),0(2)
  mvc (address360A, address360B, GR[3]);
  detailedInlineAfter ();

p60_24:;
  // (67)             CALL INLINE("18", 4, 0);
  // Type RR, p. 7-77:		LR	4,0
  detailedInlineBefore (67, "LR	4,0");
  GR[4] = GR[0];
  detailedInlineAfter ();

p60_26:;
}
}
; // (61) CALL INLINE( 88, 2, 0, NAME);
; // (62) CALL INLINE( 27, 3, 3);
; // (63) CALL INLINE( 67, 3, 0, NAME);
; // (64) CALL INLINE( 24, 0, 4);
; // (65) CALL INLINE( 88, 4, 0, TEMPL);
; // (66) CALL INLINE( 68, 3, 0, 4, 0);
; // (67) CALL INLINE( 24, 4, 0);
// BYTES_REMAINING = BYTES_REMAINING - Q; (16080)
{
  int32_t numberRHS = (int32_t)(xsubtract (
      COREHALFWORD (mOBJECT_GENERATORxBYTES_REMAINING),
      COREHALFWORD (mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxQ)));
  descriptor_t *bitRHS;
  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
  putBIT (16, mOBJECT_GENERATORxBYTES_REMAINING, bitRHS);
  bitRHS->inUse = 0;
}
// J = J + Q; (16081)
{
  int32_t numberRHS = (int32_t)(xadd (
      COREHALFWORD (mOBJECT_GENERATORxEMIT_SYM_CARDSxJ),
      COREHALFWORD (mOBJECT_GENERATORxEMIT_SYM_CARDSxEMIT_SYMxQ)));
  descriptor_t *bitRHS;
  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
  putBIT (16, mOBJECT_GENERATORxEMIT_SYM_CARDSxJ, bitRHS);
  bitRHS->inUse = 0;
}
{
  reentryGuard = 0;
  return 0;
}
}
