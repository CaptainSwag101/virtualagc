/*
  File OBJECT_GENERATOR.c generated by XCOM-I, 2024-08-08 04:32:26.
*/

#include "runtimeC.h"

int32_t
OBJECT_GENERATOR (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "OBJECT_GENERATOR");
  // IF (TOGGLE& 128)~=0 THEN (15077)
  if (1 & (xNEQ (xAND (getFIXED (mCOMM + 4 * 6), 128), 0)))
    // RETURN; (15078)
    {
      reentryGuard = 0;
      return 0;
    }
  // GENERATING, EMITTING = TRUE; (15079)
  {
    int32_t numberRHS = (int32_t)(1);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (1, mGENERATING, bitRHS);
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (1, mEMITTING, bitRHS);
    bitRHS->inUse = 0;
  }
  // CALL SET_MASKING_BIT(0); (15080)
  {
    putBITp (16, mSET_MASKING_BITxSTMT_NO, fixedToBit (32, (int32_t)(0)));
    SET_MASKING_BIT (0);
  }
  // CALL EMIT_ADDRS(0); (15081)
  {
    putBITp (16, mEMIT_ADDRSxSTMT_NO, fixedToBit (32, (int32_t)(0)));
    EMIT_ADDRS (0);
  }
  // CODE_LINE = 0; (15082)
  {
    int32_t numberRHS = (int32_t)(0);
    putFIXED (mCODE_LINE, numberRHS);
  }
  // CALL EMIT_ESD_CARDS; (15083)
  OBJECT_GENERATORxEMIT_ESD_CARDS (0);
  // ALLOCATE_SPACE(INIT_TAB,10); (15084)
  {
    putFIXED (m_ALLOCATE_SPACExDOPE, ADDR ("INIT_TAB", 0x80000000, NULL, 0));
    putFIXED (m_ALLOCATE_SPACExHIREC, 10);
    _ALLOCATE_SPACE (0);
  }
  // DO ; (15085)
  {
  rs1:;
    // IF COREWORD ( ADDR ( INIT_TAB ) + 12 ) >= COREWORD ( ADDR ( INIT_TAB ) +
    // 8 ) THEN (15086)
    if (1
        & (xGE (COREWORD (xadd (ADDR ("INIT_TAB", 0x80000000, NULL, 0), 12)),
                COREWORD (xadd (ADDR ("INIT_TAB", 0x80000000, NULL, 0), 8)))))
      // CALL _NEEDMORE_SPACE ( ADDR ( INIT_TAB )  ) ; (15087)
      {
        putFIXED (m_NEEDMORE_SPACExDOPE,
                  ADDR ("INIT_TAB", 0x80000000, NULL, 0));
        _NEEDMORE_SPACE (0);
      }
    // COREWORD ( ADDR ( INIT_TAB ) + 12 ) = COREWORD ( ADDR ( INIT_TAB ) + 12
    // ) + 1 ; (15088)
    {
      int32_t numberRHS = (int32_t)(xadd (
          COREWORD (xadd (ADDR ("INIT_TAB", 0x80000000, NULL, 0), 12)), 1));
      COREWORD2 (xadd (ADDR ("INIT_TAB", 0x80000000, NULL, 0), 12), numberRHS);
    }
  es1:;
  } // End of DO block
  // DO WHILE GENERATING; (15089)
  while (1 & (bitToFixed (getBIT (1, mGENERATING))))
    {
      // CALL NEXT_REC(0); (15090)
      {
        putBITp (16, mNEXT_RECxI, fixedToBit (32, (int32_t)(0)));
        NEXT_REC (0);
      }
      // IF LHS >= 32 THEN (15091)
      if (1 & (xGE (COREHALFWORD (mLHS), 32)))
        // DO; (15092)
        {
        rs2s1:;
        // CASE0004: (15093)
        CASE0004:
          // DO CASE (LHS-32); (15094)
          {
          rs2s1s1:
            switch (xsubtract (COREHALFWORD (mLHS), 32))
              {
              case 0:
                // IF EMITTING THEN (15096)
                if (1 & (bitToFixed (getBIT (1, mEMITTING))))
                  {
                  rs2s1s1s1:;
                    // CALL INST_ADDRS; (15097)
                    OBJECT_GENERATORxINST_ADDRS (0);
                    // RHS = GET_INST_R_X; (15098)
                    {
                      descriptor_t *bitRHS = GET_INST_R_X (0);
                      putBIT (16, mRHS, bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // OPCOUNT(INST) = OPCOUNT(INST) + 1; (15099)
                    {
                      int32_t numberRHS = (int32_t)(xadd (
                          COREHALFWORD (mOPCOUNT + 2 * getFIXED (mINST)), 1));
                      descriptor_t *bitRHS;
                      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                      putBIT (16, mOPCOUNT + 2 * (getFIXED (mINST)), bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // IF INST <  4 THEN (15100)
                    if (1 & (xLT (getFIXED (mINST), 4)))
                      // DO; (15101)
                      {
                      rs2s1s1s1s1:;
                        // IX = SHL(IA,3) | IX; (15102)
                        {
                          int32_t numberRHS = (int32_t)(xOR (
                              SHL (getFIXED (mIA), 3), getFIXED (mIX)));
                          putFIXED (mIX, numberRHS);
                        }
                        // IA = 0; (15103)
                        {
                          int32_t numberRHS = (int32_t)(0);
                          putFIXED (mIA, numberRHS);
                        }
                      es2s1s1s1s1:;
                      } // End of DO block
                    // RHS = RHS | SHL(R, 8) | IX; (15104)
                    {
                      int32_t numberRHS = (int32_t)(xOR (
                          xOR (COREHALFWORD (mRHS), SHL (getFIXED (mR), 8)),
                          getFIXED (mIX)));
                      descriptor_t *bitRHS;
                      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                      putBIT (16, mRHS, bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // CALL EMIT_TEXT_CARD(2); (15105)
                    {
                      putBITp (16, mOBJECT_GENERATORxEMIT_TEXT_CARDxI,
                               fixedToBit (32, (int32_t)(2)));
                      OBJECT_GENERATORxEMIT_TEXT_CARD (0);
                    }
                  es2s1s1s1:;
                  } // End of DO block
                break;
              case 1:
                // IF EMITTING THEN (15107)
                if (1 & (bitToFixed (getBIT (1, mEMITTING))))
                RX_RS:
                  {
                  rs2s1s1s2:;
                    // CALL INST_ADDRS; (15109)
                    OBJECT_GENERATORxINST_ADDRS (0);
                    // RHS = GET_INST_R_X; (15110)
                    {
                      descriptor_t *bitRHS = GET_INST_R_X (0);
                      putBIT (16, mRHS, bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // OPCOUNT(INST) = OPCOUNT(INST) + 1; (15111)
                    {
                      int32_t numberRHS = (int32_t)(xadd (
                          COREHALFWORD (mOPCOUNT + 2 * getFIXED (mINST)), 1));
                      descriptor_t *bitRHS;
                      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                      putBIT (16, mOPCOUNT + 2 * (getFIXED (mINST)), bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // CALL NEXT_REC(1); (15112)
                    {
                      putBITp (16, mNEXT_RECxI, fixedToBit (32, (int32_t)(1)));
                      NEXT_REC (0);
                    }
                    // CALL FORM_BD(1); (15113)
                    {
                      putBITp (16, mOBJECT_GENERATORxFORM_BDxI,
                               fixedToBit (32, (int32_t)(1)));
                      OBJECT_GENERATORxFORM_BD (0);
                    }
                    // IF (RHS &  240) =  224 THEN (15114)
                    if (1 & (xEQ (xAND (COREHALFWORD (mRHS), 240), 224)))
                      // RHS = RHS | R; (15115)
                      {
                        int32_t numberRHS = (int32_t)(xOR (COREHALFWORD (mRHS),
                                                           getFIXED (mR)));
                        descriptor_t *bitRHS;
                        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                        putBIT (16, mRHS, bitRHS);
                        bitRHS->inUse = 0;
                      }
                    // ELSE (15116)
                    else
                      // RHS = RHS | SHL(R,8) | B | SHL(IA | AM | F | IX~=0,2)
                      // |  240; (15117)
                      {
                        int32_t numberRHS = (int32_t)(xOR (
                            xOR (xOR (xOR (COREHALFWORD (mRHS),
                                           SHL (getFIXED (mR), 8)),
                                      getFIXED (mB)),
                                 SHL (xOR (xOR (xOR (getFIXED (mIA),
                                                     getFIXED (mAM)),
                                                getFIXED (mF)),
                                           xNEQ (getFIXED (mIX), 0)),
                                      2)),
                            240));
                        descriptor_t *bitRHS;
                        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                        putBIT (16, mRHS, bitRHS);
                        bitRHS->inUse = 0;
                      }
                    // RHS(1) = SHL(IX,13) | SHL(IA,12) | SHL(F,11) | D;
                    // (15118)
                    {
                      int32_t numberRHS
                          = (int32_t)(xOR (xOR (xOR (SHL (getFIXED (mIX), 13),
                                                     SHL (getFIXED (mIA), 12)),
                                                SHL (getFIXED (mF), 11)),
                                           getFIXED (mD)));
                      descriptor_t *bitRHS;
                      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                      putBIT (16, mRHS + 2 * (1), bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // CALL EMIT_TEXT_CARD(4); (15119)
                    {
                      putBITp (16, mOBJECT_GENERATORxEMIT_TEXT_CARDxI,
                               fixedToBit (32, (int32_t)(4)));
                      OBJECT_GENERATORxEMIT_TEXT_CARD (0);
                    }
                  es2s1s1s2:;
                  } // End of DO block
                  else SKIP_ADDR (0);
                break;
              case 2:
                // IF EMITTING THEN (15123)
                if (1 & (bitToFixed (getBIT (1, mEMITTING))))
                SS_TYPE:
                  {
                  rs2s1s1s3:;
                    // CALL INST_ADDRS; (15125)
                    OBJECT_GENERATORxINST_ADDRS (0);
                    // RHS = GET_INST_R_X; (15126)
                    {
                      descriptor_t *bitRHS = GET_INST_R_X (0);
                      putBIT (16, mRHS, bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // OPCOUNT(INST) = OPCOUNT(INST) + 1; (15127)
                    {
                      int32_t numberRHS = (int32_t)(xadd (
                          COREHALFWORD (mOPCOUNT + 2 * getFIXED (mINST)), 1));
                      descriptor_t *bitRHS;
                      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                      putBIT (16, mOPCOUNT + 2 * (getFIXED (mINST)), bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // CALL NEXT_REC(1); (15128)
                    {
                      putBITp (16, mNEXT_RECxI, fixedToBit (32, (int32_t)(1)));
                      NEXT_REC (0);
                    }
                    // CALL FORM_BD(1); (15129)
                    {
                      putBITp (16, mOBJECT_GENERATORxFORM_BDxI,
                               fixedToBit (32, (int32_t)(1)));
                      OBJECT_GENERATORxFORM_BD (0);
                    }
                    // IF B >= 0 THEN (15130)
                    if (1 & (xGE (getFIXED (mB), 0)))
                      // RHS = RHS | B; (15131)
                      {
                        int32_t numberRHS = (int32_t)(xOR (COREHALFWORD (mRHS),
                                                           getFIXED (mB)));
                        descriptor_t *bitRHS;
                        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                        putBIT (16, mRHS, bitRHS);
                        bitRHS->inUse = 0;
                      }
                    // RHS = RHS | SHL(D, 2); (15132)
                    {
                      int32_t numberRHS = (int32_t)(xOR (
                          COREHALFWORD (mRHS), SHL (getFIXED (mD), 2)));
                      descriptor_t *bitRHS;
                      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                      putBIT (16, mRHS, bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // CALL NEXT_REC(1); (15133)
                    {
                      putBITp (16, mNEXT_RECxI, fixedToBit (32, (int32_t)(1)));
                      NEXT_REC (0);
                    }
                    // CALL EMIT_TEXT_CARD(4); (15134)
                    {
                      putBITp (16, mOBJECT_GENERATORxEMIT_TEXT_CARDxI,
                               fixedToBit (32, (int32_t)(4)));
                      OBJECT_GENERATORxEMIT_TEXT_CARD (0);
                    }
                  es2s1s1s3:;
                  } // End of DO block
                  else
                  {
                  rs2s1s1s4:;
                    // CALL SKIP_ADDR; (15137)
                    SKIP_ADDR (0);
                    // CALL SKIP(1); (15138)
                    {
                      putBITp (16, mSKIPxN, fixedToBit (32, (int32_t)(1)));
                      SKIP (0);
                    }
                  es2s1s1s4:;
                  } // End of DO block
                break;
              case 3:
                // ADDRESS_MOD=RHS + ADDRESS_MOD; (15140)
                {
                  int32_t numberRHS = (int32_t)(xadd (
                      COREHALFWORD (mRHS),
                      getFIXED (mOBJECT_GENERATORxADDRESS_MOD)));
                  putFIXED (mOBJECT_GENERATORxADDRESS_MOD, numberRHS);
                }
                break;
              case 4:
                // DO; (15141)
                {
                rs2s1s1s5:;
                  // TAG_NAME=SYT_NAME(RHS); (15141)
                  {
                    descriptor_t *stringRHS;
                    stringRHS = getCHARACTER (getFIXED (mSYM_TAB)
                                              + 34 * (COREHALFWORD (mRHS)) + 0
                                              + 4 * (0));
                    putCHARACTER (mOBJECT_GENERATORxTAG_NAME, stringRHS);
                    stringRHS->inUse = 0;
                  }
                  // CALL PRINT_LINE; (15142)
                  OBJECT_GENERATORxPRINT_LINE (0);
                es2s1s1s5:;
                } // End of DO block
                break;
              case 5:
                // DO; (15144)
                {
                rs2s1s1s6:;
                  // TAG_NAME='LBL#' || LABEL_ARRAY(RHS); (15144)
                  {
                    descriptor_t *stringRHS;
                    stringRHS = xsCAT (
                        cToDescriptor (NULL, "LBL#"),
                        bitToCharacter (getBIT (
                            16, getFIXED (mSTMTNUM) + 2 * (COREHALFWORD (mRHS))
                                    + 0 + 2 * (0))));
                    putCHARACTER (mOBJECT_GENERATORxTAG_NAME, stringRHS);
                    stringRHS->inUse = 0;
                  }
                  // CALL PRINT_LINE; (15145)
                  OBJECT_GENERATORxPRINT_LINE (0);
                es2s1s1s6:;
                } // End of DO block
                break;
              case 6:
                // DO; (15147)
                {
                rs2s1s1s7:;
                  // CALL EMIT_CARD; (15147)
                  OBJECT_GENERATORxEMIT_CARD (0);
                  // IF RHS = FSIMBASE THEN (15148)
                  if (1
                      & (xEQ (COREHALFWORD (mRHS), COREHALFWORD (mFSIMBASE))))
                    // RHS = DATABASE; (15149)
                    {
                      descriptor_t *bitRHS = getBIT (16, mDATABASE);
                      putBIT (16, mRHS, bitRHS);
                      bitRHS->inUse = 0;
                    }
                  // ITEMP = CURRENT_ESDID~=RHS; (15150)
                  {
                    int32_t numberRHS = (int32_t)(xNEQ (
                        getFIXED (mCURRENT_ESDID), COREHALFWORD (mRHS)));
                    descriptor_t *bitRHS;
                    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                    putBIT (16, mOBJECT_GENERATORxITEMP, bitRHS);
                    bitRHS->inUse = 0;
                  }
                  // CURRENT_ESDID=RHS; (15151)
                  {
                    descriptor_t *bitRHS = getBIT (16, mRHS);
                    int32_t numberRHS;
                    numberRHS = bitToFixed (bitRHS);
                    putFIXED (mCURRENT_ESDID, numberRHS);
                    bitRHS->inUse = 0;
                  }
                  // L = CURRENT_ADDRESS; (15152)
                  {
                    int32_t numberRHS = (int32_t)(getFIXED (
                        mWORKSEG + 4 * getFIXED (mCURRENT_ESDID)));
                    putFIXED (mOBJECT_GENERATORxL, numberRHS);
                  }
                  // IF ITEMP THEN (15153)
                  if (1 & (bitToFixed (getBIT (16, mOBJECT_GENERATORxITEMP))))
                    // DO; (15154)
                    {
                    rs2s1s1s7s1:;
                      // TAG_NAME = ESD_TABLE(CURRENT_ESDID); (15155)
                      {
                        descriptor_t *stringRHS;
                        stringRHS
                            = (putBITp (16, mESD_TABLExPTR,
                                        fixedToBit (32, (int32_t)(getFIXED (
                                                            mCURRENT_ESDID)))),
                               ESD_TABLE (0));
                        putCHARACTER (mOBJECT_GENERATORxTAG_NAME, stringRHS);
                        stringRHS->inUse = 0;
                      }
                      // CALL PRINT_LINE; (15156)
                      OBJECT_GENERATORxPRINT_LINE (0);
                    es2s1s1s7s1:;
                    } // End of DO block
                  // CALL NEXT_REC; (15157)
                  NEXT_REC (0);
                  // IF SHR(LHS, 15) THEN (15158)
                  if (1 & (SHR (COREHALFWORD (mLHS), 15)))
                    // DO; (15159)
                    {
                    rs2s1s1s7s2:;
                      // CURRENT_ADDRESS = (SHL(LHS & FTWO, 16) | (RHS &
                      // FFOUR)) + ORIGIN(CURRENT_ESDID); (15160)
                      {
                        int32_t numberRHS = (int32_t)(xadd (
                            xOR (SHL (xAND (COREHALFWORD (mLHS),
                                            getFIXED (mOBJECT_GENERATORxFTWO)),
                                      16),
                                 xAND (COREHALFWORD (mRHS),
                                       getFIXED (mOBJECT_GENERATORxFFOUR))),
                            getFIXED (mORIGIN
                                      + 4 * getFIXED (mCURRENT_ESDID))));
                        putFIXED (mWORKSEG + 4 * (getFIXED (mCURRENT_ESDID)),
                                  numberRHS);
                      }
                      // IF TEMP=NEGMAX & CURRENT_ESDID <= PROCLIMIT THEN
                      // (15161)
                      if (1
                          & (xAND (xEQ (getFIXED (mTEMP), getFIXED (mNEGMAX)),
                                   xLE (getFIXED (mCURRENT_ESDID),
                                        COREHALFWORD (mPROCLIMIT)))))
                        // FIRST_INST = TRUE; (15162)
                        {
                          int32_t numberRHS = (int32_t)(1);
                          descriptor_t *bitRHS;
                          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                          putBIT (1, mFIRST_INST, bitRHS);
                          bitRHS->inUse = 0;
                        }
                      // LHS = 43; (15163)
                      {
                        int32_t numberRHS = (int32_t)(43);
                        descriptor_t *bitRHS;
                        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                        putBIT (16, mLHS, bitRHS);
                        bitRHS->inUse = 0;
                      }
                      // IF L ~= CURRENT_ADDRESS THEN (15164)
                      if (1
                          & (xNEQ (
                              getFIXED (mOBJECT_GENERATORxL),
                              getFIXED (mWORKSEG
                                        + 4 * getFIXED (mCURRENT_ESDID)))))
                        // CALL PRINT_LINE; (15165)
                        OBJECT_GENERATORxPRINT_LINE (0);
                    es2s1s1s7s2:;
                    } // End of DO block
                es2s1s1s7:;
                } // End of DO block
                break;
              case 7:
                // DO; (15167)
                {
                rs2s1s1s8:;
                  // DO ITEMP=1 TO RHS; (15167)
                  {
                    int32_t from149, to149, by149;
                    from149 = 1;
                    to149 = bitToFixed (getBIT (16, mRHS));
                    by149 = 1;
                    for (putBIT (16, mOBJECT_GENERATORxITEMP,
                                 fixedToBit (16, from149));
                         bitToFixed (getBIT (16, mOBJECT_GENERATORxITEMP))
                         <= to149;
                         putBIT (
                             16, mOBJECT_GENERATORxITEMP,
                             fixedToBit (16, bitToFixed (getBIT (
                                                 16, mOBJECT_GENERATORxITEMP))
                                                 + by149)))
                      {
                        // CALL NEXT_REC(1); (15168)
                        {
                          putBITp (16, mNEXT_RECxI,
                                   fixedToBit (32, (int32_t)(1)));
                          NEXT_REC (0);
                        }
                        // RHS=LHS(1); (15169)
                        {
                          descriptor_t *bitRHS = getBIT (16, mLHS + 2 * 1);
                          putBIT (16, mRHS, bitRHS);
                          bitRHS->inUse = 0;
                        }
                        // IF (CURRENT_ESDID=DATABASE) &  (CURRENT_ADDRESS <
                        // PROGDATA) THEN (15170)
                        if (1
                            & (xAND (xEQ (getFIXED (mCURRENT_ESDID),
                                          COREHALFWORD (mDATABASE)),
                                     xLT (getFIXED (
                                              mWORKSEG
                                              + 4 * getFIXED (mCURRENT_ESDID)),
                                          getFIXED (mPROGDATA)))))
                          // DO; (15171)
                          {
                          rs2s1s1s8s1s1:;
                            // CALL ZERO_INIT_VAL
                            // (RECORD_TOP(INIT_TAB)+1,CURRENT_ADDRESS+1);
                            // (15172)
                            {
                              putFIXED (mOBJECT_GENERATORxZERO_INIT_VALxFIRST,
                                        xadd (xsubtract (COREWORD (xadd (
                                                             ADDR ("INIT_TAB",
                                                                   0x80000000,
                                                                   NULL, 0),
                                                             12)),
                                                         1),
                                              1));
                              putFIXED (
                                  mOBJECT_GENERATORxZERO_INIT_VALxLAST,
                                  xadd (getFIXED (
                                            mWORKSEG
                                            + 4 * getFIXED (mCURRENT_ESDID)),
                                        1));
                              OBJECT_GENERATORxZERO_INIT_VAL (0);
                            }
                            // INIT_VAL(CURRENT_ADDRESS) = RHS; (15173)
                            {
                              descriptor_t *bitRHS = getBIT (16, mRHS);
                              putBIT (16,
                                      getFIXED (mINIT_TAB)
                                          + 2
                                                * (getFIXED (
                                                    mWORKSEG
                                                    + 4
                                                          * getFIXED (
                                                              mCURRENT_ESDID)))
                                          + 0 + 2 * (0),
                                      bitRHS);
                              bitRHS->inUse = 0;
                            }
                            // INIT_VAL(CURRENT_ADDRESS + 1) = RHS(1); (15174)
                            {
                              descriptor_t *bitRHS = getBIT (16, mRHS + 2 * 1);
                              putBIT (
                                  16,
                                  getFIXED (mINIT_TAB)
                                      + 2
                                            * (xadd (
                                                getFIXED (
                                                    mWORKSEG
                                                    + 4
                                                          * getFIXED (
                                                              mCURRENT_ESDID)),
                                                1))
                                      + 0 + 2 * (0),
                                  bitRHS);
                              bitRHS->inUse = 0;
                            }
                          es2s1s1s8s1s1:;
                          } // End of DO block
                        // CALL EMIT_TEXT_CARD(4); (15175)
                        {
                          putBITp (16, mOBJECT_GENERATORxEMIT_TEXT_CARDxI,
                                   fixedToBit (32, (int32_t)(4)));
                          OBJECT_GENERATORxEMIT_TEXT_CARD (0);
                        }
                      }
                  } // End of DO for-loop block
                es2s1s1s8:;
                } // End of DO block
                break;
              case 8:
                // DO; (15177)
                {
                rs2s1s1s9:;
                  // CALL NEXT_REC(1); (15177)
                  {
                    putBITp (16, mNEXT_RECxI, fixedToBit (32, (int32_t)(1)));
                    NEXT_REC (0);
                  }
                  // TEMP = LHS(1); (15178)
                  {
                    descriptor_t *bitRHS = getBIT (16, mLHS + 2 * 1);
                    int32_t numberRHS;
                    numberRHS = bitToFixed (bitRHS);
                    putFIXED (mTEMP, numberRHS);
                    bitRHS->inUse = 0;
                  }
                  // IF ESD_TYPE(RHS) ~= 2 THEN (15179)
                  if (1
                      & (xNEQ (BYTE0 (mESD_TYPE + 1 * COREHALFWORD (mRHS)),
                               2)))
                    // TEMP = TEMP + ORIGIN(RHS); (15180)
                    {
                      int32_t numberRHS = (int32_t)(xadd (
                          getFIXED (mTEMP),
                          getFIXED (mORIGIN + 4 * COREHALFWORD (mRHS))));
                      putFIXED (mTEMP, numberRHS);
                    }
                // DO_ADCONS: (15181)
                DO_ADCONS:
                  // CALL SET_ADDR_RHS; (15182)
                  OBJECT_GENERATORxSET_ADDR_RHS (0);
                  // IF (CURRENT_ESDID=DATABASE) &  (CURRENT_ADDRESS <
                  // PROGDATA) THEN (15183)
                  if (1
                      & (xAND (xEQ (getFIXED (mCURRENT_ESDID),
                                    COREHALFWORD (mDATABASE)),
                               xLT (getFIXED (mWORKSEG
                                              + 4 * getFIXED (mCURRENT_ESDID)),
                                    getFIXED (mPROGDATA)))))
                    // DO; (15184)
                    {
                    rs2s1s1s9s1:;
                      // CALL ZERO_INIT_VAL
                      // (RECORD_TOP(INIT_TAB)+1,CURRENT_ADDRESS+1); (15185)
                      {
                        putFIXED (
                            mOBJECT_GENERATORxZERO_INIT_VALxFIRST,
                            xadd (xsubtract (COREWORD (xadd (ADDR ("INIT_TAB",
                                                                   0x80000000,
                                                                   NULL, 0),
                                                             12)),
                                             1),
                                  1));
                        putFIXED (
                            mOBJECT_GENERATORxZERO_INIT_VALxLAST,
                            xadd (getFIXED (mWORKSEG
                                            + 4 * getFIXED (mCURRENT_ESDID)),
                                  1));
                        OBJECT_GENERATORxZERO_INIT_VAL (0);
                      }
                      // INIT_VAL(CURRENT_ADDRESS) = RHS; (15186)
                      {
                        descriptor_t *bitRHS = getBIT (16, mRHS);
                        putBIT (16,
                                getFIXED (mINIT_TAB)
                                    + 2
                                          * (getFIXED (
                                              mWORKSEG
                                              + 4 * getFIXED (mCURRENT_ESDID)))
                                    + 0 + 2 * (0),
                                bitRHS);
                        bitRHS->inUse = 0;
                      }
                      // INIT_VAL(CURRENT_ADDRESS + 1) = RHS(1); (15187)
                      {
                        descriptor_t *bitRHS = getBIT (16, mRHS + 2 * 1);
                        putBIT (
                            16,
                            getFIXED (mINIT_TAB)
                                + 2
                                      * (xadd (
                                          getFIXED (
                                              mWORKSEG
                                              + 4 * getFIXED (mCURRENT_ESDID)),
                                          1))
                                + 0 + 2 * (0),
                            bitRHS);
                        bitRHS->inUse = 0;
                      }
                    es2s1s1s9s1:;
                    } // End of DO block
                  // LHS = 40; (15188)
                  {
                    int32_t numberRHS = (int32_t)(40);
                    descriptor_t *bitRHS;
                    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                    putBIT (16, mLHS, bitRHS);
                    bitRHS->inUse = 0;
                  }
                  // CALL EMIT_TEXT_CARD(4); (15189)
                  {
                    putBITp (16, mOBJECT_GENERATORxEMIT_TEXT_CARDxI,
                             fixedToBit (32, (int32_t)(4)));
                    OBJECT_GENERATORxEMIT_TEXT_CARD (0);
                  }
                  // ADDRESS_MOD = 0; (15190)
                  {
                    int32_t numberRHS = (int32_t)(0);
                    putFIXED (mOBJECT_GENERATORxADDRESS_MOD, numberRHS);
                  }
                es2s1s1s9:;
                } // End of DO block
                break;
              case 9:
                // DO; (15192)
                {
                rs2s1s1s10:;
                  // CALL NEXT_REC(1); (15192)
                  {
                    putBITp (16, mNEXT_RECxI, fixedToBit (32, (int32_t)(1)));
                    NEXT_REC (0);
                  }
                  // TEMP = LOCATION(RHS(1)) + ORIGIN(RHS); (15193)
                  {
                    int32_t numberRHS = (int32_t)(xadd (
                        getFIXED (getFIXED (mLAB_LOC)
                                  + 8 * (COREHALFWORD (mRHS + 2 * 1)) + 0
                                  + 4 * (0)),
                        getFIXED (mORIGIN + 4 * COREHALFWORD (mRHS))));
                    putFIXED (mTEMP, numberRHS);
                  }
                  // GO TO DO_HADCONS; (15194)
                  goto DO_HADCONS;
                es2s1s1s10:;
                } // End of DO block
                break;
              case 10:
                // DO; (15196)
                {
                rs2s1s1s11:;
                  // CALL NEXT_REC(1); (15196)
                  {
                    putBITp (16, mNEXT_RECxI, fixedToBit (32, (int32_t)(1)));
                    NEXT_REC (0);
                  }
                  // TEMP = (CONSTANT_PTR(RHS(1)) & FFOUR) + ORIGIN(RHS);
                  // (15197)
                  {
                    int32_t numberRHS = (int32_t)(xadd (
                        xAND (COREHALFWORD (mCONSTANT_PTR
                                            + 2 * COREHALFWORD (mRHS + 2 * 1)),
                              getFIXED (mOBJECT_GENERATORxFFOUR)),
                        getFIXED (mORIGIN + 4 * COREHALFWORD (mRHS))));
                    putFIXED (mTEMP, numberRHS);
                  }
                  // GO TO DO_HADCONS; (15198)
                  goto DO_HADCONS;
                es2s1s1s11:;
                } // End of DO block
                break;
              case 11:
                // DO; (15200)
                {
                rs2s1s1s12:;
                  // TEMP = CURRENT_ADDRESS; (15200)
                  {
                    int32_t numberRHS = (int32_t)(getFIXED (
                        mWORKSEG + 4 * getFIXED (mCURRENT_ESDID)));
                    putFIXED (mTEMP, numberRHS);
                  }
                  // RHS = EMIT_RLD(RHS, TEMP); (15201)
                  {
                    descriptor_t *bitRHS
                        = (putBITp (16, mOBJECT_GENERATORxEMIT_RLDxREL,
                                    getBIT (16, mRHS)),
                           putFIXED (mOBJECT_GENERATORxEMIT_RLDxADR,
                                     getFIXED (mTEMP)),
                           OBJECT_GENERATORxEMIT_RLD (0));
                    putBIT (16, mRHS, bitRHS);
                    bitRHS->inUse = 0;
                  }
                  // IF RHS <= PROCLIMIT THEN (15202)
                  if (1
                      & (xLE (COREHALFWORD (mRHS), COREHALFWORD (mPROCLIMIT))))
                    // TAG_NAME = SYT_NAME(PROC_LEVEL(RHS)); (15203)
                    {
                      descriptor_t *stringRHS;
                      stringRHS = getCHARACTER (
                          getFIXED (mSYM_TAB)
                          + 34
                                * (COREHALFWORD (mPROC_LEVEL
                                                 + 2 * COREHALFWORD (mRHS)))
                          + 0 + 4 * (0));
                      putCHARACTER (mOBJECT_GENERATORxTAG_NAME, stringRHS);
                      stringRHS->inUse = 0;
                    }
                  // ELSE (15204)
                  else
                    // TAG_NAME = ESD_TABLE(RHS); (15205)
                    {
                      descriptor_t *stringRHS;
                      stringRHS
                          = (putBITp (16, mESD_TABLExPTR, getBIT (16, mRHS)),
                             ESD_TABLE (0));
                      putCHARACTER (mOBJECT_GENERATORxTAG_NAME, stringRHS);
                      stringRHS->inUse = 0;
                    }
                es2s1s1s12:;
                } // End of DO block
                break;
              case 12:
                // DO; (15207)
                {
                rs2s1s1s13:;
                  // DO TEMP = 0 TO 8; (15207)
                  {
                    int32_t from150, to150, by150;
                    from150 = 0;
                    to150 = 8;
                    by150 = 1;
                    for (putFIXED (mTEMP, from150); getFIXED (mTEMP) <= to150;
                         putFIXED (mTEMP, getFIXED (mTEMP) + by150))
                      {
                        // MVH_COUNT(TEMP)=0; (15208)
                        {
                          int32_t numberRHS = (int32_t)(0);
                          descriptor_t *bitRHS;
                          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                          putBIT (16,
                                  mOBJECT_GENERATORxMVH_COUNT
                                      + 2 * (getFIXED (mTEMP)),
                                  bitRHS);
                          bitRHS->inUse = 0;
                        }
                        // MVH_CNT_KNOWN(TEMP)=FALSE; (15209)
                        {
                          int32_t numberRHS = (int32_t)(0);
                          descriptor_t *bitRHS;
                          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                          putBIT (1,
                                  mOBJECT_GENERATORxMVH_CNT_KNOWN
                                      + 1 * (getFIXED (mTEMP)),
                                  bitRHS);
                          bitRHS->inUse = 0;
                        }
                      }
                  } // End of DO for-loop block
                  // TAG_NAME = 'ST#'||RHS; (15210)
                  {
                    descriptor_t *stringRHS;
                    stringRHS = xsCAT (cToDescriptor (NULL, "ST#"),
                                       bitToCharacter (getBIT (16, mRHS)));
                    putCHARACTER (mOBJECT_GENERATORxTAG_NAME, stringRHS);
                    stringRHS->inUse = 0;
                  }
                  // CALL PRINT_LINE; (15211)
                  OBJECT_GENERATORxPRINT_LINE (0);
                es2s1s1s13:;
                } // End of DO block
                break;
              case 13:
                // ADDRESS_MOD = MAXTEMP(RHS); (15213)
                {
                  int32_t numberRHS = (int32_t)(getFIXED (
                      mMAXTEMP + 4 * COREHALFWORD (mRHS)));
                  putFIXED (mOBJECT_GENERATORxADDRESS_MOD, numberRHS);
                }
                break;
              case 14:
                // DO; (15214)
                {
                rs2s1s1s14:;
                  // ITEMP = RHS; (15214)
                  {
                    descriptor_t *bitRHS = getBIT (16, mRHS);
                    putBIT (16, mOBJECT_GENERATORxITEMP, bitRHS);
                    bitRHS->inUse = 0;
                  }
                  // DO WHILE ITEMP > 0; (15215)
                  while (1 & (xGT (COREHALFWORD (mOBJECT_GENERATORxITEMP), 0)))
                    {
                      // CALL NEXT_REC(1); (15216)
                      {
                        putBITp (16, mNEXT_RECxI,
                                 fixedToBit (32, (int32_t)(1)));
                        NEXT_REC (0);
                      }
                      // RHS = LHS(1); (15217)
                      {
                        descriptor_t *bitRHS = getBIT (16, mLHS + 2 * 1);
                        putBIT (16, mRHS, bitRHS);
                        bitRHS->inUse = 0;
                      }
                      // IF (CURRENT_ESDID=DATABASE) &  (CURRENT_ADDRESS <
                      // PROGDATA) THEN (15218)
                      if (1
                          & (xAND (
                              xEQ (getFIXED (mCURRENT_ESDID),
                                   COREHALFWORD (mDATABASE)),
                              xLT (getFIXED (mWORKSEG
                                             + 4 * getFIXED (mCURRENT_ESDID)),
                                   getFIXED (mPROGDATA)))))
                        // DO; (15219)
                        {
                        rs2s1s1s14s1s1:;
                          // IF ITEMP>2 THEN (15220)
                          if (1
                              & (xGT (COREHALFWORD (mOBJECT_GENERATORxITEMP),
                                      2)))
                            // CALL ZERO_INIT_VAL
                            // (RECORD_TOP(INIT_TAB)+1,CURRENT_ADDRESS+1);
                            // (15221)
                            {
                              putFIXED (mOBJECT_GENERATORxZERO_INIT_VALxFIRST,
                                        xadd (xsubtract (COREWORD (xadd (
                                                             ADDR ("INIT_TAB",
                                                                   0x80000000,
                                                                   NULL, 0),
                                                             12)),
                                                         1),
                                              1));
                              putFIXED (
                                  mOBJECT_GENERATORxZERO_INIT_VALxLAST,
                                  xadd (getFIXED (
                                            mWORKSEG
                                            + 4 * getFIXED (mCURRENT_ESDID)),
                                        1));
                              OBJECT_GENERATORxZERO_INIT_VAL (0);
                            }
                          // ELSE (15222)
                          else
                            // CALL ZERO_INIT_VAL
                            // (RECORD_TOP(INIT_TAB)+1,CURRENT_ADDRESS);
                            // (15223)
                            {
                              putFIXED (mOBJECT_GENERATORxZERO_INIT_VALxFIRST,
                                        xadd (xsubtract (COREWORD (xadd (
                                                             ADDR ("INIT_TAB",
                                                                   0x80000000,
                                                                   NULL, 0),
                                                             12)),
                                                         1),
                                              1));
                              putFIXED (
                                  mOBJECT_GENERATORxZERO_INIT_VALxLAST,
                                  getFIXED (mWORKSEG
                                            + 4 * getFIXED (mCURRENT_ESDID)));
                              OBJECT_GENERATORxZERO_INIT_VAL (0);
                            }
                          // INIT_VAL(CURRENT_ADDRESS) = RHS; (15224)
                          {
                            descriptor_t *bitRHS = getBIT (16, mRHS);
                            putBIT (
                                16,
                                getFIXED (mINIT_TAB)
                                    + 2
                                          * (getFIXED (
                                              mWORKSEG
                                              + 4 * getFIXED (mCURRENT_ESDID)))
                                    + 0 + 2 * (0),
                                bitRHS);
                            bitRHS->inUse = 0;
                          }
                          // IF ITEMP>2 THEN (15225)
                          if (1
                              & (xGT (COREHALFWORD (mOBJECT_GENERATORxITEMP),
                                      2)))
                            // INIT_VAL(CURRENT_ADDRESS + 1) = RHS(1); (15226)
                            {
                              descriptor_t *bitRHS = getBIT (16, mRHS + 2 * 1);
                              putBIT (
                                  16,
                                  getFIXED (mINIT_TAB)
                                      + 2
                                            * (xadd (
                                                getFIXED (
                                                    mWORKSEG
                                                    + 4
                                                          * getFIXED (
                                                              mCURRENT_ESDID)),
                                                1))
                                      + 0 + 2 * (0),
                                  bitRHS);
                              bitRHS->inUse = 0;
                            }
                        es2s1s1s14s1s1:;
                        } // End of DO block
                      // CALL EMIT_TEXT_CARD(MIN(4, ITEMP)); (15227)
                      {
                        putBITp (
                            16, mOBJECT_GENERATORxEMIT_TEXT_CARDxI,
                            fixedToBit (
                                32,
                                (int32_t)((
                                    putFIXED (mMINxVAL1, 4),
                                    putFIXED (mMINxVAL2,
                                              COREHALFWORD (
                                                  mOBJECT_GENERATORxITEMP)),
                                    MIN (0)))));
                        OBJECT_GENERATORxEMIT_TEXT_CARD (0);
                      }
                      // ITEMP = ITEMP - 4; (15228)
                      {
                        int32_t numberRHS = (int32_t)(xsubtract (
                            COREHALFWORD (mOBJECT_GENERATORxITEMP), 4));
                        descriptor_t *bitRHS;
                        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                        putBIT (16, mOBJECT_GENERATORxITEMP, bitRHS);
                        bitRHS->inUse = 0;
                      }
                    } // End of DO WHILE block
                es2s1s1s14:;
                } // End of DO block
                break;
              case 15:
                // GENERATING = FALSE; (15230)
                {
                  int32_t numberRHS = (int32_t)(0);
                  descriptor_t *bitRHS;
                  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                  putBIT (1, mGENERATING, bitRHS);
                  bitRHS->inUse = 0;
                }
                break;
              case 16:
                // DO; (15231)
                {
                rs2s1s1s15:;
                  // TAG_NAME = 'LBL#' || RHS; (15231)
                  {
                    descriptor_t *stringRHS;
                    stringRHS = xsCAT (cToDescriptor (NULL, "LBL#"),
                                       bitToCharacter (getBIT (16, mRHS)));
                    putCHARACTER (mOBJECT_GENERATORxTAG_NAME, stringRHS);
                    stringRHS->inUse = 0;
                  }
                  // CALL PRINT_LINE; (15232)
                  OBJECT_GENERATORxPRINT_LINE (0);
                es2s1s1s15:;
                } // End of DO block
                break;
              case 17:
                // DATA_LIST_OFF = RHS; (15234)
                {
                  descriptor_t *bitRHS = getBIT (16, mRHS);
                  putBIT (1, mOBJECT_GENERATORxDATA_LIST_OFF, bitRHS);
                  bitRHS->inUse = 0;
                }
                break;
              case 18:
                // IF EMITTING THEN (15235)
                if (1 & (bitToFixed (getBIT (1, mEMITTING))))
                  {
                  rs2s1s1s16:;
                    // CALL INST_ADDRS; (15236)
                    OBJECT_GENERATORxINST_ADDRS (0);
                    // RHS = GET_INST_R_X; (15237)
                    {
                      descriptor_t *bitRHS = GET_INST_R_X (0);
                      putBIT (16, mRHS, bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // OPCOUNT(INST) = OPCOUNT(INST) + 1; (15238)
                    {
                      int32_t numberRHS = (int32_t)(xadd (
                          COREHALFWORD (mOPCOUNT + 2 * getFIXED (mINST)), 1));
                      descriptor_t *bitRHS;
                      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                      putBIT (16, mOPCOUNT + 2 * (getFIXED (mINST)), bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // CALL NEXT_REC(1); (15239)
                    {
                      putBITp (16, mNEXT_RECxI, fixedToBit (32, (int32_t)(1)));
                      NEXT_REC (0);
                    }
                    // CALL FORM_BD(1); (15240)
                    {
                      putBITp (16, mOBJECT_GENERATORxFORM_BDxI,
                               fixedToBit (32, (int32_t)(1)));
                      OBJECT_GENERATORxFORM_BD (0);
                    }
                    // IF B >= 0 THEN (15241)
                    if (1 & (xGE (getFIXED (mB), 0)))
                      // RHS = RHS | B; (15242)
                      {
                        int32_t numberRHS = (int32_t)(xOR (COREHALFWORD (mRHS),
                                                           getFIXED (mB)));
                        descriptor_t *bitRHS;
                        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                        putBIT (16, mRHS, bitRHS);
                        bitRHS->inUse = 0;
                      }
                    // ELSE (15243)
                    else
                      // IF LHS(1) = SHCOUNT THEN (15244)
                      if (1
                          & (xEQ (COREHALFWORD (mLHS + 2 * 1),
                                  BYTE0 (mSHCOUNT))))
                        // RHS = RHS | SHL(56-B, 2); (15245)
                        {
                          int32_t numberRHS = (int32_t)(xOR (
                              COREHALFWORD (mRHS),
                              SHL (xsubtract (56, getFIXED (mB)), 2)));
                          descriptor_t *bitRHS;
                          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                          putBIT (16, mRHS, bitRHS);
                          bitRHS->inUse = 0;
                        }
                    // IF INST >=  80 & INST <  128 THEN (15246)
                    if (1
                        & (xAND (xGE (getFIXED (mINST), 80),
                                 xLT (getFIXED (mINST), 128))))
                      // ITEMP = 1; (15247)
                      {
                        int32_t numberRHS = (int32_t)(1);
                        descriptor_t *bitRHS;
                        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                        putBIT (16, mOBJECT_GENERATORxITEMP, bitRHS);
                        bitRHS->inUse = 0;
                      }
                    // ELSE (15248)
                    else
                      // ITEMP = 2; (15249)
                      {
                        int32_t numberRHS = (int32_t)(2);
                        descriptor_t *bitRHS;
                        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                        putBIT (16, mOBJECT_GENERATORxITEMP, bitRHS);
                        bitRHS->inUse = 0;
                      }
                    // RHS = RHS | SHL(R, 8) | SHL(D, ITEMP); (15250)
                    {
                      int32_t numberRHS = (int32_t)(xOR (
                          xOR (COREHALFWORD (mRHS), SHL (getFIXED (mR), 8)),
                          SHL (getFIXED (mD),
                               COREHALFWORD (mOBJECT_GENERATORxITEMP))));
                      descriptor_t *bitRHS;
                      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                      putBIT (16, mRHS, bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // CALL EMIT_TEXT_CARD(2); (15251)
                    {
                      putBITp (16, mOBJECT_GENERATORxEMIT_TEXT_CARDxI,
                               fixedToBit (32, (int32_t)(2)));
                      OBJECT_GENERATORxEMIT_TEXT_CARD (0);
                    }
                  es2s1s1s16:;
                  } // End of DO block
                else
                  SKIP_ADDR (0);
                break;
              case 19:
                // DO; (15255)
                {
                rs2s1s1s17:;
                  // CALL EMIT_CARD; (15255)
                  OBJECT_GENERATORxEMIT_CARD (0);
                  // CURRENT_ADDRESS = CURRENT_ADDRESS + RHS & (~RHS); (15256)
                  {
                    int32_t numberRHS = (int32_t)(xAND (
                        xadd (getFIXED (mWORKSEG
                                        + 4 * getFIXED (mCURRENT_ESDID)),
                              COREHALFWORD (mRHS)),
                        xNOT (COREHALFWORD (mRHS))));
                    putFIXED (mWORKSEG + 4 * (getFIXED (mCURRENT_ESDID)),
                              numberRHS);
                  }
                es2s1s1s17:;
                } // End of DO block
                break;
              case 20:
                // CALL SKIP_ADDR; (15258)
                SKIP_ADDR (0);
                break;
              case 21:
                // DO; (15259)
                {
                rs2s1s1s18:;
                  // CALL NEXT_REC(1); (15259)
                  {
                    putBITp (16, mNEXT_RECxI, fixedToBit (32, (int32_t)(1)));
                    NEXT_REC (0);
                  }
                  // IF ESD_TYPE(RHS) ~= 2 THEN (15260)
                  if (1
                      & (xNEQ (BYTE0 (mESD_TYPE + 1 * COREHALFWORD (mRHS)),
                               2)))
                    // TEMP = TEMP + ORIGIN(RHS); (15261)
                    {
                      int32_t numberRHS = (int32_t)(xadd (
                          getFIXED (mTEMP),
                          getFIXED (mORIGIN + 4 * COREHALFWORD (mRHS))));
                      putFIXED (mTEMP, numberRHS);
                    }
                // DO_HADCONS: (15262)
                DO_HADCONS:
                  // CALL SET_ADDR_RHS; (15263)
                  OBJECT_GENERATORxSET_ADDR_RHS (0);
                  // IF (CURRENT_ESDID=DATABASE) &  (CURRENT_ADDRESS <
                  // PROGDATA) THEN (15264)
                  if (1
                      & (xAND (xEQ (getFIXED (mCURRENT_ESDID),
                                    COREHALFWORD (mDATABASE)),
                               xLT (getFIXED (mWORKSEG
                                              + 4 * getFIXED (mCURRENT_ESDID)),
                                    getFIXED (mPROGDATA)))))
                    // DO; (15265)
                    {
                    rs2s1s1s18s1:;
                      // CALL ZERO_INIT_VAL
                      // (RECORD_TOP(INIT_TAB)+1,CURRENT_ADDRESS); (15266)
                      {
                        putFIXED (
                            mOBJECT_GENERATORxZERO_INIT_VALxFIRST,
                            xadd (xsubtract (COREWORD (xadd (ADDR ("INIT_TAB",
                                                                   0x80000000,
                                                                   NULL, 0),
                                                             12)),
                                             1),
                                  1));
                        putFIXED (mOBJECT_GENERATORxZERO_INIT_VALxLAST,
                                  getFIXED (mWORKSEG
                                            + 4 * getFIXED (mCURRENT_ESDID)));
                        OBJECT_GENERATORxZERO_INIT_VAL (0);
                      }
                      // INIT_VAL(CURRENT_ADDRESS) = RHS; (15267)
                      {
                        descriptor_t *bitRHS = getBIT (16, mRHS);
                        putBIT (16,
                                getFIXED (mINIT_TAB)
                                    + 2
                                          * (getFIXED (
                                              mWORKSEG
                                              + 4 * getFIXED (mCURRENT_ESDID)))
                                    + 0 + 2 * (0),
                                bitRHS);
                        bitRHS->inUse = 0;
                      }
                    es2s1s1s18s1:;
                    } // End of DO block
                  // LHS = 0; (15268)
                  {
                    int32_t numberRHS = (int32_t)(0);
                    descriptor_t *bitRHS;
                    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                    putBIT (16, mLHS, bitRHS);
                    bitRHS->inUse = 0;
                  }
                  // CALL EMIT_TEXT_CARD(2); (15269)
                  {
                    putBITp (16, mOBJECT_GENERATORxEMIT_TEXT_CARDxI,
                             fixedToBit (32, (int32_t)(2)));
                    OBJECT_GENERATORxEMIT_TEXT_CARD (0);
                  }
                  // ADDRESS_MOD = 0; (15270)
                  {
                    int32_t numberRHS = (int32_t)(0);
                    putFIXED (mOBJECT_GENERATORxADDRESS_MOD, numberRHS);
                  }
                es2s1s1s18:;
                } // End of DO block
                break;
              case 22:
                // DO; (15272)
                {
                rs2s1s1s19:;
                es2s1s1s19:;
                } // End of DO block
                break;
              case 23:
                // DO; (15273)
                {
                rs2s1s1s20:;
                  // CALL NEXT_REC(1); (15273)
                  {
                    putBITp (16, mNEXT_RECxI, fixedToBit (32, (int32_t)(1)));
                    NEXT_REC (0);
                  }
                  // TEMP = LHS(1); (15274)
                  {
                    descriptor_t *bitRHS = getBIT (16, mLHS + 2 * 1);
                    int32_t numberRHS;
                    numberRHS = bitToFixed (bitRHS);
                    putFIXED (mTEMP, numberRHS);
                    bitRHS->inUse = 0;
                  }
                  // IF ESD_TYPE(RHS) ~= 2 THEN (15275)
                  if (1
                      & (xNEQ (BYTE0 (mESD_TYPE + 1 * COREHALFWORD (mRHS)),
                               2)))
                    // TEMP = TEMP + ORIGIN(RHS); (15276)
                    {
                      int32_t numberRHS = (int32_t)(xadd (
                          getFIXED (mTEMP),
                          getFIXED (mORIGIN + 4 * COREHALFWORD (mRHS))));
                      putFIXED (mTEMP, numberRHS);
                    }
                  // GO TO DO_ADCONS; (15277)
                  goto DO_ADCONS;
                es2s1s1s20:;
                } // End of DO block
                break;
              case 24:
                // DO; (15279)
                {
                rs2s1s1s21:;
                  // CALL EMIT_ADDRS(RHS, ERRSEG(CURRENT_ESDID),
                  // STACKSPACE(CURRENT_ESDID)); (15279)
                  {
                    putBITp (16, mEMIT_ADDRSxSTMT_NO, getBIT (16, mRHS));
                    putFIXED (
                        mEMIT_ADDRSxADDR1,
                        getFIXED (mERRSEG + 4 * getFIXED (mCURRENT_ESDID)));
                    putFIXED (mEMIT_ADDRSxADDR2,
                              getFIXED (mSTACKSPACE
                                        + 4 * getFIXED (mCURRENT_ESDID)));
                    EMIT_ADDRS (0);
                  }
                // NEW_FIRST_INST: (15280)
                NEW_FIRST_INST:
                  // ERRSEG(CURRENT_ESDID) = CURRENT_ADDRESS; (15281)
                  {
                    int32_t numberRHS = (int32_t)(getFIXED (
                        mWORKSEG + 4 * getFIXED (mCURRENT_ESDID)));
                    putFIXED (mERRSEG + 4 * (getFIXED (mCURRENT_ESDID)),
                              numberRHS);
                  }
                  // STACKSPACE(CURRENT_ESDID) = 0; (15282)
                  {
                    int32_t numberRHS = (int32_t)(0);
                    putFIXED (mSTACKSPACE + 4 * (getFIXED (mCURRENT_ESDID)),
                              numberRHS);
                  }
                  // FIRST_INST = TRUE; (15283)
                  {
                    int32_t numberRHS = (int32_t)(1);
                    descriptor_t *bitRHS;
                    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                    putBIT (1, mFIRST_INST, bitRHS);
                    bitRHS->inUse = 0;
                  }
                es2s1s1s21:;
                } // End of DO block
                break;
              case 25:
                // GO TO NEW_FIRST_INST; (15285)
                goto NEW_FIRST_INST;
                break;
              case 26:
                // DO; (15286)
                {
                rs2s1s1s22:;
                  // CALL NEXT_REC; (15286)
                  NEXT_REC (0);
                  // CODE_LINE = TEMP; (15287)
                  {
                    int32_t numberRHS = (int32_t)(getFIXED (mTEMP));
                    putFIXED (mCODE_LINE, numberRHS);
                  }
                es2s1s1s22:;
                } // End of DO block
                break;
              case 27:
                // DO; (15289)
                {
                rs2s1s1s23:;
                  // TEMP1=CODE_LINE; (15289)
                  {
                    int32_t numberRHS = (int32_t)(getFIXED (mCODE_LINE));
                    descriptor_t *bitRHS;
                    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                    putBIT (16, mOBJECT_GENERATORxTEMP1, bitRHS);
                    bitRHS->inUse = 0;
                  }
                  // CODE_LINE=MAX_CODE_LINE; (15290)
                  {
                    int32_t numberRHS = (int32_t)(getFIXED (mMAX_CODE_LINE));
                    putFIXED (mCODE_LINE, numberRHS);
                  }
                es2s1s1s23:;
                } // End of DO block
                break;
              case 28:
                // DO; (15292)
                {
                rs2s1s1s24:;
                  // MAX_CODE_LINE=CODE_LINE; (15292)
                  {
                    int32_t numberRHS = (int32_t)(getFIXED (mCODE_LINE));
                    putFIXED (mMAX_CODE_LINE, numberRHS);
                  }
                  // CODE_LINE=TEMP1+RHS-1; (15293)
                  {
                    int32_t numberRHS = (int32_t)(xsubtract (
                        xadd (COREHALFWORD (mOBJECT_GENERATORxTEMP1),
                              COREHALFWORD (mRHS)),
                        1));
                    putFIXED (mCODE_LINE, numberRHS);
                  }
                es2s1s1s24:;
                } // End of DO block
                break;
              case 29:
                  // ; (15295)
                  ;
                break;
              }
          } // End of DO CASE block
        es2s1:;
        } // End of DO block
      // ELSE (15295)
      else
        // IF LHS=0 THEN (15296)
        if (1 & (xEQ (COREHALFWORD (mLHS), 0)))
          // DO; (15297)
          {
          rs2s2:;
            // RHS = RHS + ADDRESS_MOD; (15298)
            {
              int32_t numberRHS
                  = (int32_t)(xadd (COREHALFWORD (mRHS),
                                    getFIXED (mOBJECT_GENERATORxADDRESS_MOD)));
              descriptor_t *bitRHS;
              bitRHS = fixedToBit (32, (int32_t)(numberRHS));
              putBIT (16, mRHS, bitRHS);
              bitRHS->inUse = 0;
            }
            // IF (CURRENT_ESDID=DATABASE) &  (CURRENT_ADDRESS < PROGDATA) THEN
            // (15299)
            if (1
                & (xAND (
                    xEQ (getFIXED (mCURRENT_ESDID), COREHALFWORD (mDATABASE)),
                    xLT (getFIXED (mWORKSEG + 4 * getFIXED (mCURRENT_ESDID)),
                         getFIXED (mPROGDATA)))))
              // DO; (15300)
              {
              rs2s2s1:;
                // CALL ZERO_INIT_VAL (RECORD_TOP(INIT_TAB)+1,CURRENT_ADDRESS);
                // (15301)
                {
                  putFIXED (mOBJECT_GENERATORxZERO_INIT_VALxFIRST,
                            xadd (xsubtract (COREWORD (xadd (ADDR ("INIT_TAB",
                                                                   0x80000000,
                                                                   NULL, 0),
                                                             12)),
                                             1),
                                  1));
                  putFIXED (
                      mOBJECT_GENERATORxZERO_INIT_VALxLAST,
                      getFIXED (mWORKSEG + 4 * getFIXED (mCURRENT_ESDID)));
                  OBJECT_GENERATORxZERO_INIT_VAL (0);
                }
                // INIT_VAL(CURRENT_ADDRESS) = RHS; (15302)
                {
                  descriptor_t *bitRHS = getBIT (16, mRHS);
                  putBIT (
                      16,
                      getFIXED (mINIT_TAB)
                          + 2
                                * (getFIXED (mWORKSEG
                                             + 4 * getFIXED (mCURRENT_ESDID)))
                          + 0 + 2 * (0),
                      bitRHS);
                  bitRHS->inUse = 0;
                }
              es2s2s1:;
              } // End of DO block
            // ADDRESS_MOD = 0; (15303)
            {
              int32_t numberRHS = (int32_t)(0);
              putFIXED (mOBJECT_GENERATORxADDRESS_MOD, numberRHS);
            }
            // CALL EMIT_TEXT_CARD(2); (15304)
            {
              putBITp (16, mOBJECT_GENERATORxEMIT_TEXT_CARDxI,
                       fixedToBit (32, (int32_t)(2)));
              OBJECT_GENERATORxEMIT_TEXT_CARD (0);
            }
          es2s2:;
          } // End of DO block
    }       // End of DO WHILE block
  // IF CODE_LISTING_REQUESTED THEN (15305)
  if (1 & (bitToFixed (getBIT (1, mCODE_LISTING_REQUESTED))))
    // CALL APRINT(SUBSTR(X72, 26) || 'END'); (15306)
    {
      putCHARACTERp (mOBJECT_GENERATORxAPRINTxLINE,
                     xsCAT (SUBSTR2 (getCHARACTER (mX72), 26),
                            cToDescriptor (NULL, "END")));
      OBJECT_GENERATORxAPRINT (0);
    }
  // CALL EMIT_RLD_CARDS; (15307)
  OBJECT_GENERATORxEMIT_RLD_CARDS (0);
  // CALL EMIT_CARD; (15308)
  OBJECT_GENERATORxEMIT_CARD (0);
  // CARDIMAGE, CARDIMAGE(1) = END_CARD; (15309)
  {
    int32_t numberRHS = (int32_t)(getFIXED (mOBJECT_GENERATORxEND_CARD));
    putFIXED (mOBJECT_GENERATORxCARDIMAGE, numberRHS);
    putFIXED (mOBJECT_GENERATORxCARDIMAGE + 4 * (1), numberRHS);
  }
  // DUMMY = DESC(MONITOR(23)); (15310)
  {
    descriptor_t *stringRHS;
    stringRHS = MONITOR23 ();
    putCHARACTER (mDUMMY, stringRHS);
    stringRHS->inUse = 0;
  }
  // DUMMY = SUBSTR(DUMMY, LENGTH(DUMMY)-10, 10); (15311)
  {
    descriptor_t *stringRHS;
    stringRHS = SUBSTR (getCHARACTER (mDUMMY),
                        xsubtract (LENGTH (getCHARACTER (mDUMMY)), 10), 10);
    putCHARACTER (mDUMMY, stringRHS);
    stringRHS->inUse = 0;
  }
  // DUMMY = SUBSTR(DUMMY,0,4)||BLANK||SUBSTR(DUMMY,5,2)||SUBSTR(DUMMY,8,2);
  // (15312)
  {
    descriptor_t *stringRHS;
    stringRHS = xsCAT (xsCAT (xsCAT (SUBSTR (getCHARACTER (mDUMMY), 0, 4),
                                     getCHARACTER (mBLANK)),
                              SUBSTR (getCHARACTER (mDUMMY), 5, 2)),
                       SUBSTR (getCHARACTER (mDUMMY), 8, 2));
    putCHARACTER (mDUMMY, stringRHS);
    stringRHS->inUse = 0;
  }
  // DUMMY = '2HAL/S'||DUMMY||SUBSTR(100000+DATE,1)||'RSB-XCOM-I'
  // ||XVERSION||SUBSTR(100000 + DATE_OF_GENERATION, 1); (15313)
  {
    descriptor_t *stringRHS;
    stringRHS = xsCAT (
        xsCAT (
            xsCAT (xsCAT (xsCAT (xsCAT (cToDescriptor (NULL, "2HAL/S"),
                                        getCHARACTER (mDUMMY)),
                                 SUBSTR2 (
                                     fixedToCharacter (xadd (100000, DATE ())),
                                     1)),
                          cToDescriptor (NULL, "RSB-XCOM-I")),
                   SUBSTR2 (
                       fixedToCharacter (xadd (XPL_COMPILER_VERSION (0), 100)),
                       1)),
            SUBSTR2 (fixedToCharacter (xadd (XPL_COMPILER_VERSION (1), 100)),
                     1)),
        SUBSTR2 (fixedToCharacter (xadd (100000, DATE_OF_GENERATION ())), 1));
    putCHARACTER (mDUMMY, stringRHS);
    stringRHS->inUse = 0;
  }
  {   // (50) CALL INLINE ( 88,2,0,DUMMY);
    { /*
       * File:      patch50p.c
       * For:       OBJECT_GENERATOR.c
       * Notes:     1. Page references are from IBM "ESA/390 Principles of
       *               Operation", SA22-7201-08, Ninth Edition, June 2003.
       *            2. Labels are of the form p%d_%d, where the 1st number
       *               indicates the leading patch number of the block, and
       *               the 2nd is the byte offset of the instruction within
       *               within the block.
       *            3. Known-problematic translations are marked with the
       *               string  "* * * F I X M E * * *" (without spaces).
       * History:   2024-07-18 RSB  Auto-generated by XCOM-I --guess=....
       *                            Inspected.
       */

      p50_0:;
  // (50)    CALL INLINE ("58",2,0,DUMMY);
  address360B = (mDUMMY)&0xFFFFFF;
  // Type RX, p. 7-7:		L	2,mDUMMY(0,0)
  detailedInlineBefore (50, "L	2,mDUMMY(0,0)");
  GR[2] = COREWORD (address360B);
  detailedInlineAfter ();

p50_4:;
  // (51)    CALL INLINE ("41",1,0,COLUMN);
  address360B = (mOBJECT_GENERATORxCOLUMN)&0xFFFFFF;
  // Type RX, p. 7-78:		LA	1,mOBJECT_GENERATORxCOLUMN(0,0)
  detailedInlineBefore (51, "LA	1,mOBJECT_GENERATORxCOLUMN(0,0)");
  GR[1] = address360B & 0xFFFFFF;
  detailedInlineAfter ();

p50_8:;
  // (52)    CALL INLINE("D2",2,6,1,32,2,0);
  address360A = (GR[1] + 32) & 0xFFFFFF;
  address360B = (GR[2] + 0) & 0xFFFFFF;
  // Type SS, p. 7-83:		MVC	32(38,1),0(2)
  detailedInlineBefore (52, "MVC	32(38,1),0(2)");
  mvc (address360A, address360B, 38);
  detailedInlineAfter ();

p50_14:;
}
}
; // (51) CALL INLINE ( 65,1,0,COLUMN);
; // (52) CALL INLINE( 210,2,6,1,32,2,0);
// BYTES_REMAINING = 0; (15317)
{
  int32_t numberRHS = (int32_t)(0);
  descriptor_t *bitRHS;
  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
  putBIT (16, mOBJECT_GENERATORxBYTES_REMAINING, bitRHS);
  bitRHS->inUse = 0;
}
// CALL EMIT_CARD; (15318)
OBJECT_GENERATORxEMIT_CARD (0);
// CALL MONITOR(17, PAD(THISPROGRAM, 8)); (15319)
MONITOR17 ((putCHARACTERp (mPADxSTRING, (putBITp (16, mESD_TABLExPTR,
                                                  getBIT (16, mPROGPOINT)),
                                         ESD_TABLE (0))),
            putFIXED (mPADxWIDTH, 8), PAD (0)));
// IF ~SDL THEN (15320)
if (1 & (xNOT (BYTE0 (mSDL))))
  // IF CALL#(PROGPOINT) THEN (15321)
  if (1 & (bitToFixed (getBIT (8, mCALLp + 1 * COREHALFWORD (mPROGPOINT)))))
    // DO; (15322)
    {
    rs3:;
      // TMP = SELFNAMELOC; (15323)
      {
        descriptor_t *bitRHS = getBIT (16, mSELFNAMELOC);
        int32_t numberRHS;
        numberRHS = bitToFixed (bitRHS);
        putFIXED (mTMP, numberRHS);
        bitRHS->inUse = 0;
      }
      // DO WHILE TMP > 0; (15324)
      while (1 & (xGT (getFIXED (mTMP), 0)))
        {
          // S1 = ' STACK ' || ESD_TABLE(SYT_SCOPE(TMP)); (15325)
          {
            descriptor_t *stringRHS;
            stringRHS
                = xsCAT (cToDescriptor (NULL, " STACK "),
                         (putBITp (16, mESD_TABLExPTR,
                                   getBIT (8, getFIXED (mSYM_TAB)
                                                  + 34 * (getFIXED (mTMP)) + 29
                                                  + 1 * (0))),
                          ESD_TABLE (0)));
            putCHARACTER (mOBJECT_GENERATORxS1, stringRHS);
            stringRHS->inUse = 0;
          }
          // IF MAX_SEVERITY = 0 THEN (15326)
          if (1 & (xEQ (COREHALFWORD (mMAX_SEVERITY), 0)))
            // DO; (15327)
            {
            rs3s1s1:;
              // OUTPUT(3) = S1; (15328)
              {
                descriptor_t *stringRHS;
                stringRHS = getCHARACTER (mOBJECT_GENERATORxS1);
                OUTPUT (3, stringRHS);
                stringRHS->inUse = 0;
              }
              // IF DECK_REQUESTED THEN (15329)
              if (1 & (bitToFixed (getBIT (1, mDECK_REQUESTED))))
                // OUTPUT(4) = S1; (15330)
                {
                  descriptor_t *stringRHS;
                  stringRHS = getCHARACTER (mOBJECT_GENERATORxS1);
                  OUTPUT (4, stringRHS);
                  stringRHS->inUse = 0;
                }
            es3s1s1:;
            } // End of DO block
          // TMP = SYT_LINK1(TMP); (15331)
          {
            descriptor_t *bitRHS
                = getBIT (16, getFIXED (mSYM_TAB) + 34 * (getFIXED (mTMP)) + 24
                                  + 2 * (0));
            int32_t numberRHS;
            numberRHS = bitToFixed (bitRHS);
            putFIXED (mTMP, numberRHS);
            bitRHS->inUse = 0;
          }
        } // End of DO WHILE block
      // ITEMP = CODE_LISTING_REQUESTED; (15332)
      {
        descriptor_t *bitRHS = getBIT (1, mCODE_LISTING_REQUESTED);
        putBIT (16, mOBJECT_GENERATORxITEMP, bitRHS);
        bitRHS->inUse = 0;
      }
      // TMP = DATABASE; (15333)
      {
        descriptor_t *bitRHS = getBIT (16, mDATABASE);
        int32_t numberRHS;
        numberRHS = bitToFixed (bitRHS);
        putFIXED (mTMP, numberRHS);
        bitRHS->inUse = 0;
      }
      // OP2 = PROGPOINT; (15334)
      {
        descriptor_t *bitRHS = getBIT (16, mPROGPOINT);
        putBIT (16, mOP2, bitRHS);
        bitRHS->inUse = 0;
      }
      // CODE_LISTING_REQUESTED = FALSE; (15335)
      {
        int32_t numberRHS = (int32_t)(0);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (1, mCODE_LISTING_REQUESTED, bitRHS);
        bitRHS->inUse = 0;
      }
      // CALL ENTER_ESD(THISPROGRAM, 2, 2); (15336)
      {
        putCHARACTERp (mENTER_ESDxNAME,
                       (putBITp (16, mESD_TABLExPTR, getBIT (16, mPROGPOINT)),
                        ESD_TABLE (0)));
        putBITp (16, mENTER_ESDxPTR, fixedToBit (32, (int32_t)(2)));
        putBITp (16, mENTER_ESDxTYP, fixedToBit (32, (int32_t)(2)));
        ENTER_ESD (0);
      }
      // CALL ENTER_ESD('START', 1, 0); (15337)
      {
        putCHARACTERp (mENTER_ESDxNAME, cToDescriptor (NULL, "START"));
        putBITp (16, mENTER_ESDxPTR, fixedToBit (32, (int32_t)(1)));
        putBITp (16, mENTER_ESDxTYP, fixedToBit (32, (int32_t)(0)));
        ENTER_ESD (0);
      }
      // LOCCTR(1) = 2; (15338)
      {
        int32_t numberRHS = (int32_t)(2);
        putFIXED (mLOCCTR + 4 * (1), numberRHS);
      }
      // ESD_MAX = 2; (15339)
      {
        int32_t numberRHS = (int32_t)(2);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mESD_MAX, bitRHS);
        bitRHS->inUse = 0;
      }
      // DATABASE = 3; (15340)
      {
        int32_t numberRHS = (int32_t)(3);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mDATABASE, bitRHS);
        bitRHS->inUse = 0;
      }
      // CALL EMIT_ESD_CARDS; (15341)
      OBJECT_GENERATORxEMIT_ESD_CARDS (0);
      // LHS = 39; (15342)
      {
        int32_t numberRHS = (int32_t)(39);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mLHS, bitRHS);
        bitRHS->inUse = 0;
      }
      // CURRENT_ESDID = 1; (15343)
      {
        int32_t numberRHS = (int32_t)(1);
        putFIXED (mCURRENT_ESDID, numberRHS);
      }
      // RHS(1), CURRENT_ADDRESS = 0; (15344)
      {
        int32_t numberRHS = (int32_t)(0);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mRHS + 2 * (1), bitRHS);
        putFIXED (mWORKSEG + 4 * (getFIXED (mCURRENT_ESDID)), numberRHS);
        bitRHS->inUse = 0;
      }
      // RHS =  58611; (15345)
      {
        int32_t numberRHS = (int32_t)(58611);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mRHS, bitRHS);
        bitRHS->inUse = 0;
      }
      // CALL EMIT_TEXT_CARD(4); (15346)
      {
        putBITp (16, mOBJECT_GENERATORxEMIT_TEXT_CARDxI,
                 fixedToBit (32, (int32_t)(4)));
        OBJECT_GENERATORxEMIT_TEXT_CARD (0);
      }
      // RLD#, RLD_POS_HEAD(1) = 1; (15347)
      {
        int32_t numberRHS = (int32_t)(1);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mOBJECT_GENERATORxRLDp, bitRHS);
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mLASTBASE + 2 * (1), bitRHS);
        bitRHS->inUse = 0;
      }
      // TEMP = GET_RLD(1); (15348)
      {
        int32_t numberRHS
            = (int32_t)((putFIXED (mOBJECT_GENERATORxGET_RLDxPTR, 1),
                         OBJECT_GENERATORxGET_RLD (0)));
        putFIXED (mTEMP, numberRHS);
      }
      // RLD_ADDR(TEMP) = 1; (15349)
      {
        int32_t numberRHS = (int32_t)(1);
        putFIXED (getFIXED (mLIT_PG) + 1560 * (0) + 520
                      + 4 * (getFIXED (mTEMP)),
                  numberRHS);
      }
      // RLD_LINK(TEMP) = 0; (15350)
      {
        int32_t numberRHS = (int32_t)(0);
        putFIXED (getFIXED (mLIT_PG) + 1560 * (0) + 1040
                      + 4 * (getFIXED (mTEMP)),
                  numberRHS);
      }
      // RLD_REF(TEMP) = 2; (15351)
      {
        int32_t numberRHS = (int32_t)(2);
        putFIXED (getFIXED (mLIT_PG) + 1560 * (0) + 0 + 4 * (getFIXED (mTEMP)),
                  numberRHS);
      }
      // PROGPOINT, DATABASE = 1; (15352)
      {
        int32_t numberRHS = (int32_t)(1);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mPROGPOINT, bitRHS);
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mDATABASE, bitRHS);
        bitRHS->inUse = 0;
      }
      // CALL EMIT_RLD_CARDS; (15353)
      OBJECT_GENERATORxEMIT_RLD_CARDS (0);
      // CALL EMIT_CARD; (15354)
      OBJECT_GENERATORxEMIT_CARD (0);
      // CARDIMAGE, CARDIMAGE(1) = END_CARD; (15355)
      {
        int32_t numberRHS = (int32_t)(getFIXED (mOBJECT_GENERATORxEND_CARD));
        putFIXED (mOBJECT_GENERATORxCARDIMAGE, numberRHS);
        putFIXED (mOBJECT_GENERATORxCARDIMAGE + 4 * (1), numberRHS);
      }
      // CARDIMAGE(2) =  1073741824; (15356)
      {
        int32_t numberRHS = (int32_t)(1073741824);
        putFIXED (mOBJECT_GENERATORxCARDIMAGE + 4 * (2), numberRHS);
      }
      // CARDIMAGE(4) =  1077936129; (15357)
      {
        int32_t numberRHS = (int32_t)(1077936129);
        putFIXED (mOBJECT_GENERATORxCARDIMAGE + 4 * (4), numberRHS);
      }
      {   // (53) CALL INLINE( 88,2,0,DUMMY);
        { /*
           * File:      patch53p.c
           * For:       OBJECT_GENERATOR.c
           * Notes:     1. Page references are from IBM "ESA/390 Principles of
           *               Operation", SA22-7201-08, Ninth Edition, June 2003.
           *            2. Labels are of the form p%d_%d, where the 1st number
           *               indicates the leading patch number of the block, and
           *               the 2nd is the byte offset of the instruction within
           *               within the block.
           *            3. Known-problematic translations are marked with the
           *               string  "* * * F I X M E * * *" (without spaces).
           * History:   2024-07-18 RSB  Auto-generated by XCOM-I --guess=....
           *                            Inspected.
           */

          p53_0:;
      // (53)       CALL INLINE("58",2,0,DUMMY);
      address360B = (mDUMMY)&0xFFFFFF;
      // Type RX, p. 7-7:		L	2,mDUMMY(0,0)
      detailedInlineBefore (53, "L	2,mDUMMY(0,0)");
      GR[2] = COREWORD (address360B);
      detailedInlineAfter ();

    p53_4:;
      // (54)       CALL INLINE("41",1,0,COLUMN);
      address360B = (mOBJECT_GENERATORxCOLUMN)&0xFFFFFF;
      // Type RX, p. 7-78:		LA	1,mOBJECT_GENERATORxCOLUMN(0,0)
      detailedInlineBefore (54, "LA	1,mOBJECT_GENERATORxCOLUMN(0,0)");
      GR[1] = address360B & 0xFFFFFF;
      detailedInlineAfter ();

    p53_8:;
      // (55)       CALL INLINE("D2",2,6,1,32,2,0);
      address360A = (GR[1] + 32) & 0xFFFFFF;
      address360B = (GR[2] + 0) & 0xFFFFFF;
      // Type SS, p. 7-83:		MVC	32(38,1),0(2)
      detailedInlineBefore (55, "MVC	32(38,1),0(2)");
      mvc (address360A, address360B, 38);
      detailedInlineAfter ();

    p53_14:;
    }
}
; // (54) CALL INLINE( 65,1,0,COLUMN);
; // (55) CALL INLINE( 210,2,6,1,32,2,0);
// BYTES_REMAINING = 0; (15361)
{
  int32_t numberRHS = (int32_t)(0);
  descriptor_t *bitRHS;
  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
  putBIT (16, mOBJECT_GENERATORxBYTES_REMAINING, bitRHS);
  bitRHS->inUse = 0;
}
// CALL EMIT_CARD; (15362)
OBJECT_GENERATORxEMIT_CARD (0);
// CODE_LISTING_REQUESTED = ITEMP; (15363)
{
  descriptor_t *bitRHS = getBIT (16, mOBJECT_GENERATORxITEMP);
  putBIT (1, mCODE_LISTING_REQUESTED, bitRHS);
  bitRHS->inUse = 0;
}
// DATABASE = TMP; (15364)
{
  int32_t numberRHS = (int32_t)(getFIXED (mTMP));
  descriptor_t *bitRHS;
  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
  putBIT (16, mDATABASE, bitRHS);
  bitRHS->inUse = 0;
}
// PROGPOINT = OP2; (15365)
{
  descriptor_t *bitRHS = getBIT (16, mOP2);
  putBIT (16, mPROGPOINT, bitRHS);
  bitRHS->inUse = 0;
}
es3:;
} // End of DO block
// IF CODE_LISTING_REQUESTED THEN (15366)
if (1 & (bitToFixed (getBIT (1, mCODE_LISTING_REQUESTED))))
  // DO; (15367)
  {
  rs4:;
    // CALL AHEADSET(3); (15368)
    {
      putBITp (16, mOBJECT_GENERATORxAHEADSETxN,
               fixedToBit (32, (int32_t)(3)));
      OBJECT_GENERATORxAHEADSET (0);
    }
    // CALL APRINT(BLANK); (15369)
    {
      putCHARACTERp (mOBJECT_GENERATORxAPRINTxLINE, getCHARACTER (mBLANK));
      OBJECT_GENERATORxAPRINT (0);
    }
    // CALL MONITOR(0, 7); (15370)
    MONITOR0 (7);
  es4:;
  } // End of DO block
// CALL ZERO_INIT_VAL(RECORD_TOP(INIT_TAB)+1,PROGDATA-1); (15371)
{
  putFIXED (mOBJECT_GENERATORxZERO_INIT_VALxFIRST,
            xadd (xsubtract (COREWORD (xadd (
                                 ADDR ("INIT_TAB", 0x80000000, NULL, 0), 12)),
                             1),
                  1));
  putFIXED (mOBJECT_GENERATORxZERO_INIT_VALxLAST,
            xsubtract (getFIXED (mPROGDATA), 1));
  OBJECT_GENERATORxZERO_INIT_VAL (0);
}
// RECORD_SEAL(INIT_TAB); (15372)
{
  putFIXED (m_RECORD_SEALxDOPE, ADDR ("INIT_TAB", 0x80000000, NULL, 0));
  _RECORD_SEAL (0);
}
{
  reentryGuard = 0;
  return 0;
}
}
