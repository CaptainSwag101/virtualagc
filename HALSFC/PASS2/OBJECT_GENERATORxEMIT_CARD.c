/*
  File OBJECT_GENERATORxEMIT_CARD.c generated by XCOM-I, 2024-08-09 12:39:31.
*/

#include "runtimeC.h"

int32_t
OBJECT_GENERATORxEMIT_CARD (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "OBJECT_GENERATORxEMIT_CARD");
  // IF FIRST_TIME THEN (15420)
  if (1 & (bitToFixed (getBIT (1, mOBJECT_GENERATORxFIRST_TIME))))
    // DO; (15421)
    {
    rs1:;
      // COREWORD(ADDR(DUMMY_CHAR))=(ADDR(COLUMN) |  1325400064); (15422)
      {
        int32_t numberRHS = (int32_t)(xOR (
            ADDR (NULL, 0, "OBJECT_GENERATORxCOLUMN", 0), 1325400064));
        COREWORD2 (ADDR (NULL, 0, "OBJECT_GENERATORxDUMMY_CHAR", 0),
                   numberRHS);
      }
      // FIRST_TIME= 0; (15423)
      {
        int32_t numberRHS = (int32_t)(0);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (1, mOBJECT_GENERATORxFIRST_TIME, bitRHS);
        bitRHS->inUse = 0;
      }
    es1:;
    } // End of DO block
  // ELSE (15424)
  else
    // DO; (15425)
    {
    rs2:;
      // IF (BYTES_REMAINING-CURRENT_SIZE)*CARDIMAGE=0 THEN (15426)
      if (1
          & (xEQ (
              xmultiply (
                  xsubtract (COREHALFWORD (mOBJECT_GENERATORxBYTES_REMAINING),
                             COREHALFWORD (mOBJECT_GENERATORxCURRENT_SIZE)),
                  getFIXED (mOBJECT_GENERATORxCARDIMAGE)),
              0)))
        // RETURN; (15427)
        {
          reentryGuard = 0;
          return 0;
        }
      // IF CARDIMAGE ~= END_CARD THEN (15428)
      if (1
          & (xNEQ (getFIXED (mOBJECT_GENERATORxCARDIMAGE),
                   getFIXED (mOBJECT_GENERATORxEND_CARD))))
        // CARDIMAGE(3)= 1077936128+CURRENT_SIZE-BYTES_REMAINING; (15429)
        {
          int32_t numberRHS = (int32_t)(xsubtract (
              xadd (1077936128, COREHALFWORD (mOBJECT_GENERATORxCURRENT_SIZE)),
              COREHALFWORD (mOBJECT_GENERATORxBYTES_REMAINING)));
          putFIXED (mOBJECT_GENERATORxCARDIMAGE + 4 * (3), numberRHS);
        }
      // IF MAX_SEVERITY = 0 THEN (15430)
      if (1 & (xEQ (COREHALFWORD (mMAX_SEVERITY), 0)))
        // DO; (15431)
        {
        rs2s1:;
          // OUTPUT(3) = DUMMY_CHAR; (15432)
          {
            descriptor_t *stringRHS;
            stringRHS = getCHARACTER (mOBJECT_GENERATORxDUMMY_CHAR);
            OUTPUT (3, stringRHS);
            stringRHS->inUse = 0;
          }
          // IF DECK_REQUESTED THEN (15433)
          if (1 & (bitToFixed (getBIT (1, mDECK_REQUESTED))))
            // OUTPUT(4) = DUMMY_CHAR; (15434)
            {
              descriptor_t *stringRHS;
              stringRHS = getCHARACTER (mOBJECT_GENERATORxDUMMY_CHAR);
              OUTPUT (4, stringRHS);
              stringRHS->inUse = 0;
            }
        es2s1:;
        } // End of DO block
    es2:;
    } // End of DO block
  // CARDIMAGE = 0; (15435)
  {
    int32_t numberRHS = (int32_t)(0);
    putFIXED (mOBJECT_GENERATORxCARDIMAGE, numberRHS);
  }
  // DO TEMP=1 TO 18; (15436)
  {
    int32_t from153, to153, by153;
    from153 = 1;
    to153 = 18;
    by153 = 1;
    for (putFIXED (mTEMP, from153); getFIXED (mTEMP) <= to153;
         putFIXED (mTEMP, getFIXED (mTEMP) + by153))
      {
        // CARDIMAGE(TEMP)= 1077952576; (15437)
        {
          int32_t numberRHS = (int32_t)(1077952576);
          putFIXED (mOBJECT_GENERATORxCARDIMAGE + 4 * (getFIXED (mTEMP)),
                    numberRHS);
        }
      }
  } // End of DO for-loop block
  // CARDIMAGE(19)=I_SQUARED; (15438)
  {
    int32_t numberRHS = (int32_t)(getFIXED (mOBJECT_GENERATORxI_SQUARED));
    putFIXED (mOBJECT_GENERATORxCARDIMAGE + 4 * (19), numberRHS);
  }
  // CARD_COUNTER=CARD_COUNTER+1; (15439)
  {
    int32_t numberRHS
        = (int32_t)(xadd (getFIXED (mOBJECT_GENERATORxCARD_COUNTER), 1));
    putFIXED (mOBJECT_GENERATORxCARD_COUNTER, numberRHS);
  }
  // S1=CARD_COUNTER; (15440)
  {
    int32_t numberRHS = (int32_t)(getFIXED (mOBJECT_GENERATORxCARD_COUNTER));
    descriptor_t *stringRHS;
    stringRHS = fixedToCharacter (numberRHS);
    putCHARACTER (mOBJECT_GENERATORxS1, stringRHS);
    stringRHS->inUse = 0;
  }
  // S1=SUBSTR(S1,LENGTH(S1)-4,4); (15441)
  {
    descriptor_t *stringRHS;
    stringRHS = SUBSTR (
        getCHARACTER (mOBJECT_GENERATORxS1),
        xsubtract (LENGTH (getCHARACTER (mOBJECT_GENERATORxS1)), 4), 4);
    putCHARACTER (mOBJECT_GENERATORxS1, stringRHS);
    stringRHS->inUse = 0;
  }
  {   // (56) CALL INLINE ( 88,1,0,S1);
    { /*
       * File:      patch56p.c
       * For:       OBJECT_GENERATORxEMIT_CARD.c
       * Notes:     1. Page references are from IBM "ESA/390 Principles of
       *               Operation", SA22-7201-08, Ninth Edition, June 2003.
       *            2. Labels are of the form p%d_%d, where the 1st number
       *               indicates the leading patch number of the block, and
       *               the 2nd is the byte offset of the instruction within
       *               within the block.
       *            3. Known-problematic translations are marked with the
       *               string  "* * * F I X M E * * *" (without spaces).
       * History:   2024-07-18 RSB  Auto-generated by XCOM-I --guess=....
       *                            Inspected.
       */

      p56_0:;
  // (56)          CALL INLINE ("58",1,0,S1);    /*LOAD DESCRIPTOR*/
  address360B = (mOBJECT_GENERATORxS1)&0xFFFFFF;
  // Type RX, p. 7-7:		L	1,mOBJECT_GENERATORxS1(0,0)
  detailedInlineBefore (56, "L	1,mOBJECT_GENERATORxS1(0,0)");
  GR[1] = COREWORD (address360B);
  detailedInlineAfter ();

p56_4:;
  // (57)          CALL INLINE ("41",2,0,COLUMN);    /*ADDRESS OF RECEIVING
  // FIELD*/
  address360B = (mOBJECT_GENERATORxCOLUMN)&0xFFFFFF;
  // Type RX, p. 7-78:		LA	2,mOBJECT_GENERATORxCOLUMN(0,0)
  detailedInlineBefore (57, "LA	2,mOBJECT_GENERATORxCOLUMN(0,0)");
  GR[2] = address360B & 0xFFFFFF;
  detailedInlineAfter ();

p56_8:;
  // (58)          CALL INLINE ("D2",0,3,2,76,1,0); /*MVC 76(4,2);,0(1);*/
  address360A = (GR[2] + 76) & 0xFFFFFF;
  address360B = (GR[1] + 0) & 0xFFFFFF;
  // Type SS, p. 7-83:		MVC	76(3,2),0(1)
  detailedInlineBefore (58, "MVC	76(3,2),0(1)");
  mvc (address360A, address360B, 3);
  detailedInlineAfter ();

p56_14:;
}
}
; // (57) CALL INLINE ( 65,2,0,COLUMN);
; // (58) CALL INLINE ( 210,0,3,2,76,1,0);
{
  reentryGuard = 0;
  return 0;
}
}
