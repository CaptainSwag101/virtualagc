/*
  File ERRORS.c generated by XCOM-I, 2024-08-09 12:39:31.
*/

#include "runtimeC.h"

int32_t
ERRORS (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "ERRORS");
  // IF CLASS <= CLASS_ZS THEN (1347)
  if (1 & (xLE (COREHALFWORD (mERRORSxCLASS), BYTE0 (mCLASS_ZS))))
    // DO; (1348)
    {
    rs1:;
      // ERROR# = ERROR# + 1; (1349)
      {
        int32_t numberRHS = (int32_t)(xadd (COREHALFWORD (mERRORp), 1));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mERRORp, bitRHS);
        bitRHS->inUse = 0;
      }
      // SEVERITY = COMMON_ERRORS (CLASS, NUM, TEXT, ERROR#, LINE#); (1350)
      {
        int32_t numberRHS = (int32_t)((
            putBITp (16, mCOMMON_ERRORSxCLASS, getBIT (16, mERRORSxCLASS)),
            putBITp (16, mCOMMON_ERRORSxNUM, getBIT (16, mERRORSxNUM)),
            putCHARACTERp (mCOMMON_ERRORSxTEXT, getCHARACTER (mERRORSxTEXT)),
            putBITp (16, mCOMMON_ERRORSxERRORp, getBIT (16, mERRORp)),
            putFIXED (mCOMMON_ERRORSxSTMTp, getFIXED (mLINEp)),
            COMMON_ERRORS (0)));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mERRORSxSEVERITY, bitRHS);
        bitRHS->inUse = 0;
      }
      // IF SEVERITY > MAX_SEVERITY THEN (1351)
      if (1
          & (xGT (COREHALFWORD (mERRORSxSEVERITY),
                  COREHALFWORD (mMAX_SEVERITY))))
        // MAX_SEVERITY = SEVERITY; (1352)
        {
          descriptor_t *bitRHS = getBIT (16, mERRORSxSEVERITY);
          putBIT (16, mMAX_SEVERITY, bitRHS);
          bitRHS->inUse = 0;
        }
      // IF SEVERITY~=0 THEN (1353)
      if (1 & (xNEQ (COREHALFWORD (mERRORSxSEVERITY), 0)))
        // DO; (1354)
        {
        rs1s1:;
          // IF (SEVERITY=1)&(ERROR#<ERRLIM)&GENERATING THEN (1355)
          if (1
              & (xAND (xAND (xEQ (COREHALFWORD (mERRORSxSEVERITY), 1),
                             xLT (COREHALFWORD (mERRORp), 100)),
                       BYTE0 (mGENERATING))))
            // DO; (1356)
            {
            rs1s1s1:;
              // CALL RELEASETEMP; (1357)
              RELEASETEMP (0);
              // OUTPUT=BLANK; (1358)
              {
                descriptor_t *stringRHS;
                stringRHS = getCHARACTER (mBLANK);
                OUTPUT (0, stringRHS);
                stringRHS->inUse = 0;
              }
              // DO WHILE CTR<SMRK_CTR; (1359)
              while (1 & (xLT (COREHALFWORD (mCTR), COREHALFWORD (mSMRK_CTR))))
                {
                  // CALL NEXTCODE; (1360)
                  NEXTCODE (0);
                } // End of DO WHILE block
              // GO TO SRCERR; (1361)
              {
                resetAllReentryGuards ();
                longjmp (jbSRCERR, 1);
              }
            es1s1s1:;
            } // End of DO block
          // ELSE (1362)
          else
            // DO; (1363)
            {
            rs1s1s2:;
              // OUTPUT=AST||'CONVERSION ABANDONED'; (1364)
              {
                descriptor_t *stringRHS;
                stringRHS
                    = xsCAT (getCHARACTER (mERRORSxAST),
                             cToDescriptor (NULL, "CONVERSION ABANDONED"));
                OUTPUT (0, stringRHS);
                stringRHS->inUse = 0;
              }
              // IF NUM = 504 THEN (1365)
              if (1 & (xEQ (COREHALFWORD (mERRORSxNUM), 504)))
                // RETURN; (1366)
                {
                  reentryGuard = 0;
                  return 0;
                }
              // GO TO SUBMONITOR; (1367)
              {
                resetAllReentryGuards ();
                longjmp (jbSUBMONITOR, 1);
              }
            es1s1s2:;
            } // End of DO block
        es1s1:;
        } // End of DO block
    es1:;
    } // End of DO block
  // ELSE (1368)
  else
    // DO; (1369)
    {
    rs2:;
      // DO ; (1370)
      {
      rs2s1:;
        // IF COREWORD ( ADDR ( ADVISE ) + 12 ) >= COREWORD ( ADDR ( ADVISE ) +
        // 8 ) THEN (1371)
        if (1
            & (xGE (
                COREWORD (xadd (ADDR ("ADVISE", 0x80000000, NULL, 0), 12)),
                COREWORD (xadd (ADDR ("ADVISE", 0x80000000, NULL, 0), 8)))))
          // CALL _NEEDMORE_SPACE ( ADDR ( ADVISE )  ) ; (1372)
          {
            putFIXED (m_NEEDMORE_SPACExDOPE,
                      ADDR ("ADVISE", 0x80000000, NULL, 0));
            _NEEDMORE_SPACE (0);
          }
        // COREWORD ( ADDR ( ADVISE ) + 12 ) = COREWORD ( ADDR ( ADVISE ) + 12
        // ) + 1 ; (1373)
        {
          int32_t numberRHS = (int32_t)(xadd (
              COREWORD (xadd (ADDR ("ADVISE", 0x80000000, NULL, 0), 12)), 1));
          COREWORD2 (xadd (ADDR ("ADVISE", 0x80000000, NULL, 0), 12),
                     numberRHS);
        }
      es2s1:;
      } // End of DO block
      // ADV_STMT#(RECORD_USED(ADVISE)-1) = LINE#; (1374)
      {
        int32_t numberRHS = (int32_t)(getFIXED (mLINEp));
        putBIT (16,
                getFIXED (mADVISE)
                    + 6
                          * (xsubtract (
                              COREWORD (xadd (
                                  ADDR ("ADVISE", 0x80000000, NULL, 0), 12)),
                              1))
                    + 4 + 2 * (0),
                fixedToBit (16, numberRHS));
      }
      // ADV_ERROR#(RECORD_USED(ADVISE)-1) =
      // SUBSTR(ERROR_CLASSES,SHL(CLASS-1,1),2)||NUM; (1375)
      {
        descriptor_t *stringRHS;
        stringRHS = xsCAT (
            SUBSTR (getCHARACTER (mERROR_CLASSES),
                    SHL (xsubtract (COREHALFWORD (mERRORSxCLASS), 1), 1), 2),
            bitToCharacter (getBIT (16, mERRORSxNUM)));
        putCHARACTER (
            getFIXED (mADVISE)
                + 6
                      * (xsubtract (
                          COREWORD (
                              xadd (ADDR ("ADVISE", 0x80000000, NULL, 0), 12)),
                          1))
                + 0 + 4 * (0),
            stringRHS);
        stringRHS->inUse = 0;
      }
    es2:;
    } // End of DO block
  {
    reentryGuard = 0;
    return 0;
  }
}
