/*
  File EMITADDR.c generated by XCOM-I, 2024-08-09 12:39:31.
*/

#include "runtimeC.h"

int32_t
EMITADDR (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "EMITADDR");
  // FLAG = 0; (1147)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mEMITADDRxFLAG, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF VAL < 0 THEN (1148)
  if (1 & (xLT (getFIXED (mEMITADDRxVAL), 0)))
    // DO; (1149)
    {
    rs1:;
      // IF OP ~= DADDR THEN (1150)
      if (1 & (xNEQ (COREHALFWORD (mEMITADDRxOP), BYTE0 (mDADDR))))
        // VAL = -VAL; (1151)
        {
          int32_t numberRHS = (int32_t)(xminus (getFIXED (mEMITADDRxVAL)));
          putFIXED (mEMITADDRxVAL, numberRHS);
        }
      // ELSE (1152)
      else
        // VAL = (-VAL& 4294901760)|(VAL& 65535); (1153)
        {
          int32_t numberRHS = (int32_t)(xOR (
              xAND (xminus (getFIXED (mEMITADDRxVAL)), 4294901760),
              xAND (getFIXED (mEMITADDRxVAL), 65535)));
          putFIXED (mEMITADDRxVAL, numberRHS);
        }
      // FLAG = 8; (1154)
      {
        int32_t numberRHS = (int32_t)(8);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mEMITADDRxFLAG, bitRHS);
        bitRHS->inUse = 0;
      }
    es1:;
    } // End of DO block
  // CALL EMITC(RLD, CTR + SHL(FLAG,12)); (1155)
  {
    putBITp (16, mEMITCxTYPE, getBIT (8, mRLD));
    putBITp (16, mEMITCxINST,
             fixedToBit (32, (int32_t)(xadd (
                                 COREHALFWORD (mEMITADDRxCTR),
                                 SHL (COREHALFWORD (mEMITADDRxFLAG), 12)))));
    EMITC (0);
  }
  // CTR = CTR &  4095; (1156)
  {
    int32_t numberRHS = (int32_t)(xAND (COREHALFWORD (mEMITADDRxCTR), 4095));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mEMITADDRxCTR, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF OP ~= 0 THEN (1157)
  if (1 & (xNEQ (COREHALFWORD (mEMITADDRxOP), 0)))
    // CALL EMITC(OP, CTR); (1158)
    {
      putBITp (16, mEMITCxTYPE, getBIT (16, mEMITADDRxOP));
      putBITp (16, mEMITCxINST, getBIT (16, mEMITADDRxCTR));
      EMITC (0);
    }
  // ELSE (1159)
  else
    // CALL EMITC(HADDR, CTR); (1160)
    {
      putBITp (16, mEMITCxTYPE, getBIT (8, mHADDR));
      putBITp (16, mEMITCxINST, getBIT (16, mEMITADDRxCTR));
      EMITC (0);
    }
  // CALL EMITW(VAL, 1); (1161)
  {
    putFIXED (mEMITWxDATA, getFIXED (mEMITADDRxVAL));
    putBITp (1, mEMITWxMODIFIER, fixedToBit (32, (int32_t)(1)));
    EMITW (0);
  }
  // IF OP ~= DADDR THEN (1162)
  if (1 & (xNEQ (COREHALFWORD (mEMITADDRxOP), BYTE0 (mDADDR))))
    // LOCCTR(INDEXNEST) = LOCCTR(INDEXNEST) + 1; (1163)
    {
      int32_t numberRHS = (int32_t)(xadd (
          getFIXED (mLOCCTR + 4 * COREHALFWORD (mINDEXNEST)), 1));
      putFIXED (mLOCCTR + 4 * (COREHALFWORD (mINDEXNEST)), numberRHS);
    }
  // ELSE (1164)
  else
    // LOCCTR(INDEXNEST) = LOCCTR(INDEXNEST) + 2; (1165)
    {
      int32_t numberRHS = (int32_t)(xadd (
          getFIXED (mLOCCTR + 4 * COREHALFWORD (mINDEXNEST)), 2));
      putFIXED (mLOCCTR + 4 * (COREHALFWORD (mINDEXNEST)), numberRHS);
    }
  // VAL, OP = 0; (1166)
  {
    int32_t numberRHS = (int32_t)(0);
    putFIXED (mEMITADDRxVAL, numberRHS);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mEMITADDRxOP, bitRHS);
    bitRHS->inUse = 0;
  }
  {
    reentryGuard = 0;
    return 0;
  }
}
