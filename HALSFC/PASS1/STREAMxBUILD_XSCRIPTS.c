/*
  File STREAMxBUILD_XSCRIPTS.c generated by XCOM-I, 2024-08-09 12:38:15.
*/

#include "runtimeC.h"

int32_t
STREAMxBUILD_XSCRIPTS (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "STREAMxBUILD_XSCRIPTS");
  // S_STACK, E_STACK = ''; (4666)
  {
    descriptor_t *stringRHS;
    stringRHS = cToDescriptor (NULL, "");
    putCHARACTER (mSTREAMxS_STACK, stringRHS);
    putCHARACTER (mSTREAMxE_STACK, stringRHS);
    stringRHS->inUse = 0;
  }
  // S_BLANKS, E_BLANKS = -1; (4667)
  {
    int32_t numberRHS = (int32_t)(-1);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mSTREAMxS_BLANKS, bitRHS);
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mSTREAMxE_BLANKS, bitRHS);
    bitRHS->inUse = 0;
  }
  // SP, EP = -1; (4668)
  {
    int32_t numberRHS = (int32_t)(-1);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mSTREAMxSP, bitRHS);
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mSTREAMxEP, bitRHS);
    bitRHS->inUse = 0;
  }
// CHECK_M: (4669)
CHECK_M:
  // IF BYTE(M_LINE, INDEX) = BYTE(X1) THEN (4670)
  if (1
      & (xEQ (
          BYTE (getCHARACTER (mSTREAMxM_LINE), COREHALFWORD (mSTREAMxINDEX)),
          BYTE1 (getCHARACTER (mX1)))))
    // DO; (4671)
    {
    rs1:;
      // CALL STACK(0); (4672)
      {
        putFIXED (mSTREAMxSTACKxTYPE, 0);
        STREAMxSTACK (0);
      }
      // CALL STACK(1); (4673)
      {
        putFIXED (mSTREAMxSTACKxTYPE, 1);
        STREAMxSTACK (0);
      }
      // CALL CHOP; (4674)
      STREAMxCHOP (0);
      // IF ~GROUP_NEEDED THEN (4675)
      if (1 & (xNOT (BYTE0 (mGROUP_NEEDED))))
        // GO TO CHECK_M; (4676)
        goto CHECK_M;
    es1:;
    } // End of DO block
  // IF GROUP_NEEDED THEN (4677)
  if (1 & (bitToFixed (getBIT (1, mGROUP_NEEDED))))
    // IF NONBLANK_FOUND THEN (4678)
    if (1 & (bitToFixed (getBIT (1, mNONBLANK_FOUND))))
      // DO; (4679)
      {
      rs2:;
        // CALL GET_GROUP; (4680)
        STREAMxGET_GROUP (0);
        // INDEX = 1; (4681)
        {
          int32_t numberRHS = (int32_t)(1);
          descriptor_t *bitRHS;
          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
          putBIT (16, mSTREAMxINDEX, bitRHS);
          bitRHS->inUse = 0;
        }
        // GROUP_NEEDED = FALSE; (4682)
        {
          int32_t numberRHS = (int32_t)(0);
          descriptor_t *bitRHS;
          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
          putBIT (1, mGROUP_NEEDED, bitRHS);
          bitRHS->inUse = 0;
        }
        // GO TO CHECK_M; (4683)
        goto CHECK_M;
      es2:;
      } // End of DO block
  // NONBLANK_FOUND = FALSE; (4684)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (1, mNONBLANK_FOUND, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF BYTE(S_STACK, SP) = BYTE(X1) THEN (4685)
  if (1
      & (xEQ (BYTE (getCHARACTER (mSTREAMxS_STACK), COREHALFWORD (mSTREAMxSP)),
              BYTE1 (getCHARACTER (mX1)))))
    // DO; (4686)
    {
    rs3:;
      // IF SP > 0 THEN (4687)
      if (1 & (xGT (COREHALFWORD (mSTREAMxSP), 0)))
        // S_STACK = SUBSTR(S_STACK, 0, SP); (4688)
        {
          descriptor_t *stringRHS;
          stringRHS = SUBSTR (getCHARACTER (mSTREAMxS_STACK), 0,
                              COREHALFWORD (mSTREAMxSP));
          putCHARACTER (mSTREAMxS_STACK, stringRHS);
          stringRHS->inUse = 0;
        }
      // ELSE (4689)
      else
        // S_STACK = ''; (4690)
        {
          descriptor_t *stringRHS;
          stringRHS = cToDescriptor (NULL, "");
          putCHARACTER (mSTREAMxS_STACK, stringRHS);
          stringRHS->inUse = 0;
        }
      // S_BLANKS = S_IND(SP); (4691)
      {
        descriptor_t *bitRHS
            = getBIT (16, mSTREAMxS_IND + 2 * COREHALFWORD (mSTREAMxSP));
        putBIT (16, mSTREAMxS_BLANKS, bitRHS);
        bitRHS->inUse = 0;
      }
    es3:;
    } // End of DO block
  // IF BYTE(E_STACK, EP) = BYTE(X1) THEN (4692)
  if (1
      & (xEQ (BYTE (getCHARACTER (mSTREAMxE_STACK), COREHALFWORD (mSTREAMxEP)),
              BYTE1 (getCHARACTER (mX1)))))
    // DO; (4693)
    {
    rs4:;
      // IF EP > 0 THEN (4694)
      if (1 & (xGT (COREHALFWORD (mSTREAMxEP), 0)))
        // E_STACK = SUBSTR(E_STACK, 0, EP); (4695)
        {
          descriptor_t *stringRHS;
          stringRHS = SUBSTR (getCHARACTER (mSTREAMxE_STACK), 0,
                              COREHALFWORD (mSTREAMxEP));
          putCHARACTER (mSTREAMxE_STACK, stringRHS);
          stringRHS->inUse = 0;
        }
      // ELSE (4696)
      else
        // E_STACK = ''; (4697)
        {
          descriptor_t *stringRHS;
          stringRHS = cToDescriptor (NULL, "");
          putCHARACTER (mSTREAMxE_STACK, stringRHS);
          stringRHS->inUse = 0;
        }
      // E_BLANKS = E_IND(EP); (4698)
      {
        descriptor_t *bitRHS
            = getBIT (16, mSTREAMxE_IND + 2 * COREHALFWORD (mSTREAMxEP));
        putBIT (16, mSTREAMxE_BLANKS, bitRHS);
        bitRHS->inUse = 0;
      }
    es4:;
    } // End of DO block
  // IF E_BLANKS >= S_BLANKS THEN (4699)
  if (1
      & (xGE (COREHALFWORD (mSTREAMxE_BLANKS),
              COREHALFWORD (mSTREAMxS_BLANKS))))
    // M_BLANKS = S_BLANKS; (4700)
    {
      descriptor_t *bitRHS = getBIT (16, mSTREAMxS_BLANKS);
      putBIT (16, mSTREAMxM_BLANKS, bitRHS);
      bitRHS->inUse = 0;
    }
  // ELSE (4701)
  else
    // M_BLANKS = E_BLANKS; (4702)
    {
      descriptor_t *bitRHS = getBIT (16, mSTREAMxE_BLANKS);
      putBIT (16, mSTREAMxM_BLANKS, bitRHS);
      bitRHS->inUse = 0;
    }
  {
    reentryGuard = 0;
    return 0;
  }
}
