/*
  File CHECK_STRUC_CONFLICTS.c generated by XCOM-I, 2024-08-08 04:31:11.
*/

#include "runtimeC.h"

int32_t
CHECK_STRUC_CONFLICTS (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "CHECK_STRUC_CONFLICTS");
  // SNAME=SYT_NAME(ID_LOC); (1318)
  {
    descriptor_t *stringRHS;
    stringRHS = getCHARACTER (getFIXED (mSYM_TAB) + 34 * (getFIXED (mID_LOC))
                              + 0 + 4 * (0));
    putCHARACTER (mCHECK_STRUC_CONFLICTSxSNAME, stringRHS);
    stringRHS->inUse = 0;
  }
  // IF SYT_CLASS(ID_LOC)~=VAR_CLASS THEN (1319)
  if (1
      & (xNEQ (BYTE0 (getFIXED (mSYM_TAB) + 34 * (getFIXED (mID_LOC)) + 30
                      + 1 * (0)),
               BYTE0 (mVAR_CLASS))))
    // DO; (1320)
    {
    rs1:;
      // IF STRUC_DIM~=0 THEN (1321)
      if (1 & (xNEQ (getFIXED (mSTRUC_DIM), 0)))
        // DO; (1322)
        {
        rs1s1:;
          // CALL ERROR(CLASS_DD,12,SNAME); (1323)
          {
            putBITp (16, mERRORxCLASS, getBIT (16, mCLASS_DD));
            putBITp (8, mERRORxNUM, fixedToBit (32, (int32_t)(12)));
            putCHARACTERp (mERRORxTEXT,
                           getCHARACTER (mCHECK_STRUC_CONFLICTSxSNAME));
            ERROR (0);
          }
          // STRUC_DIM=0; (1324)
          {
            int32_t numberRHS = (int32_t)(0);
            putFIXED (mSTRUC_DIM, numberRHS);
          }
        es1s1:;
        } // End of DO block
      // IF SUBSTR(SYT_NAME(STRUC_PTR),1)=SNAME THEN (1325)
      if (1
          & (xsEQ (SUBSTR2 (getCHARACTER (getFIXED (mSYM_TAB)
                                          + 34 * (getFIXED (mSTRUC_PTR)) + 0
                                          + 4 * (0)),
                            1),
                   getCHARACTER (mCHECK_STRUC_CONFLICTSxSNAME))))
        // CALL ERROR(CLASS_DQ,3); (1326)
        {
          putBITp (16, mERRORxCLASS, getBIT (16, mCLASS_DQ));
          putBITp (8, mERRORxNUM, fixedToBit (32, (int32_t)(3)));
          ERROR (0);
        }
    es1:;
    } // End of DO block
  // ELSE (1327)
  else
    // IF SUBSTR(SYT_NAME(STRUC_PTR),1)=SNAME THEN (1328)
    if (1
        & (xsEQ (SUBSTR2 (getCHARACTER (getFIXED (mSYM_TAB)
                                        + 34 * (getFIXED (mSTRUC_PTR)) + 0
                                        + 4 * (0)),
                          1),
                 getCHARACTER (mCHECK_STRUC_CONFLICTSxSNAME))))
      // DO; (1329)
      {
      rs2:;
        // KIN=STRUC_PTR; (1330)
        {
          int32_t numberRHS = (int32_t)(getFIXED (mSTRUC_PTR));
          descriptor_t *bitRHS;
          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
          putBIT (16, mKIN, bitRHS);
          bitRHS->inUse = 0;
        }
        // IF STRUC_PTR < PROCMARK THEN (1331)
        if (1 & (xLT (getFIXED (mSTRUC_PTR), getFIXED (mPROCMARK))))
          // CALL ERROR(CLASS_DQ,5,SNAME); (1332)
          {
            putBITp (16, mERRORxCLASS, getBIT (16, mCLASS_DQ));
            putBITp (8, mERRORxNUM, fixedToBit (32, (int32_t)(5)));
            putCHARACTERp (mERRORxTEXT,
                           getCHARACTER (mCHECK_STRUC_CONFLICTSxSNAME));
            ERROR (0);
          }
        // ELSE (1333)
        else
          // IF SYT_PTR(STRUC_PTR)~=0 THEN (1334)
          if (1
              & (xNEQ (COREHALFWORD (getFIXED (mSYM_TAB)
                                     + 34 * (getFIXED (mSTRUC_PTR)) + 22
                                     + 2 * (0)),
                       0)))
            // CALL ERROR(CLASS_DQ,4,SNAME); (1335)
            {
              putBITp (16, mERRORxCLASS, getBIT (16, mCLASS_DQ));
              putBITp (8, mERRORxNUM, fixedToBit (32, (int32_t)(4)));
              putCHARACTERp (mERRORxTEXT,
                             getCHARACTER (mCHECK_STRUC_CONFLICTSxSNAME));
              ERROR (0);
            }
          // ELSE (1336)
          else
            // IF (SYT_FLAGS(STRUC_PTR)&DUPL_FLAG)~=0 THEN (1337)
            if (1
                & (xNEQ (xAND (getFIXED (getFIXED (mSYM_TAB)
                                         + 34 * (getFIXED (mSTRUC_PTR)) + 8
                                         + 4 * (0)),
                               67108864),
                         0)))
              // CALL ERROR(CLASS_DQ,8,SNAME); (1338)
              {
                putBITp (16, mERRORxCLASS, getBIT (16, mCLASS_DQ));
                putBITp (8, mERRORxNUM, fixedToBit (32, (int32_t)(8)));
                putCHARACTERp (mERRORxTEXT,
                               getCHARACTER (mCHECK_STRUC_CONFLICTSxSNAME));
                ERROR (0);
              }
            // ELSE (1339)
            else
              // IF (SYT_FLAGS(STRUC_PTR)&EVIL_FLAG)=0 THEN (1340)
              if (1
                  & (xEQ (xAND (getFIXED (getFIXED (mSYM_TAB)
                                          + 34 * (getFIXED (mSTRUC_PTR)) + 8
                                          + 4 * (0)),
                                2097152),
                          0)))
                // DO FOREVER; (1341)
                while (1 & (1))
                  {
                    // DO WHILE SYT_LINK1(KIN)>0; (1342)
                    while (1
                           & (xGT (COREHALFWORD (getFIXED (mSYM_TAB)
                                                 + 34 * (COREHALFWORD (mKIN))
                                                 + 24 + 2 * (0)),
                                   0)))
                      {
                        // KIN=SYT_LINK1(KIN); (1343)
                        {
                          descriptor_t *bitRHS
                              = getBIT (16, getFIXED (mSYM_TAB)
                                                + 34 * (COREHALFWORD (mKIN))
                                                + 24 + 2 * (0));
                          putBIT (16, mKIN, bitRHS);
                          bitRHS->inUse = 0;
                        }
                      } // End of DO WHILE block
                    // IF SYT_TYPE(KIN)=MAJ_STRUC THEN (1344)
                    if (1
                        & (xEQ (BYTE0 (getFIXED (mSYM_TAB)
                                       + 34 * (COREHALFWORD (mKIN)) + 32
                                       + 1 * (0)),
                                10)))
                      // DO; (1345)
                      {
                      rs2s1s2:;
                        // CALL ERROR(CLASS_DQ,6,SNAME); (1346)
                        {
                          putBITp (16, mERRORxCLASS, getBIT (16, mCLASS_DQ));
                          putBITp (8, mERRORxNUM,
                                   fixedToBit (32, (int32_t)(6)));
                          putCHARACTERp (
                              mERRORxTEXT,
                              getCHARACTER (mCHECK_STRUC_CONFLICTSxSNAME));
                          ERROR (0);
                        }
                        // GO TO MNF_CHECK; (1347)
                        goto MNF_CHECK;
                      es2s1s2:;
                      } // End of DO block
                    // DO WHILE SYT_LINK2(KIN)<0; (1348)
                    while (1
                           & (xLT (COREHALFWORD (getFIXED (mSYM_TAB)
                                                 + 34 * (COREHALFWORD (mKIN))
                                                 + 26 + 2 * (0)),
                                   0)))
                      {
                        // KIN=-SYT_LINK2(KIN); (1349)
                        {
                          int32_t numberRHS = (int32_t)(xminus (COREHALFWORD (
                              getFIXED (mSYM_TAB) + 34 * (COREHALFWORD (mKIN))
                              + 26 + 2 * (0))));
                          descriptor_t *bitRHS;
                          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                          putBIT (16, mKIN, bitRHS);
                          bitRHS->inUse = 0;
                        }
                      } // End of DO WHILE block
                    // KIN=SYT_LINK2(KIN); (1350)
                    {
                      descriptor_t *bitRHS = getBIT (
                          16, getFIXED (mSYM_TAB) + 34 * (COREHALFWORD (mKIN))
                                  + 26 + 2 * (0));
                      putBIT (16, mKIN, bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // IF KIN=0 THEN (1351)
                    if (1 & (xEQ (COREHALFWORD (mKIN), 0)))
                      // DO; (1352)
                      {
                      rs2s1s4:;
                        // SYT_PTR(STRUC_PTR)=ID_LOC; (1353)
                        {
                          int32_t numberRHS = (int32_t)(getFIXED (mID_LOC));
                          putBIT (16,
                                  getFIXED (mSYM_TAB)
                                      + 34 * (getFIXED (mSTRUC_PTR)) + 22
                                      + 2 * (0),
                                  fixedToBit (16, numberRHS));
                        }
                        // GO TO MNF_CHECK; (1354)
                        goto MNF_CHECK;
                      es2s1s4:;
                      } // End of DO block
                  }     // End of DO WHILE block
      es2:;
      } // End of DO block
// MNF_CHECK: (1355)
MNF_CHECK:
  // IF (SYT_FLAGS(STRUC_PTR)&MISC_NAME_FLAG)~=0 THEN (1356)
  if (1
      & (xNEQ (xAND (getFIXED (getFIXED (mSYM_TAB)
                               + 34 * (getFIXED (mSTRUC_PTR)) + 8 + 4 * (0)),
                     1073741824),
               0)))
    // DO; (1357)
    {
    rs3:;
      // IF BUILDING_TEMPLATE THEN (1358)
      if (1 & (bitToFixed (getBIT (1, mBUILDING_TEMPLATE))))
        // SYT_FLAGS(REF_ID_LOC)=SYT_FLAGS(REF_ID_LOC)|MISC_NAME_FLAG; (1359)
        {
          int32_t numberRHS = (int32_t)(xOR (
              getFIXED (getFIXED (mSYM_TAB) + 34 * (getFIXED (mREF_ID_LOC)) + 8
                        + 4 * (0)),
              1073741824));
          putFIXED (getFIXED (mSYM_TAB) + 34 * (getFIXED (mREF_ID_LOC)) + 8
                        + 4 * (0),
                    numberRHS);
        }
    es3:;
    } // End of DO block
  {
    reentryGuard = 0;
    return 0;
  }
}
