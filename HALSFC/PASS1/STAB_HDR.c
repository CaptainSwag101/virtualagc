/*
  File STAB_HDR.c generated by XCOM-I, 2024-08-09 12:38:15.
*/

#include "runtimeC.h"

int32_t
STAB_HDR (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "STAB_HDR");
  // CELLSIZE = 32; (7038)
  {
    int32_t numberRHS = (int32_t)(32);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mSTAB_HDRxCELLSIZE, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF ADDR_PRESENT THEN (7039)
  if (1 & (bitToFixed (getBIT (1, mADDR_PRESENT))))
    // CELLSIZE=CELLSIZE+16; (7040)
    {
      int32_t numberRHS
          = (int32_t)(xadd (COREHALFWORD (mSTAB_HDRxCELLSIZE), 16));
      descriptor_t *bitRHS;
      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
      putBIT (16, mSTAB_HDRxCELLSIZE, bitRHS);
      bitRHS->inUse = 0;
    }
  // SRN_INX = CELLSIZE; (7041)
  {
    descriptor_t *bitRHS = getBIT (16, mSTAB_HDRxCELLSIZE);
    putBIT (16, mSTAB_HDRxSRN_INX, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF HMAT_OPT THEN (7042)
  if (1 & (bitToFixed (getBIT (1, mHMAT_OPT))))
    // CELLSIZE = CELLSIZE+4; (7043)
    {
      int32_t numberRHS
          = (int32_t)(xadd (COREHALFWORD (mSTAB_HDRxCELLSIZE), 4));
      descriptor_t *bitRHS;
      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
      putBIT (16, mSTAB_HDRxCELLSIZE, bitRHS);
      bitRHS->inUse = 0;
    }
  // IF SRN_PRESENT THEN (7044)
  if (1 & (bitToFixed (getBIT (1, mSRN_PRESENT))))
    // IF SRN_COUNT(2) > 0 THEN (7045)
    if (1 & (xGT (COREHALFWORD (mSRN_COUNT + 2 * 2), 0)))
      // CELLSIZE = CELLSIZE + 17; (7046)
      {
        int32_t numberRHS
            = (int32_t)(xadd (COREHALFWORD (mSTAB_HDRxCELLSIZE), 17));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mSTAB_HDRxCELLSIZE, bitRHS);
        bitRHS->inUse = 0;
      }
    // ELSE (7047)
    else
      // CELLSIZE = CELLSIZE + 9; (7048)
      {
        int32_t numberRHS
            = (int32_t)(xadd (COREHALFWORD (mSTAB_HDRxCELLSIZE), 9));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mSTAB_HDRxCELLSIZE, bitRHS);
        bitRHS->inUse = 0;
      }
  // CELL_PTR = GET_CELL(CELLSIZE,ADDR(NODE_H),RESV+MODF); (7049)
  {
    int32_t numberRHS = (int32_t)((
        putFIXED (mGET_CELLxCELL_SIZE, COREHALFWORD (mSTAB_HDRxCELLSIZE)),
        putFIXED (mGET_CELLxBVAR,
                  ADDR ("STAB_HDRxNODE_H", 0x80000000, NULL, 0)),
        putBITp (
            8, mGET_CELLxFLAGS,
            fixedToBit (32, (int32_t)(xadd (BYTE0 (mRESV), BYTE0 (mMODF))))),
        GET_CELL (0)));
    putFIXED (mSTAB_HDRxCELL_PTR, numberRHS);
  }
  // IF HMAT_OPT THEN (7050)
  if (1 & (bitToFixed (getBIT (1, mHMAT_OPT))))
    // DO; (7051)
    {
    rs1:;
      // CELL_PTR = CELL_PTR+4; (7052)
      {
        int32_t numberRHS = (int32_t)(xadd (getFIXED (mSTAB_HDRxCELL_PTR), 4));
        putFIXED (mSTAB_HDRxCELL_PTR, numberRHS);
      }
      // COREWORD(ADDR(NODE_H))=COREWORD(ADDR(NODE_H))+4; (7053)
      {
        int32_t numberRHS = (int32_t)(xadd (
            COREWORD (ADDR ("STAB_HDRxNODE_H", 0x80000000, NULL, 0)), 4));
        COREWORD2 (ADDR ("STAB_HDRxNODE_H", 0x80000000, NULL, 0), numberRHS);
      }
    es1:;
    } // End of DO block
  // IF FIRST_CALL THEN (7054)
  if (1 & (bitToFixed (getBIT (8, mSTAB_HDRxFIRST_CALL))))
    // DO; (7055)
    {
    rs2:;
      // STMT_DATA_HEAD = CELL_PTR; (7056)
      {
        int32_t numberRHS = (int32_t)(getFIXED (mSTAB_HDRxCELL_PTR));
        putFIXED (mCOMM + 4 * (16), numberRHS);
      }
      // FIRST_CALL = FALSE; (7057)
      {
        int32_t numberRHS = (int32_t)(0);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (8, mSTAB_HDRxFIRST_CALL, bitRHS);
        bitRHS->inUse = 0;
      }
    es2:;
    } // End of DO block
  // IF LAST_STAB_CELL_PTR ~= -1 THEN (7058)
  if (1 & (xNEQ (getFIXED (mLAST_STAB_CELL_PTR), -1)))
    // DO; (7059)
    {
    rs3:;
      // CALL LOCATE(LAST_STAB_CELL_PTR,ADDR(NODE_F),MODF); (7060)
      {
        putFIXED (mLOCATExPTR, getFIXED (mLAST_STAB_CELL_PTR));
        putFIXED (mLOCATExBVAR, ADDR ("STAB_HDRxNODE_F", 0x80000000, NULL, 0));
        putBITp (8, mLOCATExFLAGS, getBIT (8, mMODF));
        LOCATE (0);
      }
      // NODE_F(0) = CELL_PTR; (7061)
      {
        int32_t numberRHS = (int32_t)(getFIXED (mSTAB_HDRxCELL_PTR));
        putFIXED (getFIXED (mSTAB_HDRxNODE_F) + 4 * (0), numberRHS);
      }
    es3:;
    } // End of DO block
  // COREWORD(ADDR(NODE_F)) = ADDR(NODE_H(0)); (7062)
  {
    int32_t numberRHS = (int32_t)(ADDR ("STAB_HDRxNODE_H", 0, NULL, 0));
    COREWORD2 (ADDR ("STAB_HDRxNODE_F", 0x80000000, NULL, 0), numberRHS);
  }
  // IF HMAT_OPT THEN (7063)
  if (1 & (bitToFixed (getBIT (1, mHMAT_OPT))))
    // NODE_F(-1) = NILL; (7064)
    {
      int32_t numberRHS = (int32_t)(-1);
      putFIXED (getFIXED (mSTAB_HDRxNODE_F) + 4 * (-1), numberRHS);
    }
  // NODE_F(0) = NILL; (7065)
  {
    int32_t numberRHS = (int32_t)(-1);
    putFIXED (getFIXED (mSTAB_HDRxNODE_F) + 4 * (0), numberRHS);
  }
  // NODE_F(1) = LAST_STAB_CELL_PTR; (7066)
  {
    int32_t numberRHS = (int32_t)(getFIXED (mLAST_STAB_CELL_PTR));
    putFIXED (getFIXED (mSTAB_HDRxNODE_F) + 4 * (1), numberRHS);
  }
  // NODE_H(12) = 0; (7067)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, getFIXED (mSTAB_HDRxNODE_H) + 2 * (12), bitRHS);
    bitRHS->inUse = 0;
  }
  // NODE_H(13) = STMT_TYPE; (7068)
  {
    descriptor_t *bitRHS = getBIT (16, mSTMT_TYPE);
    putBIT (16, getFIXED (mSTAB_HDRxNODE_H) + 2 * (13), bitRHS);
    bitRHS->inUse = 0;
  }
  // NODE_H(14) = STMT_NUM; (7069)
  {
    int32_t numberRHS = (int32_t)(getFIXED (mCOMM + 4 * 3));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, getFIXED (mSTAB_HDRxNODE_H) + 2 * (14), bitRHS);
    bitRHS->inUse = 0;
  }
  // NODE_H(15) = BLOCK_SYTREF(NEST); (7070)
  {
    descriptor_t *bitRHS = getBIT (16, mBLOCK_SYTREF + 2 * getFIXED (mNEST));
    putBIT (16, getFIXED (mSTAB_HDRxNODE_H) + 2 * (15), bitRHS);
    bitRHS->inUse = 0;
  }
  // IF SRN_PRESENT THEN (7071)
  if (1 & (bitToFixed (getBIT (1, mSRN_PRESENT))))
    // DO; (7072)
    {
    rs4:;
      // S = SRN(2); (7073)
      {
        descriptor_t *stringRHS;
        stringRHS = getCHARACTER (mSRN + 4 * 2);
        putCHARACTER (mS, stringRHS);
        stringRHS->inUse = 0;
      }
      {   // (78) CALL INLINE( 72,1,0,SRN_INX);
        { // File:      patch78.c
          // For:       STAB_HDR.c
          // Notes:     1. Page references are from IBM "ESA/390 Principles of
          //               Operation", SA22-7201-08, Ninth Edition, June 2003.
          //            2. Labels are of the form p%d_%d, where the 1st number
          //               indicates the leading patch number of the block, and
          //               the 2nd is the byte offset of the instruction within
          //               within the block.
          //            3. Known-problematic translations are marked with the
          //               string  "* * * F I X M E * * *" (without spaces).
          // History:   2024-07-17 RSB  Auto-generated by XCOM-I --guess=....
          //                            Inspected.

          p78_0:;
      // (78)          CALL INLINE("48",1,0,SRN_INX);
      address360B = (mSTAB_HDRxSRN_INX)&0xFFFFFF;
      // Type RX, p. 7-80:		LH	1,mSTAB_HDRxSRN_INX(0,0)
      detailedInlineBefore (78, "LH	1,mSTAB_HDRxSRN_INX(0,0)");
      GR[1] = COREHALFWORD (address360B);
      detailedInlineAfter ();

    p78_4:;
      // (79)          CALL INLINE("5A",1,0,NODE_H);
      address360B = (mSTAB_HDRxNODE_H)&0xFFFFFF;
      // Type RX, p. 7-12:		A	1,mSTAB_HDRxNODE_H(0,0)
      detailedInlineBefore (79, "A	1,mSTAB_HDRxNODE_H(0,0)");
      scratchd = GR[1] + COREWORD (address360B);
      setCC ();
      GR[1] = scratch;
      detailedInlineAfter ();

    p78_8:;
      // (80)          CALL INLINE("58",2,0,S);
      address360B = (mS)&0xFFFFFF;
      // Type RX, p. 7-7:		L	2,mS(0,0)
      detailedInlineBefore (80, "L	2,mS(0,0)");
      GR[2] = COREWORD (address360B);
      detailedInlineAfter ();

    p78_12:;
      // (81)          CALL INLINE("D2",0,7,1,0,2,0);           /*CR12214*/
      address360A = (GR[1] + 0) & 0xFFFFFF;
      address360B = (GR[2] + 0) & 0xFFFFFF;
      // Type SS, p. 7-83:		MVC	0(7,1),0(2)
      detailedInlineBefore (81, "MVC	0(7,1),0(2)");
      mvc (address360A, address360B, 7);
      detailedInlineAfter ();

    p78_18:;
    }
}; // (79) CALL INLINE( 90,1,0,NODE_H);
;  // (80) CALL INLINE( 88,2,0,S);
;  // (81) CALL INLINE( 210,0,7,1,0,2,0);
// NODE_H(SHR(SRN_INX,1)+4) = SRN_COUNT(2); (7078)
{
  descriptor_t *bitRHS = getBIT (16, mSRN_COUNT + 2 * 2);
  putBIT (16,
          getFIXED (mSTAB_HDRxNODE_H)
              + 2 * (xadd (SHR (COREHALFWORD (mSTAB_HDRxSRN_INX), 1), 4)),
          bitRHS);
  bitRHS->inUse = 0;
}
// IF SRN_COUNT(2) > 0 THEN (7079)
if (1 & (xGT (COREHALFWORD (mSRN_COUNT + 2 * 2), 0)))
  // DO; (7080)
  {
  rs4s1:;
    // S = INCL_SRN(2); (7081)
    {
      descriptor_t *stringRHS;
      stringRHS = getCHARACTER (mINCL_SRN + 4 * 2);
      putCHARACTER (mS, stringRHS);
      stringRHS->inUse = 0;
    }
    // SRN_INX = SRN_INX + 10; (7082)
    {
      int32_t numberRHS
          = (int32_t)(xadd (COREHALFWORD (mSTAB_HDRxSRN_INX), 10));
      descriptor_t *bitRHS;
      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
      putBIT (16, mSTAB_HDRxSRN_INX, bitRHS);
      bitRHS->inUse = 0;
    }
    {   // (82) CALL INLINE( 72, 1, 0, SRN_INX);
      { // File:      patch82.c
        // For:       STAB_HDR.c
        // Notes:     1. Page references are from IBM "ESA/390 Principles of
        //               Operation", SA22-7201-08, Ninth Edition, June 2003.
        //            2. Labels are of the form p%d_%d, where the 1st number
        //               indicates the leading patch number of the block, and
        //               the 2nd is the byte offset of the instruction within
        //               within the block.
        //            3. Known-problematic translations are marked with the
        //               string  "* * * F I X M E * * *" (without spaces).
        // History:   2024-07-17 RSB  Auto-generated by XCOM-I --guess=....
        //                            Inspected.

        p82_0:;
    // (82)             CALL INLINE("48", 1, 0, SRN_INX);
    address360B = (mSTAB_HDRxSRN_INX)&0xFFFFFF;
    // Type RX, p. 7-80:		LH	1,mSTAB_HDRxSRN_INX(0,0)
    detailedInlineBefore (82, "LH	1,mSTAB_HDRxSRN_INX(0,0)");
    GR[1] = COREHALFWORD (address360B);
    detailedInlineAfter ();

  p82_4:;
    // (83)             CALL INLINE("5A", 1, 0, NODE_H);
    address360B = (mSTAB_HDRxNODE_H)&0xFFFFFF;
    // Type RX, p. 7-12:		A	1,mSTAB_HDRxNODE_H(0,0)
    detailedInlineBefore (83, "A	1,mSTAB_HDRxNODE_H(0,0)");
    scratchd = GR[1] + COREWORD (address360B);
    setCC ();
    GR[1] = scratch;
    detailedInlineAfter ();

  p82_8:;
    // (84)             CALL INLINE("58", 2, 0, S);
    address360B = (mS)&0xFFFFFF;
    // Type RX, p. 7-7:		L	2,mS(0,0)
    detailedInlineBefore (84, "L	2,mS(0,0)");
    GR[2] = COREWORD (address360B);
    detailedInlineAfter ();

  p82_12:;
    // (85)             CALL INLINE("D2", 0, 7, 1, 0, 2, 0);  /*CR12214*/
    address360A = (GR[1] + 0) & 0xFFFFFF;
    address360B = (GR[2] + 0) & 0xFFFFFF;
    // Type SS, p. 7-83:		MVC	0(7,1),0(2)
    detailedInlineBefore (85, "MVC	0(7,1),0(2)");
    mvc (address360A, address360B, 7);
    detailedInlineAfter ();

  p82_18:;
  }
}
; // (83) CALL INLINE( 90, 1, 0, NODE_H);
; // (84) CALL INLINE( 88, 2, 0, S);
; // (85) CALL INLINE( 210, 0, 7, 1, 0, 2, 0);
// NODE_H(13) = NODE_H(13) |  32768; (7087)
{
  int32_t numberRHS = (int32_t)(xOR (
      COREHALFWORD (getFIXED (mSTAB_HDRxNODE_H) + 2 * 13), 32768));
  descriptor_t *bitRHS;
  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
  putBIT (16, getFIXED (mSTAB_HDRxNODE_H) + 2 * (13), bitRHS);
  bitRHS->inUse = 0;
}
es4s1:;
} // End of DO block
es4:;
} // End of DO block
// CELLSIZE = STAB2_STACKTOP - STAB2_MARK; (7088)
{
  int32_t numberRHS = (int32_t)(xsubtract (COREHALFWORD (mSTAB2_STACKTOP),
                                           COREHALFWORD (mSTAB2_MARK)));
  descriptor_t *bitRHS;
  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
  putBIT (16, mSTAB_HDRxCELLSIZE, bitRHS);
  bitRHS->inUse = 0;
}
// IF CELLSIZE > 0 THEN (7089)
if (1 & (xGT (COREHALFWORD (mSTAB_HDRxCELLSIZE), 0)))
  // DO; (7090)
  {
  rs5:;
    // NODE_F(2) = GET_CELL(SHL(CELLSIZE,1)+2,ADDR(NODE_H),MODF); (7091)
    {
      int32_t numberRHS = (int32_t)((
          putFIXED (mGET_CELLxCELL_SIZE,
                    xadd (SHL (COREHALFWORD (mSTAB_HDRxCELLSIZE), 1), 2)),
          putFIXED (mGET_CELLxBVAR,
                    ADDR ("STAB_HDRxNODE_H", 0x80000000, NULL, 0)),
          putBITp (8, mGET_CELLxFLAGS, getBIT (8, mMODF)), GET_CELL (0)));
      putFIXED (getFIXED (mSTAB_HDRxNODE_F) + 4 * (2), numberRHS);
    }
    // NODE_H(0) = CELLSIZE; (7092)
    {
      descriptor_t *bitRHS = getBIT (16, mSTAB_HDRxCELLSIZE);
      putBIT (16, getFIXED (mSTAB_HDRxNODE_H) + 2 * (0), bitRHS);
      bitRHS->inUse = 0;
    }
    // DO I = STAB2_MARK + 1 TO STAB2_STACKTOP; (7093)
    {
      int32_t from113, to113, by113;
      from113 = xadd (COREHALFWORD (mSTAB2_MARK), 1);
      to113 = bitToFixed (getBIT (16, mSTAB2_STACKTOP));
      by113 = 1;
      for (putBIT (16, mSTAB_HDRxI, fixedToBit (16, from113));
           bitToFixed (getBIT (16, mSTAB_HDRxI)) <= to113; putBIT (
               16, mSTAB_HDRxI,
               fixedToBit (16, bitToFixed (getBIT (16, mSTAB_HDRxI)) + by113)))
        {
          // J = I - STAB2_MARK; (7094)
          {
            int32_t numberRHS = (int32_t)(xsubtract (
                COREHALFWORD (mSTAB_HDRxI), COREHALFWORD (mSTAB2_MARK)));
            descriptor_t *bitRHS;
            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
            putBIT (16, mSTAB_HDRxJ, bitRHS);
            bitRHS->inUse = 0;
          }
          // NODE_H(J) = STAB2_STACK(I); (7095)
          {
            descriptor_t *bitRHS
                = getBIT (16, mSTAB2_STACK + 2 * COREHALFWORD (mSTAB_HDRxI));
            putBIT (16,
                    getFIXED (mSTAB_HDRxNODE_H)
                        + 2 * (COREHALFWORD (mSTAB_HDRxJ)),
                    bitRHS);
            bitRHS->inUse = 0;
          }
        }
    } // End of DO for-loop block
  es5:;
  } // End of DO block
// ELSE (7096)
else
  // NODE_F(2) = -1; (7097)
  {
    int32_t numberRHS = (int32_t)(-1);
    putFIXED (getFIXED (mSTAB_HDRxNODE_F) + 4 * (2), numberRHS);
  }
// CELLSIZE = STAB_STACKTOP - STAB_MARK; (7098)
{
  int32_t numberRHS = (int32_t)(xsubtract (COREHALFWORD (mSTAB_STACKTOP),
                                           COREHALFWORD (mSTAB_MARK)));
  descriptor_t *bitRHS;
  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
  putBIT (16, mSTAB_HDRxCELLSIZE, bitRHS);
  bitRHS->inUse = 0;
}
// IF CELLSIZE > 0 THEN (7099)
if (1 & (xGT (COREHALFWORD (mSTAB_HDRxCELLSIZE), 0)))
  // DO; (7100)
  {
  rs6:;
    // NODE_F(3) = GET_CELL(SHL(CELLSIZE,1)+2,ADDR(NODE_H),MODF); (7101)
    {
      int32_t numberRHS = (int32_t)((
          putFIXED (mGET_CELLxCELL_SIZE,
                    xadd (SHL (COREHALFWORD (mSTAB_HDRxCELLSIZE), 1), 2)),
          putFIXED (mGET_CELLxBVAR,
                    ADDR ("STAB_HDRxNODE_H", 0x80000000, NULL, 0)),
          putBITp (8, mGET_CELLxFLAGS, getBIT (8, mMODF)), GET_CELL (0)));
      putFIXED (getFIXED (mSTAB_HDRxNODE_F) + 4 * (3), numberRHS);
    }
    // NODE_H(0) = CELLSIZE; (7102)
    {
      descriptor_t *bitRHS = getBIT (16, mSTAB_HDRxCELLSIZE);
      putBIT (16, getFIXED (mSTAB_HDRxNODE_H) + 2 * (0), bitRHS);
      bitRHS->inUse = 0;
    }
    // DO I = STAB_MARK+1 TO STAB_STACKTOP; (7103)
    {
      int32_t from114, to114, by114;
      from114 = xadd (COREHALFWORD (mSTAB_MARK), 1);
      to114 = bitToFixed (getBIT (16, mSTAB_STACKTOP));
      by114 = 1;
      for (putBIT (16, mSTAB_HDRxI, fixedToBit (16, from114));
           bitToFixed (getBIT (16, mSTAB_HDRxI)) <= to114; putBIT (
               16, mSTAB_HDRxI,
               fixedToBit (16, bitToFixed (getBIT (16, mSTAB_HDRxI)) + by114)))
        {
          // J = I - STAB_MARK; (7104)
          {
            int32_t numberRHS = (int32_t)(xsubtract (
                COREHALFWORD (mSTAB_HDRxI), COREHALFWORD (mSTAB_MARK)));
            descriptor_t *bitRHS;
            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
            putBIT (16, mSTAB_HDRxJ, bitRHS);
            bitRHS->inUse = 0;
          }
          // NODE_H(J) = STAB_STACK(I); (7105)
          {
            descriptor_t *bitRHS
                = getBIT (16, mSTAB_STACK + 2 * COREHALFWORD (mSTAB_HDRxI));
            putBIT (16,
                    getFIXED (mSTAB_HDRxNODE_H)
                        + 2 * (COREHALFWORD (mSTAB_HDRxJ)),
                    bitRHS);
            bitRHS->inUse = 0;
          }
        }
    } // End of DO for-loop block
  es6:;
  } // End of DO block
// ELSE (7106)
else
  // NODE_F(3) = -1; (7107)
  {
    int32_t numberRHS = (int32_t)(-1);
    putFIXED (getFIXED (mSTAB_HDRxNODE_F) + 4 * (3), numberRHS);
  }
// CALL PTR_LOCATE(CELL_PTR,RELS); (7108)
{
  putFIXED (mPTR_LOCATExPTR, getFIXED (mSTAB_HDRxCELL_PTR));
  putBITp (8, mPTR_LOCATExFLAGS, getBIT (8, mRELS));
  PTR_LOCATE (0);
}
// LAST_STAB_CELL_PTR = CELL_PTR; (7109)
{
  int32_t numberRHS = (int32_t)(getFIXED (mSTAB_HDRxCELL_PTR));
  putFIXED (mLAST_STAB_CELL_PTR, numberRHS);
}
// STAB_STACKTOP =STAB_MARK; (7110)
{
  descriptor_t *bitRHS = getBIT (16, mSTAB_MARK);
  putBIT (16, mSTAB_STACKTOP, bitRHS);
  bitRHS->inUse = 0;
}
// STAB2_STACKTOP = STAB2_MARK; (7111)
{
  descriptor_t *bitRHS = getBIT (16, mSTAB2_MARK);
  putBIT (16, mSTAB2_STACKTOP, bitRHS);
  bitRHS->inUse = 0;
}
// STMT_TYPE=0; (7112)
{
  int32_t numberRHS = (int32_t)(0);
  descriptor_t *bitRHS;
  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
  putBIT (16, mSTMT_TYPE, bitRHS);
  bitRHS->inUse = 0;
}
{
  reentryGuard = 0;
  return 0;
}
}
