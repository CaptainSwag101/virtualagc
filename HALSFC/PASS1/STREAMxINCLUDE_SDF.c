/*
  File STREAMxINCLUDE_SDF.c generated by XCOM-I, 2024-08-08 04:31:11.
*/

#include "runtimeC.h"

descriptor_t *
STREAMxINCLUDE_SDF (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (descriptor_t *)0;
    }
  reentryGuard = guardReentry (reentryGuard, "STREAMxINCLUDE_SDF");
  // IF NEST > 0 THEN (3443)
  if (1 & (xGT (getFIXED (mNEST), 0)))
    // DO; (3444)
    {
    rs1:;
      // CALL ERROR(CLASS_PE, 1); (3445)
      {
        putBITp (16, mERRORxCLASS, getBIT (16, mCLASS_PE));
        putBITp (8, mERRORxNUM, fixedToBit (32, (int32_t)(1)));
        ERROR (0);
      }
      // RETURN TRUE; (3446)
      {
        reentryGuard = 0;
        return fixedToBit (32, (int32_t)(1));
      }
    es1:;
    } // End of DO block
  // ELSE (3447)
  else
    // IF BLOCK_MODE > 0 THEN (3448)
    if (1 & (xGT (BYTE0 (mBLOCK_MODE), 0)))
      // DO; (3449)
      {
      rs2:;
        // CALL ERROR(CLASS_PE, 2); (3450)
        {
          putBITp (16, mERRORxCLASS, getBIT (16, mCLASS_PE));
          putBITp (8, mERRORxNUM, fixedToBit (32, (int32_t)(2)));
          ERROR (0);
        }
        // RETURN TRUE; (3451)
        {
          reentryGuard = 0;
          return fixedToBit (32, (int32_t)(1));
        }
      es2:;
      } // End of DO block
  // IF ~SDF_FOUND THEN (3452)
  if (1 & (xNOT (bitToFixed (STREAMxINCLUDE_SDFxSDF_FOUND (0)))))
    // RETURN FALSE; (3453)
    {
      reentryGuard = 0;
      return fixedToBit (32, (int32_t)(0));
    }
  // DO ; (3454)
  {
  rs3:;
    // CALL MONITOR ( 22 , 7 ) ; (3455)
    MONITOR22 (7);
    // COREWORD ( ADDR ( SDF_B ) ) , COREWORD ( ADDR ( SDF_H ) ) , COREWORD (
    // ADDR ( SDF_F ) ) = COMMTABL_FULLWORD(7) ; (3456)
    {
      int32_t numberRHS = (int32_t)(getFIXED (
          getFIXED (mSTREAMxINCLUDE_SDFxCOMMTABL_FULLWORD) + 4 * 7));
      COREWORD2 (ADDR ("STREAMxINCLUDE_SDFxSDF_B", 0x80000000, NULL, 0),
                 numberRHS);
      COREWORD2 (ADDR ("STREAMxINCLUDE_SDFxSDF_H", 0x80000000, NULL, 0),
                 numberRHS);
      COREWORD2 (ADDR ("STREAMxINCLUDE_SDFxSDF_F", 0x80000000, NULL, 0),
                 numberRHS);
    }
    // ; (3457)
    ;
  es3:;
  } // End of DO block
  // ; (3458)
  ;
  // SDF_ROOT_FLAGS = SDF_H(0); (3459)
  {
    descriptor_t *bitRHS
        = getBIT (16, getFIXED (mSTREAMxINCLUDE_SDFxSDF_H) + 2 * 0);
    putBIT (16, mSTREAMxINCLUDE_SDFxSDF_ROOT_FLAGS, bitRHS);
    bitRHS->inUse = 0;
  }
  // LAST_COMSUB_SYMB = SDF_ROOT_COMSUB_END; (3460)
  {
    descriptor_t *bitRHS
        = getBIT (16, getFIXED (mSTREAMxINCLUDE_SDFxSDF_H) + 2 * 59);
    putBIT (16, mSTREAMxINCLUDE_SDFxLAST_COMSUB_SYMB, bitRHS);
    bitRHS->inUse = 0;
  }
  // UNIT_SYMB# = SDF_ROOT_UNIT_SYMB#; (3461)
  {
    descriptor_t *bitRHS
        = getBIT (16, getFIXED (mSTREAMxINCLUDE_SDFxSDF_H) + 2 * 14);
    putBIT (16, mSTREAMxINCLUDE_SDFxUNIT_SYMBp, bitRHS);
    bitRHS->inUse = 0;
  }
  // #SDF_PAGES = SDF_ROOT_LAST_PAGE + 1; (3462)
  {
    int32_t numberRHS = (int32_t)(xadd (
        COREHALFWORD (getFIXED (mSTREAMxINCLUDE_SDFxSDF_H) + 2 * 1), 1));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mSTREAMxINCLUDE_SDFxpSDF_PAGES, bitRHS);
    bitRHS->inUse = 0;
  }
  // DO ; (3463)
  {
  rs4:;
    // COMMTABL_HALFWORD ( 8 ) = SDF_H ( 44 ) ; (3464)
    {
      descriptor_t *bitRHS
          = getBIT (16, getFIXED (mSTREAMxINCLUDE_SDFxSDF_H) + 2 * 44);
      putBIT (16, getFIXED (mSTREAMxINCLUDE_SDFxCOMMTABL_HALFWORD) + 2 * (8),
              bitRHS);
      bitRHS->inUse = 0;
    }
    // CALL MONITOR ( 22 , 8 ) ; (3465)
    MONITOR22 (8);
    // COREWORD ( ADDR ( SDF_B ) ) , COREWORD ( ADDR ( SDF_H ) ) , COREWORD (
    // ADDR ( SDF_F ) ) = COMMTABL_FULLWORD(7) ; (3466)
    {
      int32_t numberRHS = (int32_t)(getFIXED (
          getFIXED (mSTREAMxINCLUDE_SDFxCOMMTABL_FULLWORD) + 4 * 7));
      COREWORD2 (ADDR ("STREAMxINCLUDE_SDFxSDF_B", 0x80000000, NULL, 0),
                 numberRHS);
      COREWORD2 (ADDR ("STREAMxINCLUDE_SDFxSDF_H", 0x80000000, NULL, 0),
                 numberRHS);
      COREWORD2 (ADDR ("STREAMxINCLUDE_SDFxSDF_F", 0x80000000, NULL, 0),
                 numberRHS);
    }
    // ; (3467)
    ;
  es4:;
  } // End of DO block
  // ; (3468)
  ;
  // IF SDFPKG_BLKNAM ~= UNIT THEN (3469)
  if (1
      & (xsNEQ (
          getCHARACTERd (xadd (
              xadd (
                  SHL (xsubtract (
                           BYTE0 (getFIXED (mSTREAMxINCLUDE_SDFxCOMMTABL_BYTE)
                                  + 1 * 22),
                           1),
                       24),
                  getFIXED (mSTREAMxINCLUDE_SDFxCOMMTABL_ADDR)),
              56)),
          getCHARACTER (mSTREAMxINCLUDE_SDFxUNIT))))
    // DO; (3470)
    {
    rs5:;
      // UNIT = NEW_STRING(SDFPKG_BLKNAM); (3471)
      {
        descriptor_t *stringRHS;
        stringRHS = SUBSTR2 (
            xsCAT (
                getCHARACTER (mX1),
                getCHARACTERd (xadd (
                    xadd (
                        SHL (xsubtract (
                                 BYTE0 (getFIXED (
                                            mSTREAMxINCLUDE_SDFxCOMMTABL_BYTE)
                                        + 1 * 22),
                                 1),
                             24),
                        getFIXED (mSTREAMxINCLUDE_SDFxCOMMTABL_ADDR)),
                    56))),
            1);
        putCHARACTER (mSTREAMxINCLUDE_SDFxUNIT, stringRHS);
        stringRHS->inUse = 0;
      }
    es5:;
    } // End of DO block
  // IF DUPLICATE_NAME(UNIT) THEN (3472)
  if (1
      & (bitToFixed ((putCHARACTERp (mSTREAMxINCLUDE_SDFxDUPLICATE_NAMExNAME,
                                     getCHARACTER (mSTREAMxINCLUDE_SDFxUNIT)),
                      STREAMxINCLUDE_SDFxDUPLICATE_NAME (0)))))
    // CALL ERROR(CLASS_PL, 2, UNIT); (3473)
    {
      putBITp (16, mERRORxCLASS, getBIT (16, mCLASS_PL));
      putBITp (8, mERRORxNUM, fixedToBit (32, (int32_t)(2)));
      putCHARACTERp (mERRORxTEXT, getCHARACTER (mSTREAMxINCLUDE_SDFxUNIT));
      ERROR (0);
    }
  // #BLK_SYMBS = SDF_BLK_LAST_SYMB# - SDF_BLK_FIRST_SYMB# + 1; (3474)
  {
    int32_t numberRHS = (int32_t)(xadd (
        xsubtract (
            COREHALFWORD (getFIXED (mSTREAMxINCLUDE_SDFxSDF_H) + 2 * 17),
            COREHALFWORD (getFIXED (mSTREAMxINCLUDE_SDFxSDF_H) + 2 * 16)),
        1));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mSTREAMxINCLUDE_SDFxpBLK_SYMBS, bitRHS);
    bitRHS->inUse = 0;
  }
  // ID_LOC = ENTER(UNIT, LABEL_CLASS); (3475)
  {
    int32_t numberRHS = (int32_t)((
        putCHARACTERp (mENTERxNAME, getCHARACTER (mSTREAMxINCLUDE_SDFxUNIT)),
        putFIXED (mENTERxCLASS, BYTE0 (mLABEL_CLASS)), ENTER (0)));
    putFIXED (mID_LOC, numberRHS);
  }
  // BLK_TYPE = SDF_BLK_CATEGORY; (3476)
  {
    descriptor_t *bitRHS
        = getBIT (8, getFIXED (mSTREAMxINCLUDE_SDFxSDF_B) + 1 * 30);
    putBIT (16, mSTREAMxINCLUDE_SDFxBLK_TYPE, bitRHS);
    bitRHS->inUse = 0;
  }
  // FLAGS = EXTERNAL_FLAG | DEFINED_LABEL | SDF_INCL_FLAG; (3477)
  {
    int32_t numberRHS = (int32_t)(1050688);
    putFIXED (mSTREAMxINCLUDE_SDFxFLAGS, numberRHS);
  }
  // IF (INCL_FLAGS & INCL_REMOTE_FLAG) ~= 0 THEN (3478)
  if (1 & (xNEQ (xAND (BYTE0 (mSTREAMxINCLUDE_SDFxINCL_FLAGS), 1), 0)))
    // DO; (3479)
    {
    rs6:;
      // IF BLK_TYPE = 4  THEN (3480)
      if (1 & (xEQ (COREHALFWORD (mSTREAMxINCLUDE_SDFxBLK_TYPE), 4)))
        // FLAGS = FLAGS | REMOTE_FLAG; (3481)
        {
          int32_t numberRHS
              = (int32_t)(xOR (getFIXED (mSTREAMxINCLUDE_SDFxFLAGS), 128));
          putFIXED (mSTREAMxINCLUDE_SDFxFLAGS, numberRHS);
        }
      // ELSE (3482)
      else
        // CALL ERROR(CLASS_XI, 5); (3483)
        {
          putBITp (16, mERRORxCLASS, getBIT (16, mCLASS_XI));
          putBITp (8, mERRORxNUM, fixedToBit (32, (int32_t)(5)));
          ERROR (0);
        }
      // TPL_REMOTE = FALSE; (3484)
      {
        int32_t numberRHS = (int32_t)(0);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (1, mTPL_REMOTE, bitRHS);
        bitRHS->inUse = 0;
      }
    es6:;
    } // End of DO block
  // DO I = 0 TO #BLK_FLAGS; (3485)
  {
    int32_t from65, to65, by65;
    from65 = 0;
    to65 = 3;
    by65 = 1;
    for (putBIT (16, mSTREAMxINCLUDE_SDFxI, fixedToBit (16, from65));
         bitToFixed (getBIT (16, mSTREAMxINCLUDE_SDFxI)) <= to65; putBIT (
             16, mSTREAMxINCLUDE_SDFxI,
             fixedToBit (16, bitToFixed (getBIT (16, mSTREAMxINCLUDE_SDFxI))
                                 + by65)))
      {
        // IF (SDF_BLK_FLAGS & IN_BLK_FLAG(I)) ~= 0 THEN (3486)
        if (1
            & (xNEQ (
                xAND (BYTE0 (getFIXED (mSTREAMxINCLUDE_SDFxSDF_B) + 1 * 24),
                      BYTE0 (mSTREAMxINCLUDE_SDFxIN_BLK_FLAG
                             + 1 * COREHALFWORD (mSTREAMxINCLUDE_SDFxI))),
                0)))
          // FLAGS = FLAGS | OUT_BLK_FLAG(I); (3487)
          {
            int32_t numberRHS = (int32_t)(xOR (
                getFIXED (mSTREAMxINCLUDE_SDFxFLAGS),
                getFIXED (mSTREAMxINCLUDE_SDFxOUT_BLK_FLAG
                          + 4 * COREHALFWORD (mSTREAMxINCLUDE_SDFxI))));
            putFIXED (mSTREAMxINCLUDE_SDFxFLAGS, numberRHS);
          }
      }
  } // End of DO for-loop block
  // SYT_FLAGS(ID_LOC) = FLAGS; (3488)
  {
    int32_t numberRHS = (int32_t)(getFIXED (mSTREAMxINCLUDE_SDFxFLAGS));
    putFIXED (getFIXED (mSYM_TAB) + 34 * (getFIXED (mID_LOC)) + 8 + 4 * (0),
              numberRHS);
  }
  // NEST = 1; (3489)
  {
    int32_t numberRHS = (int32_t)(1);
    putFIXED (mNEST, numberRHS);
  }
  // SCOPE#_STACK(NEST) = SCOPE#; (3490)
  {
    descriptor_t *bitRHS = getBIT (16, mSCOPEp);
    putBIT (16, mSCOPEp_STACK + 2 * (getFIXED (mNEST)), bitRHS);
    bitRHS->inUse = 0;
  }
  // SYT_SCOPE(ID_LOC), SCOPE#, MAX_SCOPE# = MAX_SCOPE# + 1; (3491)
  {
    int32_t numberRHS = (int32_t)(xadd (getFIXED (mCOMM + 4 * 5), 1));
    putBIT (8, getFIXED (mSYM_TAB) + 34 * (getFIXED (mID_LOC)) + 29 + 1 * (0),
            fixedToBit (8, numberRHS));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mSCOPEp, bitRHS);
    putFIXED (mCOMM + 4 * (5), numberRHS);
    bitRHS->inUse = 0;
  }
  // DO ; (3492)
  {
  rs8:;
    // IF COREWORD ( ADDR ( CSECT_LENGTHS ) + 12 ) >= COREWORD ( ADDR (
    // CSECT_LENGTHS ) + 8 ) THEN (3493)
    if (1
        & (xGE (
            COREWORD (xadd (ADDR ("CSECT_LENGTHS", 0x80000000, NULL, 0), 12)),
            COREWORD (xadd (ADDR ("CSECT_LENGTHS", 0x80000000, NULL, 0), 8)))))
      // CALL _NEEDMORE_SPACE ( ADDR ( CSECT_LENGTHS )  ) ; (3494)
      {
        putFIXED (m_NEEDMORE_SPACExDOPE,
                  ADDR ("CSECT_LENGTHS", 0x80000000, NULL, 0));
        _NEEDMORE_SPACE (0);
      }
    // COREWORD ( ADDR ( CSECT_LENGTHS ) + 12 ) = COREWORD ( ADDR (
    // CSECT_LENGTHS ) + 12 ) + 1 ; (3495)
    {
      int32_t numberRHS = (int32_t)(xadd (
          COREWORD (xadd (ADDR ("CSECT_LENGTHS", 0x80000000, NULL, 0), 12)),
          1));
      COREWORD2 (xadd (ADDR ("CSECT_LENGTHS", 0x80000000, NULL, 0), 12),
                 numberRHS);
    }
  es8:;
  } // End of DO block
  // PROCMARK_STACK(NEST) = PROCMARK; (3496)
  {
    int32_t numberRHS = (int32_t)(getFIXED (mPROCMARK));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mPROCMARK_STACK + 2 * (getFIXED (mNEST)), bitRHS);
    bitRHS->inUse = 0;
  }
  // PROCMARK, REGULAR_PROCMARK = NDECSY + 1; (3497)
  {
    int32_t numberRHS = (int32_t)(xadd (getFIXED (mCOMM + 4 * 10), 1));
    putFIXED (mPROCMARK, numberRHS);
    putFIXED (mREGULAR_PROCMARK, numberRHS);
  }
  // BLOCK_SYTREF(NEST) = ID_LOC; (3498)
  {
    int32_t numberRHS = (int32_t)(getFIXED (mID_LOC));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mBLOCK_SYTREF + 2 * (getFIXED (mNEST)), bitRHS);
    bitRHS->inUse = 0;
  }
  // SYT_PTR(ID_LOC) = PROCMARK; (3499)
  {
    int32_t numberRHS = (int32_t)(getFIXED (mPROCMARK));
    putBIT (16, getFIXED (mSYM_TAB) + 34 * (getFIXED (mID_LOC)) + 22 + 2 * (0),
            fixedToBit (16, numberRHS));
  }
  // CALL ENTER_LAYOUT(ID_LOC); (3500)
  {
    putBITp (16, mENTER_LAYOUTxNDX,
             fixedToBit (32, (int32_t)(getFIXED (mID_LOC))));
    ENTER_LAYOUT (0);
  }
  // SYT_LOCK#(ID_LOC) = SDF_BLK_VERSION#; (3501)
  {
    descriptor_t *bitRHS
        = getBIT (8, getFIXED (mSTREAMxINCLUDE_SDFxSDF_B) + 1 * 25);
    putBIT (8, getFIXED (mSYM_TAB) + 34 * (getFIXED (mID_LOC)) + 31 + 1 * (0),
            bitRHS);
    bitRHS->inUse = 0;
  }
  // DO ; (3502)
  {
  rs9:;
    // COMMTABL_HALFWORD ( 9 ) = UNIT_SYMB# ; (3503)
    {
      descriptor_t *bitRHS = getBIT (16, mSTREAMxINCLUDE_SDFxUNIT_SYMBp);
      putBIT (16, getFIXED (mSTREAMxINCLUDE_SDFxCOMMTABL_HALFWORD) + 2 * (9),
              bitRHS);
      bitRHS->inUse = 0;
    }
    // CALL MONITOR ( 22 , 9 ) ; (3504)
    MONITOR22 (9);
    // COREWORD ( ADDR ( SDF_B ) ) , COREWORD ( ADDR ( SDF_H ) ) , COREWORD (
    // ADDR ( SDF_F ) ) = COMMTABL_FULLWORD(7) ; (3505)
    {
      int32_t numberRHS = (int32_t)(getFIXED (
          getFIXED (mSTREAMxINCLUDE_SDFxCOMMTABL_FULLWORD) + 4 * 7));
      COREWORD2 (ADDR ("STREAMxINCLUDE_SDFxSDF_B", 0x80000000, NULL, 0),
                 numberRHS);
      COREWORD2 (ADDR ("STREAMxINCLUDE_SDFxSDF_H", 0x80000000, NULL, 0),
                 numberRHS);
      COREWORD2 (ADDR ("STREAMxINCLUDE_SDFxSDF_F", 0x80000000, NULL, 0),
                 numberRHS);
    }
    // ; (3506)
    ;
  es9:;
  } // End of DO block
  // ; (3507)
  ;
  // NEXT_SYMBOL = SDF_SYMB_DECLARE_LINK; (3508)
  {
    descriptor_t *bitRHS
        = getBIT (16, getFIXED (mSTREAMxINCLUDE_SDFxSDF_H) + 2 * -5);
    putBIT (16, mSTREAMxINCLUDE_SDFxNEXT_SYMBOL, bitRHS);
    bitRHS->inUse = 0;
  }
  // DO CASE BLK_TYPE; (3509)
  {
  rs10:
    switch (COREHALFWORD (mSTREAMxINCLUDE_SDFxBLK_TYPE))
      {
      case 0:
          // ; (3511)
          ;
        break;
      case 1:
        // DO; (3512)
        {
        rs10s1:;
          // BLOCK_MODE(NEST) = PROG_MODE; (3512)
          {
            descriptor_t *bitRHS = getBIT (8, mPROG_MODE);
            putBIT (8, mBLOCK_MODE + 1 * (getFIXED (mNEST)), bitRHS);
            bitRHS->inUse = 0;
          }
          // SYT_TYPE(ID_LOC) = PROG_LABEL; (3513)
          {
            int32_t numberRHS = (int32_t)(73);
            putBIT (8,
                    getFIXED (mSYM_TAB) + 34 * (getFIXED (mID_LOC)) + 32
                        + 1 * (0),
                    fixedToBit (8, numberRHS));
          }
          // SYT_FLAGS(ID_LOC) = SYT_FLAGS(ID_LOC) | LATCHED_FLAG; (3514)
          {
            int32_t numberRHS = (int32_t)(xOR (
                getFIXED (getFIXED (mSYM_TAB) + 34 * (getFIXED (mID_LOC)) + 8
                          + 4 * (0)),
                131072));
            putFIXED (getFIXED (mSYM_TAB) + 34 * (getFIXED (mID_LOC)) + 8
                          + 4 * (0),
                      numberRHS);
          }
        es10s1:;
        } // End of DO block
        break;
      case 2:
        // DO; (3516)
        {
        rs10s2:;
          // IF ((SDF_ROOT_FLAGS &  4) ~= 0) THEN (3516)
          if (1
              & (xNEQ (
                  xAND (COREHALFWORD (mSTREAMxINCLUDE_SDFxSDF_ROOT_FLAGS), 4),
                  0)))
            // SYT_FLAGS(ID_LOC) = SYT_FLAGS(ID_LOC) | REMOTE_FLAG; (3517)
            {
              int32_t numberRHS = (int32_t)(xOR (
                  getFIXED (getFIXED (mSYM_TAB) + 34 * (getFIXED (mID_LOC)) + 8
                            + 4 * (0)),
                  128));
              putFIXED (getFIXED (mSYM_TAB) + 34 * (getFIXED (mID_LOC)) + 8
                            + 4 * (0),
                        numberRHS);
            }
          // BLOCK_MODE(NEST) = PROC_MODE; (3518)
          {
            descriptor_t *bitRHS = getBIT (8, mPROC_MODE);
            putBIT (8, mBLOCK_MODE + 1 * (getFIXED (mNEST)), bitRHS);
            bitRHS->inUse = 0;
          }
          // SYT_TYPE(ID_LOC) = PROC_LABEL; (3519)
          {
            int32_t numberRHS = (int32_t)(71);
            putBIT (8,
                    getFIXED (mSYM_TAB) + 34 * (getFIXED (mID_LOC)) + 32
                        + 1 * (0),
                    fixedToBit (8, numberRHS));
          }
          // IF LAST_COMSUB_SYMB ~= UNIT_SYMB# THEN (3520)
          if (1
              & (xNEQ (COREHALFWORD (mSTREAMxINCLUDE_SDFxLAST_COMSUB_SYMB),
                       COREHALFWORD (mSTREAMxINCLUDE_SDFxUNIT_SYMBp))))
            // CALL ENTER_COMSUB_ARGS; (3521)
            STREAMxINCLUDE_SDFxENTER_COMSUB_ARGS (0);
        es10s2:;
        } // End of DO block
        break;
      case 3:
        // DO; (3523)
        {
        rs10s3:;
          // IF ((SDF_ROOT_FLAGS &  4) ~= 0) THEN (3523)
          if (1
              & (xNEQ (
                  xAND (COREHALFWORD (mSTREAMxINCLUDE_SDFxSDF_ROOT_FLAGS), 4),
                  0)))
            // SYT_FLAGS(ID_LOC) = SYT_FLAGS(ID_LOC) | REMOTE_FLAG; (3524)
            {
              int32_t numberRHS = (int32_t)(xOR (
                  getFIXED (getFIXED (mSYM_TAB) + 34 * (getFIXED (mID_LOC)) + 8
                            + 4 * (0)),
                  128));
              putFIXED (getFIXED (mSYM_TAB) + 34 * (getFIXED (mID_LOC)) + 8
                            + 4 * (0),
                        numberRHS);
            }
          // BLOCK_MODE(NEST) = FUNC_MODE; (3525)
          {
            descriptor_t *bitRHS = getBIT (8, mFUNC_MODE);
            putBIT (8, mBLOCK_MODE + 1 * (getFIXED (mNEST)), bitRHS);
            bitRHS->inUse = 0;
          }
          // SYT_CLASS(ID_LOC) = FUNC_CLASS; (3526)
          {
            descriptor_t *bitRHS = getBIT (8, mFUNC_CLASS);
            putBIT (8,
                    getFIXED (mSYM_TAB) + 34 * (getFIXED (mID_LOC)) + 30
                        + 1 * (0),
                    bitRHS);
            bitRHS->inUse = 0;
          }
          // CALL SET_TYPE_AND_LEN(ID_LOC); (3527)
          {
            putBITp (16, mSTREAMxINCLUDE_SDFxSET_TYPE_AND_LENxNDX,
                     fixedToBit (32, (int32_t)(getFIXED (mID_LOC))));
            STREAMxINCLUDE_SDFxSET_TYPE_AND_LEN (0);
          }
          // IF LAST_COMSUB_SYMB ~= UNIT_SYMB# THEN (3528)
          if (1
              & (xNEQ (COREHALFWORD (mSTREAMxINCLUDE_SDFxLAST_COMSUB_SYMB),
                       COREHALFWORD (mSTREAMxINCLUDE_SDFxUNIT_SYMBp))))
            // CALL ENTER_COMSUB_ARGS; (3529)
            STREAMxINCLUDE_SDFxENTER_COMSUB_ARGS (0);
        es10s3:;
        } // End of DO block
        break;
      case 4:
        // DO; (3531)
        {
        rs10s4:;
          // BLOCK_MODE(NEST) = CMPL_MODE; (3531)
          {
            descriptor_t *bitRHS = getBIT (8, mCMPL_MODE);
            putBIT (8, mBLOCK_MODE + 1 * (getFIXED (mNEST)), bitRHS);
            bitRHS->inUse = 0;
          }
          // SYT_TYPE(ID_LOC) = COMPOOL_LABEL; (3532)
          {
            int32_t numberRHS = (int32_t)(74);
            putBIT (8,
                    getFIXED (mSYM_TAB) + 34 * (getFIXED (mID_LOC)) + 32
                        + 1 * (0),
                    fixedToBit (8, numberRHS));
          }
          // CSECT_LENGTHS(SCOPE#).PRIMARY = PRIMARY_LENGTH; (3533)
          {
            descriptor_t *bitRHS
                = getBIT (16, mSTREAMxINCLUDE_SDFxCSECT_LENGTH + 2 * 0);
            putBIT (16,
                    getFIXED (mCSECT_LENGTHS) + 4 * (COREHALFWORD (mSCOPEp))
                        + 0 + 2 * (0),
                    bitRHS);
            bitRHS->inUse = 0;
          }
          // CSECT_LENGTHS(SCOPE#).REMOTE = REMOTE_LENGTH; (3534)
          {
            descriptor_t *bitRHS
                = getBIT (16, mSTREAMxINCLUDE_SDFxCSECT_LENGTH + 2 * 1);
            putBIT (16,
                    getFIXED (mCSECT_LENGTHS) + 4 * (COREHALFWORD (mSCOPEp))
                        + 2 + 2 * (0),
                    bitRHS);
            bitRHS->inUse = 0;
          }
          // CSECT_LENGTH(0),CSECT_LENGTH(1) = 0; (3535)
          {
            int32_t numberRHS = (int32_t)(0);
            descriptor_t *bitRHS;
            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
            putBIT (16, mSTREAMxINCLUDE_SDFxCSECT_LENGTH + 2 * (0), bitRHS);
            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
            putBIT (16, mSTREAMxINCLUDE_SDFxCSECT_LENGTH + 2 * (1), bitRHS);
            bitRHS->inUse = 0;
          }
          // CALL ENTER_COMPOOL_VARS; (3536)
          STREAMxINCLUDE_SDFxENTER_COMPOOL_VARS (0);
          // CSECT_LENGTHS(SCOPE#).PRIMARY = PRIMARY_LENGTH; (3537)
          {
            descriptor_t *bitRHS
                = getBIT (16, mSTREAMxINCLUDE_SDFxCSECT_LENGTH + 2 * 0);
            putBIT (16,
                    getFIXED (mCSECT_LENGTHS) + 4 * (COREHALFWORD (mSCOPEp))
                        + 0 + 2 * (0),
                    bitRHS);
            bitRHS->inUse = 0;
          }
          // CSECT_LENGTHS(SCOPE#).REMOTE = REMOTE_LENGTH; (3538)
          {
            descriptor_t *bitRHS
                = getBIT (16, mSTREAMxINCLUDE_SDFxCSECT_LENGTH + 2 * 1);
            putBIT (16,
                    getFIXED (mCSECT_LENGTHS) + 4 * (COREHALFWORD (mSCOPEp))
                        + 2 + 2 * (0),
                    bitRHS);
            bitRHS->inUse = 0;
          }
        es10s4:;
        } // End of DO block
        break;
      case 5:
          // ; (3540)
          ;
        break;
      case 6:
          // ; (3541)
          ;
        break;
      }
  } // End of DO CASE block
  // SYT_FLAGS(NDECSY) = SYT_FLAGS(NDECSY) | ENDSCOPE_FLAG; (3541)
  {
    int32_t numberRHS = (int32_t)(xOR (
        getFIXED (getFIXED (mSYM_TAB) + 34 * (getFIXED (mCOMM + 4 * 10)) + 8
                  + 4 * (0)),
        16384));
    putFIXED (getFIXED (mSYM_TAB) + 34 * (getFIXED (mCOMM + 4 * 10)) + 8
                  + 4 * (0),
              numberRHS);
  }
  // IF REGULAR_PROCMARK > NDECSY THEN (3542)
  if (1 & (xGT (getFIXED (mREGULAR_PROCMARK), getFIXED (mCOMM + 4 * 10))))
    // SYT_PTR(BLOCK_SYTREF(NEST)) = 0; (3543)
    {
      int32_t numberRHS = (int32_t)(0);
      putBIT (16,
              getFIXED (mSYM_TAB)
                  + 34 * (COREHALFWORD (mBLOCK_SYTREF + 2 * getFIXED (mNEST)))
                  + 22 + 2 * (0),
              fixedToBit (16, numberRHS));
    }
  // ELSE (3544)
  else
    // DO I = 0 TO NDECSY - REGULAR_PROCMARK; (3545)
    {
      int32_t from66, to66, by66;
      from66 = 0;
      to66 = xsubtract (getFIXED (mCOMM + 4 * 10),
                        getFIXED (mREGULAR_PROCMARK));
      by66 = 1;
      for (putBIT (16, mSTREAMxINCLUDE_SDFxI, fixedToBit (16, from66));
           bitToFixed (getBIT (16, mSTREAMxINCLUDE_SDFxI)) <= to66; putBIT (
               16, mSTREAMxINCLUDE_SDFxI,
               fixedToBit (16, bitToFixed (getBIT (16, mSTREAMxINCLUDE_SDFxI))
                                   + by66)))
        {
          // J = NDECSY - I; (3546)
          {
            int32_t numberRHS
                = (int32_t)(xsubtract (getFIXED (mCOMM + 4 * 10),
                                       COREHALFWORD (mSTREAMxINCLUDE_SDFxI)));
            descriptor_t *bitRHS;
            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
            putBIT (16, mSTREAMxINCLUDE_SDFxJ, bitRHS);
            bitRHS->inUse = 0;
          }
          // IF (SYT_FLAGS(J) & INACTIVE_FLAG) ~= 0 THEN (3547)
          if (1
              & (xNEQ (
                  xAND (getFIXED (getFIXED (mSYM_TAB)
                                  + 34 * (COREHALFWORD (mSTREAMxINCLUDE_SDFxJ))
                                  + 8 + 4 * (0)),
                        32768),
                  0)))
            // REPEAT; (3548)
            continue;
          // CLOSE_BCD = SYT_NAME(J); (3549)
          {
            descriptor_t *stringRHS;
            stringRHS = getCHARACTER (
                getFIXED (mSYM_TAB)
                + 34 * (COREHALFWORD (mSTREAMxINCLUDE_SDFxJ)) + 0 + 4 * (0));
            putCHARACTER (mCLOSE_BCD, stringRHS);
            stringRHS->inUse = 0;
          }
          // CALL DISCONNECT(J); (3550)
          {
            putBITp (16, mDISCONNECTxLOC, getBIT (16, mSTREAMxINCLUDE_SDFxJ));
            DISCONNECT (0);
          }
        }
    } // End of DO for-loop block
  // SYT_ARRAY(BLOCK_SYTREF(NEST)) =  57344; (3551)
  {
    int32_t numberRHS = (int32_t)(57344);
    putBIT (16,
            getFIXED (mSYM_TAB)
                + 34 * (COREHALFWORD (mBLOCK_SYTREF + 2 * getFIXED (mNEST)))
                + 20 + 2 * (0),
            fixedToBit (16, numberRHS));
  }
  // PROCMARK, REGULAR_PROCMARK = PROCMARK_STACK(NEST); (3552)
  {
    descriptor_t *bitRHS = getBIT (16, mPROCMARK_STACK + 2 * getFIXED (mNEST));
    int32_t numberRHS;
    numberRHS = bitToFixed (bitRHS);
    putFIXED (mPROCMARK, numberRHS);
    numberRHS = bitToFixed (bitRHS);
    putFIXED (mREGULAR_PROCMARK, numberRHS);
    bitRHS->inUse = 0;
  }
  // SCOPE# = SCOPE#_STACK(NEST); (3553)
  {
    descriptor_t *bitRHS = getBIT (16, mSCOPEp_STACK + 2 * getFIXED (mNEST));
    putBIT (16, mSCOPEp, bitRHS);
    bitRHS->inUse = 0;
  }
  // NEST = 0; (3554)
  {
    int32_t numberRHS = (int32_t)(0);
    putFIXED (mNEST, numberRHS);
  }
  // DO I = 0 TO FACTOR_LIM; (3555)
  {
    int32_t from67, to67, by67;
    from67 = 0;
    to67 = 19;
    by67 = 1;
    for (putBIT (16, mSTREAMxINCLUDE_SDFxI, fixedToBit (16, from67));
         bitToFixed (getBIT (16, mSTREAMxINCLUDE_SDFxI)) <= to67; putBIT (
             16, mSTREAMxINCLUDE_SDFxI,
             fixedToBit (16, bitToFixed (getBIT (16, mSTREAMxINCLUDE_SDFxI))
                                 + by67)))
      {
        // TYPE(I) = 0; (3556)
        {
          int32_t numberRHS = (int32_t)(0);
          putFIXED (mTYPE + 4 * (COREHALFWORD (mSTREAMxINCLUDE_SDFxI)),
                    numberRHS);
        }
      }
  } // End of DO for-loop block
  // NAME_IMPLIED, TEMPORARY_IMPLIED = FALSE; (3557)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (1, mNAME_IMPLIED, bitRHS);
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (1, mTEMPORARY_IMPLIED, bitRHS);
    bitRHS->inUse = 0;
  }
  // MACRO_ARG_COUNT, STRUC_PTR, STRUC_DIM, STRUC_SIZE = 0; (3558)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mMACRO_ARG_COUNT, bitRHS);
    putFIXED (mSTRUC_PTR, numberRHS);
    putFIXED (mSTRUC_DIM, numberRHS);
    putFIXED (mSTRUC_SIZE, numberRHS);
    bitRHS->inUse = 0;
  }
  // ID_LOC, REF_ID_LOC = 0; (3559)
  {
    int32_t numberRHS = (int32_t)(0);
    putFIXED (mID_LOC, numberRHS);
    putFIXED (mREF_ID_LOC, numberRHS);
  }
  // INCLUDE_STMT = STMT_NUM; (3560)
  {
    int32_t numberRHS = (int32_t)(getFIXED (mCOMM + 4 * 3));
    putFIXED (mINCLUDE_STMT, numberRHS);
  }
  // STMT_NUM = STMT_NUM + 1; (3561)
  {
    int32_t numberRHS = (int32_t)(xadd (getFIXED (mCOMM + 4 * 3), 1));
    putFIXED (mCOMM + 4 * (3), numberRHS);
  }
  // OUTPUT = X8 || STARS || 'INCLUDED FROM SDF ' || SDF_NAME || X1 || STARS;
  // (3562)
  {
    descriptor_t *stringRHS;
    stringRHS = xsCAT (
        xsCAT (xsCAT (xsCAT (xsCAT (getCHARACTER (mX8), getCHARACTER (mSTARS)),
                             cToDescriptor (NULL, "INCLUDED FROM SDF ")),
                      getCHARACTER (mSTREAMxINCLUDE_SDFxSDF_NAME)),
               getCHARACTER (mX1)),
        getCHARACTER (mSTARS));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT = X8 || STARS || REVSTR || X1 || STARS; (3563)
  {
    descriptor_t *stringRHS;
    stringRHS = xsCAT (
        xsCAT (xsCAT (xsCAT (getCHARACTER (mX8), getCHARACTER (mSTARS)),
                      getCHARACTER (mSTREAMxINCLUDE_SDFxREVSTR)),
               getCHARACTER (mX1)),
        getCHARACTER (mSTARS));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT = X1; (3564)
  {
    descriptor_t *stringRHS;
    stringRHS = getCHARACTER (mX1);
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // DO ; (3565)
  {
  rs13:;
    // CALL MONITOR ( 22 , 1 ) ; (3566)
    MONITOR22 (1);
    // SDF_OPEN = 0 ; (3567)
    {
      int32_t numberRHS = (int32_t)(0);
      descriptor_t *bitRHS;
      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
      putBIT (1, mSDF_OPEN, bitRHS);
      bitRHS->inUse = 0;
    }
  es13:;
  } // End of DO block
  // IF RECORD_ALLOC(FORFCB) > 0 THEN (3568)
  if (1
      & (xGT (COREWORD (xadd (
                  ADDR ("STREAMxINCLUDE_SDFxFORFCB", 0x80000000, NULL, 0), 8)),
              0)))
    // RECORD_FREE(FORFCB); (3569)
    {
      putFIXED (m_RECORD_FREExDOPE,
                ADDR ("STREAMxINCLUDE_SDFxFORFCB", 0x80000000, NULL, 0));
      _RECORD_FREE (0);
    }
  // IF RECORD_ALLOC(PGING) > 0 THEN (3570)
  if (1
      & (xGT (COREWORD (xadd (
                  ADDR ("STREAMxINCLUDE_SDFxPGING", 0x80000000, NULL, 0), 8)),
              0)))
    // RECORD_FREE(PGING); (3571)
    {
      putFIXED (m_RECORD_FREExDOPE,
                ADDR ("STREAMxINCLUDE_SDFxPGING", 0x80000000, NULL, 0));
      _RECORD_FREE (0);
    }
  // IF SIMULATING THEN (3572)
  if (1 & (bitToFixed (getBIT (8, mSIMULATING))))
    // CALL MAKE_INCL_CELL(SDF_NAME, INCL_FLAGS, SHL(REV,16) | CAT); (3573)
    {
      putCHARACTERp (mMAKE_INCL_CELLxNAME,
                     getCHARACTER (mSTREAMxINCLUDE_SDFxSDF_NAME));
      putBITp (8, mMAKE_INCL_CELLxFLAGS,
               getBIT (8, mSTREAMxINCLUDE_SDFxINCL_FLAGS));
      putFIXED (mMAKE_INCL_CELLxREV_CAT,
                xOR (SHL (COREHALFWORD (mSTREAMxINCLUDE_SDFxREV), 16),
                     COREHALFWORD (mSTREAMxINCLUDE_SDFxCAT)));
      MAKE_INCL_CELL (0);
    }
  // RETURN TRUE; (3574)
  {
    reentryGuard = 0;
    return fixedToBit (32, (int32_t)(1));
  }
}
