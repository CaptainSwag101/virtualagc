/*
  File PASS1xPOP_BLOCK_FRAME.c generated by XCOM-I, 2024-08-09 12:39:13.
*/

#include "runtimeC.h"

int32_t
PASS1xPOP_BLOCK_FRAME (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "PASS1xPOP_BLOCK_FRAME");
  // IF STACK_DUMP THEN (1685)
  if (1 & (bitToFixed (getBIT (1, mSTACK_DUMP))))
    // CALL DUMP_STACK; (1686)
    PASS1xDUMP_STACK (0);
  // CALL DECR_STACK_PTR; (1687)
  DECR_STACK_PTR (0);
  // IF FRAME_TYPE(STACK_PTR + 1) ~= BLOCK_TYPE THEN (1688)
  if (1
      & (xNEQ (BYTE0 (getFIXED (mSTACK_FRAME)
                      + 32 * (xadd (COREHALFWORD (mSTACK_PTR), 1)) + 30
                      + 1 * (0)),
               1)))
    // CALL STACK_ERROR('CLOS OR ICLOS', FRAME_TYPE(STACK_PTR + 1), CCURRENT);
    // (1689)
    {
      putCHARACTERp (mPASS1xSTACK_ERRORxHALMAT_TYPE,
                     cToDescriptor (NULL, "CLOS OR ICLOS"));
      putBITp (16, mPASS1xSTACK_ERRORxFRM_TYPE,
               getBIT (8, getFIXED (mSTACK_FRAME)
                              + 32 * (xadd (COREHALFWORD (mSTACK_PTR), 1)) + 30
                              + 1 * (0)));
      putCHARACTERp (mPASS1xSTACK_ERRORxWHICH_FRAME, getCHARACTER (mCCURRENT));
      PASS1xSTACK_ERROR (0);
    }
  // CALL DECODE_HALRAND(1); (1690)
  {
    putBITp (16, mPASS1xDECODE_HALRANDxOP, fixedToBit (32, (int32_t)(1)));
    PASS1xDECODE_HALRAND (0);
  }
  // IF HALRAND ~= FRAME_INL(STACK_PTR + 1) THEN (1691)
  if (1
      & (xNEQ (COREHALFWORD (mHALRAND),
               COREHALFWORD (getFIXED (mSTACK_FRAME)
                             + 32 * (xadd (COREHALFWORD (mSTACK_PTR), 1)) + 8
                             + 2 * (0)))))
    // CALL ERRORS (CLASS_BI, 406); (1692)
    {
      putBITp (16, mERRORSxCLASS, getBIT (16, mCLASS_BI));
      putBITp (16, mERRORSxNUM, fixedToBit (32, (int32_t)(406)));
      ERRORS (0);
    }
  // CALL FREE_SYT_REF_FRAME(FRAME_SYT_REF(STACK_PTR + 1)); (1693)
  {
    putBITp (16, mFREE_SYT_REF_FRAMExPOOL_INDEX,
             getBIT (16, getFIXED (mSTACK_FRAME)
                             + 32 * (xadd (COREHALFWORD (mSTACK_PTR), 1)) + 10
                             + 2 * (0)));
    FREE_SYT_REF_FRAME (0);
  }
  // CALL FREE_VAC_REF_FRAME(FRAME_VAC_REF(STACK_PTR + 1)); (1694)
  {
    putBITp (16, mFREE_VAC_REF_FRAMExPOOL_INDEX,
             getBIT (16, getFIXED (mSTACK_FRAME)
                             + 32 * (xadd (COREHALFWORD (mSTACK_PTR), 1)) + 12
                             + 2 * (0)));
    FREE_VAC_REF_FRAME (0);
  }
  // CALL FREE_SYT_REF_FRAME(FRAME_SYT_PREV_REF(STACK_PTR + 1)); (1695)
  {
    putBITp (16, mFREE_SYT_REF_FRAMExPOOL_INDEX,
             getBIT (16, getFIXED (mSTACK_FRAME)
                             + 32 * (xadd (COREHALFWORD (mSTACK_PTR), 1)) + 14
                             + 2 * (0)));
    FREE_SYT_REF_FRAME (0);
  }
  // CALL FREE_VAC_REF_FRAME(FRAME_VAC_PREV_REF(STACK_PTR + 1)); (1696)
  {
    putBITp (16, mFREE_VAC_REF_FRAMExPOOL_INDEX,
             getBIT (16, getFIXED (mSTACK_FRAME)
                             + 32 * (xadd (COREHALFWORD (mSTACK_PTR), 1)) + 16
                             + 2 * (0)));
    FREE_VAC_REF_FRAME (0);
  }
  // FRAME_BUMP_FACTOR(STACK_PTR) = FRAME_BUMP_FACTOR(STACK_PTR + 1); (1697)
  {
    descriptor_t *bitRHS = getBIT (
        16, getFIXED (mSTACK_FRAME)
                + 32 * (xadd (COREHALFWORD (mSTACK_PTR), 1)) + 18 + 2 * (0));
    putBIT (16,
            getFIXED (mSTACK_FRAME) + 32 * (COREHALFWORD (mSTACK_PTR)) + 18
                + 2 * (0),
            bitRHS);
    bitRHS->inUse = 0;
  }
  // CALL ADD_TO_VAC_BOUNDS(FRAME_START(STACK_PTR + 1), HALMAT_PTR +
  // HALRATOR_#RANDS); (1698)
  {
    putBITp (16, mPASS1xADD_TO_VAC_BOUNDSxSTART,
             getBIT (16, getFIXED (mSTACK_FRAME)
                             + 32 * (xadd (COREHALFWORD (mSTACK_PTR), 1)) + 4
                             + 2 * (0)));
    putBITp (16, mPASS1xADD_TO_VAC_BOUNDSxFINISH,
             fixedToBit (32, (int32_t)(xadd (COREHALFWORD (mHALMAT_PTR),
                                             BYTE0 (mHALRATOR_pRANDS)))));
    PASS1xADD_TO_VAC_BOUNDS (0);
  }
  // IF STACK_DUMP THEN (1699)
  if (1 & (bitToFixed (getBIT (1, mSTACK_DUMP))))
    // CALL DUMP_STACK; (1700)
    PASS1xDUMP_STACK (0);
  {
    reentryGuard = 0;
    return 0;
  }
}
