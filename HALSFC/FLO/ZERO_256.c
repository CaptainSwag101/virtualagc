/*
  File ZERO_256.c generated by XCOM-I, 2024-08-08 04:31:35.
*/

#include "runtimeC.h"

int32_t
ZERO_256 (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "ZERO_256");
  // COUNT = COUNT - 2; (835)
  {
    int32_t numberRHS
        = (int32_t)(xsubtract (COREHALFWORD (mZERO_256xCOUNT), 2));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mZERO_256xCOUNT, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF COUNT < 0 THEN (836)
  if (1 & (xLT (COREHALFWORD (mZERO_256xCOUNT), 0)))
    // DO; (837)
    {
    rs1:;
      {   // (17) CALL INLINE( 88, 1, 0, CORE_ADDR);
        { /*
           * File:      patch17.c
           * For:       ZERO_256.c
           * Notes:     1. Page references are from IBM "ESA/390 Principles of
           *               Operation", SA22-7201-08, Ninth Edition, June 2003.
           *            2. Labels are of the form p%d_%d, where the 1st number
           *               indicates the leading patch number of the block, and
           *               the 2nd is the byte offset of the instruction within
           *               within the block.
           *            3. Known-problematic translations are marked with the
           *               string  "* * * F I X M E * * *" (without spaces).
           * History:   2024-07-18 RSB  Auto-generated by XCOM-I --guess=....
           *                            Inspected.
           */

          p17_0:;
      // (17)          CALL INLINE("58", 1, 0, CORE_ADDR);  /* L   1,CORE_ADDR
      // */
      address360B = (mZERO_256xCORE_ADDR)&0xFFFFFF;
      // Type RX, p. 7-7:		L	1,mZERO_256xCORE_ADDR(0,0)
      detailedInlineBefore (17, "L	1,mZERO_256xCORE_ADDR(0,0)");
      GR[1] = COREWORD (address360B);
      detailedInlineAfter ();

    p17_4:;
      // (18)          CALL INLINE("92", 0, 0, 1, 0);       /* MVI 0(1),X'00'
      // */
      address360A = (GR[1] + 0) & 0xFFFFFF;
      // Type SI, p. 7-83:		MVI	0(1),0
      detailedInlineBefore (18, "MVI	0(1),0");
      memory[address360A] = 0;
      detailedInlineAfter ();

    p17_8:;
    }
}; // (18) CALL INLINE( 146, 0, 0, 1, 0);
es1:;
} // End of DO block
// ELSE (840)
else
// DO; (841)
{
rs2:;
  // MVCTEMP = ADDR(MVC); (842)
  {
    int32_t numberRHS = (int32_t)(-1);
    putFIXED (mZERO_256xMVCTEMP, numberRHS);
  }
  {   // (19) CALL INLINE( 88, 1, 0, CORE_ADDR);
    { /*
       * File:      patch19.c
       * For:       ZERO_256.c
       * Notes:     1. Page references are from IBM "ESA/390 Principles of
       *               Operation", SA22-7201-08, Ninth Edition, June 2003.
       *            2. Labels are of the form p%d_%d, where the 1st number
       *               indicates the leading patch number of the block, and
       *               the 2nd is the byte offset of the instruction within
       *               within the block.
       *            3. Known-problematic translations are marked with the
       *               string  "* * * F I X M E * * *" (without spaces).
       * History:   2024-07-18 RSB  Auto-generated by XCOM-I --guess=....
       */

      p19_0:;
  // (19)          CALL INLINE("58", 1, 0, CORE_ADDR);  /* L   1,CORE_ADDR */
  address360B = (mZERO_256xCORE_ADDR)&0xFFFFFF;
  // Type RX, p. 7-7:		L	1,mZERO_256xCORE_ADDR(0,0)
  detailedInlineBefore (19, "L	1,mZERO_256xCORE_ADDR(0,0)");
  GR[1] = COREWORD (address360B);
  detailedInlineAfter ();

p19_4:;
  // (20)          CALL INLINE("92", 0, 0, 1, 0);       /* MVI 0(1),X'00' */
  address360A = (GR[1] + 0) & 0xFFFFFF;
  // Type SI, p. 7-83:		MVI	0(1),0
  detailedInlineBefore (20, "MVI	0(1),0");
  memory[address360A] = 0;
  detailedInlineAfter ();

p19_8:;
  // (21)          CALL INLINE("48", 2, 0, COUNT);      /* LH  2,COUNT */
  address360B = (mZERO_256xCOUNT)&0xFFFFFF;
  // Type RX, p. 7-80:		LH	2,mZERO_256xCOUNT(0,0)
  detailedInlineBefore (21, "LH	2,mZERO_256xCOUNT(0,0)");
  GR[2] = COREHALFWORD (address360B);
  detailedInlineAfter ();

p19_12:;
  // (22)          CALL INLINE("58", 3, 0, MVCTEMP);    /* L   3,MVCTEMP */
  address360B = (mZERO_256xMVCTEMP)&0xFFFFFF;
  // Type RX, p. 7-7:		L	3,mZERO_256xMVCTEMP(0,0)
  detailedInlineBefore (22, "L	3,mZERO_256xMVCTEMP(0,0)");
  GR[3] = COREWORD (address360B);
  detailedInlineAfter ();

p19_16:;
  // (23)          CALL INLINE("44", 2, 0, 3, 0);       /* EX  2,0(0,3) */
  address360B = (GR[3] + 0) & 0xFFFFFF;
  // Type RX, p. 7-74:		EX	2,0(0,3)
  detailedInlineBefore (23, "EX	2,0(0,3)");
  // Unsupported opcode EX.  See patch24.c.
  // (24)       CALL INLINE("D2", 0, 0, 1, 1, 1, 0);    /* MVC 1(0,1),0(1) */
  address360A = (GR[1] + 1) & 0xFFFFFF;
  address360B = (GR[1] + 0) & 0xFFFFFF;
  // Type SS, p. 7-83:          MVC     1(0,1),0(1)
  detailedInlineBefore (24, "MVC 1(0,1),0(1)");
  mvc (address360A, address360B, GR[2]);
  detailedInlineAfter ();

p19_20:;
}
}
; // (20) CALL INLINE( 146, 0, 0, 1, 0);
; // (21) CALL INLINE( 72, 2, 0, COUNT);
; // (22) CALL INLINE( 88, 3, 0, MVCTEMP);
; // (23) CALL INLINE( 68, 2, 0, 3, 0);
es2:;
} // End of DO block
// RETURN; (848)
{
  reentryGuard = 0;
  return 0;
}
// MVC: (849)
MVC : {   // (24) CALL INLINE( 210, 0, 0, 1, 1, 1, 0);
        { /*
           * File:      patch24.c
           * For:       ZERO_256.c
           * Notes:     1. Page references are from IBM "ESA/390 Principles of
           *               Operation", SA22-7201-08, Ninth Edition, June 2003.
           *            2. Labels are of the form p%d_%d, where the 1st number
           *               indicates the leading patch number of the block, and
           *               the 2nd is the byte offset of the instruction within
           *               within the block.
           *            3. Known-problematic translations are marked with the
           *               string  "* * * F I X M E * * *" (without spaces).
           * History:   2024-07-18 RSB  Auto-generated by XCOM-I --guess=....
           *                            Inspected.
           */

          p24_0:;
// (24)       CALL INLINE("D2", 0, 0, 1, 1, 1, 0);    /* MVC 1(0,1),0(1) */
address360A = (GR[1] + 1) & 0xFFFFFF;
address360B = (GR[1] + 0) & 0xFFFFFF;
// Type SS, p. 7-83:		MVC	1(0,1),0(1)
detailedInlineBefore (24, "MVC	1(0,1),0(1)");
mvc (address360A, address360B, 0);
detailedInlineAfter ();

p24_6:;
}
}
{
  reentryGuard = 0;
  return 0;
}
}
