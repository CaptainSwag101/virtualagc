/*
  File COLLECT_MATCHES.c generated by XCOM-I, 2024-08-09 12:38:53.
*/

#include "runtimeC.h"

int32_t
COLLECT_MATCHES (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "COLLECT_MATCHES");
  // IF TRACE THEN (4405)
  if (1 & (bitToFixed (getBIT (8, mTRACE))))
    // DO; (4406)
    {
    rs1:;
      // OUTPUT = 'COLLECT_MATCHES: '|| H_PTR; (4407)
      {
        descriptor_t *stringRHS;
        stringRHS
            = xsCAT (cToDescriptor (NULL, "COLLECT_MATCHES: "),
                     bitToCharacter (getBIT (16, mCOLLECT_MATCHESxH_PTR)));
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
    es1:;
    } // End of DO block
  // E = ELIMINATE_DIVIDES = FALSE; (4408)
  {
    int32_t numberRHS
        = (int32_t)(xEQ (BYTE0 (mCOLLECT_MATCHESxELIMINATE_DIVIDES), 0));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (8, mCOLLECT_MATCHESxE, bitRHS);
    bitRHS->inUse = 0;
  }
  // CALL FLAG_NODE(H_PTR); (4409)
  {
    putBITp (16, mFLAG_NODExHALMAT_PTR, getBIT (16, mCOLLECT_MATCHESxH_PTR));
    FLAG_NODE (0);
  }
  // IF E THEN (4410)
  if (1 & (bitToFixed (getBIT (8, mCOLLECT_MATCHESxE))))
    // CALL FLAG_MATCHES; (4411)
    FLAG_MATCHES (0);
  // ELSE (4412)
  else
    // IF WATCH THEN (4413)
    if (1 & (bitToFixed (getBIT (8, mWATCH))))
      // CALL PRINT_SENTENCE(HALMAT_NODE_START); (4414)
      {
        putBITp (16, mPRINT_SENTENCExPTR, getBIT (16, mHALMAT_NODE_START));
        PRINT_SENTENCE (0);
      }
  // LAST_INX, HALMAT_PTR, H_INX = HALMAT_NODE_START; (4415)
  {
    descriptor_t *bitRHS = getBIT (16, mHALMAT_NODE_START);
    putBIT (16, mLAST_INX, bitRHS);
    putBIT (16, mHALMAT_PTR, bitRHS);
    putBIT (16, mH_INX, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF FORWARD & REVERSE THEN (4416)
  if (1 & (xAND (BYTE0 (mFORWARD), BYTE0 (mREVERSE))))
    // DO; (4417)
    {
    rs2:;
      // PARITY0# = MPARITY1#; (4418)
      {
        descriptor_t *bitRHS = getBIT (16, mMPARITY1p);
        putBIT (16, mCOLLECT_MATCHESxPARITY0p, bitRHS);
        bitRHS->inUse = 0;
      }
      // PARITY1# = MPARITY0#; (4419)
      {
        descriptor_t *bitRHS = getBIT (16, mMPARITY0p);
        putBIT (16, mCOLLECT_MATCHESxPARITY1p, bitRHS);
        bitRHS->inUse = 0;
      }
    es2:;
    } // End of DO block
  // ELSE (4420)
  else
    // DO; (4421)
    {
    rs3:;
      // PARITY0# = MPARITY0#; (4422)
      {
        descriptor_t *bitRHS = getBIT (16, mMPARITY0p);
        putBIT (16, mCOLLECT_MATCHESxPARITY0p, bitRHS);
        bitRHS->inUse = 0;
      }
      // PARITY1# = MPARITY1#; (4423)
      {
        descriptor_t *bitRHS = getBIT (16, mMPARITY1p);
        putBIT (16, mCOLLECT_MATCHESxPARITY1p, bitRHS);
        bitRHS->inUse = 0;
      }
    es3:;
    } // End of DO block
  // INVERSE = FALSE; (4424)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (8, mINVERSE, bitRHS);
    bitRHS->inUse = 0;
  }
  // POINT1 = GROUP(PARITY0#,E); (4425)
  {
    descriptor_t *bitRHS = (putBITp (16, mCOLLECT_MATCHESxGROUPxPARITYp,
                                     getBIT (16, mCOLLECT_MATCHESxPARITY0p)),
                            putBITp (8, mCOLLECT_MATCHESxGROUPxMATCHED_OPS,
                                     getBIT (8, mCOLLECT_MATCHESxE)),
                            COLLECT_MATCHESxGROUP (0));
    putBIT (16, mPOINT1, bitRHS);
    bitRHS->inUse = 0;
  }
  // INVERSE = TRUE; (4426)
  {
    int32_t numberRHS = (int32_t)(1);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (8, mINVERSE, bitRHS);
    bitRHS->inUse = 0;
  }
  // CALL GROUP(PARITY1#,E); (4427)
  {
    putBITp (16, mCOLLECT_MATCHESxGROUPxPARITYp,
             getBIT (16, mCOLLECT_MATCHESxPARITY1p));
    putBITp (8, mCOLLECT_MATCHESxGROUPxMATCHED_OPS,
             getBIT (8, mCOLLECT_MATCHESxE));
    COLLECT_MATCHESxGROUP (0);
  }
  // IF PARITY0# > 1 THEN (4428)
  if (1 & (xGT (COREHALFWORD (mCOLLECT_MATCHESxPARITY0p), 1)))
    // DO; (4429)
    {
    rs4:;
      // IF PARITY1# >= 1 THEN (4430)
      if (1 & (xGE (COREHALFWORD (mCOLLECT_MATCHESxPARITY1p), 1)))
        // DO; (4431)
        {
        rs4s1:;
          // CALL SET_WORDS(1,PARITY1# = 1 & E,PARITY1# = 1,E); (4432)
          {
            putBITp (8, mSET_WORDSxOPPARITY, fixedToBit (32, (int32_t)(1)));
            putBITp (
                8, mSET_WORDSxMATCHED_OPS,
                fixedToBit (
                    32, (int32_t)(xAND (
                            xEQ (COREHALFWORD (mCOLLECT_MATCHESxPARITY1p), 1),
                            BYTE0 (mCOLLECT_MATCHESxE)))));
            putBITp (
                16, mSET_WORDSxTERMINALp,
                fixedToBit (
                    32, (int32_t)(xEQ (
                            COREHALFWORD (mCOLLECT_MATCHESxPARITY1p), 1))));
            putBITp (8, mSET_WORDSxTAG, getBIT (8, mCOLLECT_MATCHESxE));
            SET_WORDS (0);
          }
          // HALMAT_PTR = LAST_INX; (4433)
          {
            descriptor_t *bitRHS = getBIT (16, mLAST_INX);
            putBIT (16, mHALMAT_PTR, bitRHS);
            bitRHS->inUse = 0;
          }
        es4s1:;
        } // End of DO block
      // ELSE (4434)
      else
        // DO; (4435)
        {
        rs4s2:;
          // HALMAT_PTR = LAST_INX; (4436)
          {
            descriptor_t *bitRHS = getBIT (16, mLAST_INX);
            putBIT (16, mHALMAT_PTR, bitRHS);
            bitRHS->inUse = 0;
          }
          // CALL SET_HALMAT_FLAG(HALMAT_PTR); (4437)
          {
            putBITp (16, mSET_HALMAT_FLAGxPTR, getBIT (16, mHALMAT_PTR));
            SET_HALMAT_FLAG (0);
          }
        es4s2:;
        } // End of DO block
    es4:;
    } // End of DO block
  // ELSE (4438)
  else
    // IF PARITY0# = 1 THEN (4439)
    if (1 & (xEQ (COREHALFWORD (mCOLLECT_MATCHESxPARITY0p), 1)))
      // DO; (4440)
      {
      rs5:;
        // CALL SET_WORDS(1,E,PARITY1# = 1,E,1); (4441)
        {
          putBITp (8, mSET_WORDSxOPPARITY, fixedToBit (32, (int32_t)(1)));
          putBITp (8, mSET_WORDSxMATCHED_OPS, getBIT (8, mCOLLECT_MATCHESxE));
          putBITp (16, mSET_WORDSxTERMINALp,
                   fixedToBit (
                       32, (int32_t)(xEQ (
                               COREHALFWORD (mCOLLECT_MATCHESxPARITY1p), 1))));
          putBITp (8, mSET_WORDSxTAG, getBIT (8, mCOLLECT_MATCHESxE));
          putBITp (8, mSET_WORDSxSPECIAL, fixedToBit (32, (int32_t)(1)));
          SET_WORDS (0);
        }
        // HALMAT_PTR = LAST_INX; (4442)
        {
          descriptor_t *bitRHS = getBIT (16, mLAST_INX);
          putBIT (16, mHALMAT_PTR, bitRHS);
          bitRHS->inUse = 0;
        }
      es5:;
      } // End of DO block
    // ELSE (4443)
    else
      // DO; (4444)
      {
      rs6:;
        // HALMAT_PTR = LAST_INX; (4445)
        {
          descriptor_t *bitRHS = getBIT (16, mLAST_INX);
          putBIT (16, mHALMAT_PTR, bitRHS);
          bitRHS->inUse = 0;
        }
        // CALL SET_HALMAT_FLAG(HALMAT_PTR); (4446)
        {
          putBITp (16, mSET_HALMAT_FLAGxPTR, getBIT (16, mHALMAT_PTR));
          SET_HALMAT_FLAG (0);
        }
      es6:;
      } // End of DO block
  // IF ELIMINATE_DIVIDES THEN (4447)
  if (1 & (bitToFixed (getBIT (8, mCOLLECT_MATCHESxELIMINATE_DIVIDES))))
    // DO; (4448)
    {
    rs7:;
      // ELIMINATE_DIVIDES = FALSE; (4449)
      {
        int32_t numberRHS = (int32_t)(0);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (8, mCOLLECT_MATCHESxELIMINATE_DIVIDES, bitRHS);
        bitRHS->inUse = 0;
      }
      // RETURN; (4450)
      {
        reentryGuard = 0;
        return 0;
      }
    es7:;
    } // End of DO block
  // INVERSE = FALSE; (4451)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (8, mINVERSE, bitRHS);
    bitRHS->inUse = 0;
  }
  // P0 = NPARITY0# - PARITY0#; (4452)
  {
    int32_t numberRHS
        = (int32_t)(xsubtract (COREHALFWORD (mCOLLECT_MATCHESxNPARITY0p),
                               COREHALFWORD (mCOLLECT_MATCHESxPARITY0p)));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mCOLLECT_MATCHESxP0, bitRHS);
    bitRHS->inUse = 0;
  }
  // P1 = NPARITY1# - PARITY1#; (4453)
  {
    int32_t numberRHS
        = (int32_t)(xsubtract (COREHALFWORD (mCOLLECT_MATCHESxNPARITY1p),
                               COREHALFWORD (mCOLLECT_MATCHESxPARITY1p)));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mCOLLECT_MATCHESxP1, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF PARITY0# > 0 THEN (4454)
  if (1 & (xGT (COREHALFWORD (mCOLLECT_MATCHESxPARITY0p), 0)))
    // DO; (4455)
    {
    rs8:;
      // DO FOR TEMP = PARITY0# + 1 TO NPARITY0#; (4456)
      {
        int32_t from101, to101, by101;
        from101 = xadd (COREHALFWORD (mCOLLECT_MATCHESxPARITY0p), 1);
        to101 = bitToFixed (getBIT (16, mCOLLECT_MATCHESxNPARITY0p));
        by101 = 1;
        for (putBIT (16, mCOLLECT_MATCHESxTEMP, fixedToBit (16, from101));
             bitToFixed (getBIT (16, mCOLLECT_MATCHESxTEMP)) <= to101;
             putBIT (16, mCOLLECT_MATCHESxTEMP,
                     fixedToBit (
                         16, bitToFixed (getBIT (16, mCOLLECT_MATCHESxTEMP))
                                 + by101)))
          {
            // CALL SET_WORDS(0,0,1); (4457)
            {
              putBITp (8, mSET_WORDSxOPPARITY, fixedToBit (32, (int32_t)(0)));
              putBITp (8, mSET_WORDSxMATCHED_OPS,
                       fixedToBit (32, (int32_t)(0)));
              putBITp (16, mSET_WORDSxTERMINALp,
                       fixedToBit (32, (int32_t)(1)));
              SET_WORDS (0);
            }
          }
      } // End of DO for-loop block
      // POINT1 = LAST_INX; (4458)
      {
        descriptor_t *bitRHS = getBIT (16, mLAST_INX);
        putBIT (16, mPOINT1, bitRHS);
        bitRHS->inUse = 0;
      }
      // INVERSE = TRUE; (4459)
      {
        int32_t numberRHS = (int32_t)(1);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (8, mINVERSE, bitRHS);
        bitRHS->inUse = 0;
      }
      // IF P1 > 0 THEN (4460)
      if (1 & (xGT (COREHALFWORD (mCOLLECT_MATCHESxP1), 0)))
        // DO; (4461)
        {
        rs8s2:;
          // IF P1 > 1 THEN (4462)
          if (1 & (xGT (COREHALFWORD (mCOLLECT_MATCHESxP1), 1)))
            // CALL GROUP(P1,0); (4463)
            {
              putBITp (16, mCOLLECT_MATCHESxGROUPxPARITYp,
                       getBIT (16, mCOLLECT_MATCHESxP1));
              putBITp (8, mCOLLECT_MATCHESxGROUPxMATCHED_OPS,
                       fixedToBit (32, (int32_t)(0)));
              COLLECT_MATCHESxGROUP (0);
            }
          // CALL SET_WORDS(1,0,P1 = 1); (4464)
          {
            putBITp (8, mSET_WORDSxOPPARITY, fixedToBit (32, (int32_t)(1)));
            putBITp (8, mSET_WORDSxMATCHED_OPS, fixedToBit (32, (int32_t)(0)));
            putBITp (
                16, mSET_WORDSxTERMINALp,
                fixedToBit (32, (int32_t)(xEQ (
                                    COREHALFWORD (mCOLLECT_MATCHESxP1), 1))));
            SET_WORDS (0);
          }
        es8s2:;
        } // End of DO block
    es8:;
    } // End of DO block
  // ELSE (4465)
  else
    // DO; (4466)
    {
    rs9:;
      // INVERSE = TRUE; (4467)
      {
        int32_t numberRHS = (int32_t)(1);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (8, mINVERSE, bitRHS);
        bitRHS->inUse = 0;
      }
      // DO FOR TEMP = 1 TO P1; (4468)
      {
        int32_t from102, to102, by102;
        from102 = 1;
        to102 = bitToFixed (getBIT (16, mCOLLECT_MATCHESxP1));
        by102 = 1;
        for (putBIT (16, mCOLLECT_MATCHESxTEMP, fixedToBit (16, from102));
             bitToFixed (getBIT (16, mCOLLECT_MATCHESxTEMP)) <= to102;
             putBIT (16, mCOLLECT_MATCHESxTEMP,
                     fixedToBit (
                         16, bitToFixed (getBIT (16, mCOLLECT_MATCHESxTEMP))
                                 + by102)))
          {
            // CALL SET_WORDS(0,0,1); (4469)
            {
              putBITp (8, mSET_WORDSxOPPARITY, fixedToBit (32, (int32_t)(0)));
              putBITp (8, mSET_WORDSxMATCHED_OPS,
                       fixedToBit (32, (int32_t)(0)));
              putBITp (16, mSET_WORDSxTERMINALp,
                       fixedToBit (32, (int32_t)(1)));
              SET_WORDS (0);
            }
          }
      } // End of DO for-loop block
      // POINT2 = LAST_INX; (4470)
      {
        descriptor_t *bitRHS = getBIT (16, mLAST_INX);
        putBIT (16, mCOLLECT_MATCHESxPOINT2, bitRHS);
        bitRHS->inUse = 0;
      }
      // INVERSE = FALSE; (4471)
      {
        int32_t numberRHS = (int32_t)(0);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (8, mINVERSE, bitRHS);
        bitRHS->inUse = 0;
      }
      // IF P0 > 1 THEN (4472)
      if (1 & (xGT (COREHALFWORD (mCOLLECT_MATCHESxP0), 1)))
        // DO; (4473)
        {
        rs9s2:;
          // CALL GROUP(P0,0); (4474)
          {
            putBITp (16, mCOLLECT_MATCHESxGROUPxPARITYp,
                     getBIT (16, mCOLLECT_MATCHESxP0));
            putBITp (8, mCOLLECT_MATCHESxGROUPxMATCHED_OPS,
                     fixedToBit (32, (int32_t)(0)));
            COLLECT_MATCHESxGROUP (0);
          }
          // POINT1 = LAST_INX; (4475)
          {
            descriptor_t *bitRHS = getBIT (16, mLAST_INX);
            putBIT (16, mPOINT1, bitRHS);
            bitRHS->inUse = 0;
          }
          // LAST_INX = POINT2; (4476)
          {
            descriptor_t *bitRHS = getBIT (16, mCOLLECT_MATCHESxPOINT2);
            putBIT (16, mLAST_INX, bitRHS);
            bitRHS->inUse = 0;
          }
          // CALL SET_WORDS(1,0,0); (4477)
          {
            putBITp (8, mSET_WORDSxOPPARITY, fixedToBit (32, (int32_t)(1)));
            putBITp (8, mSET_WORDSxMATCHED_OPS, fixedToBit (32, (int32_t)(0)));
            putBITp (16, mSET_WORDSxTERMINALp, fixedToBit (32, (int32_t)(0)));
            SET_WORDS (0);
          }
        es9s2:;
        } // End of DO block
      // ELSE (4478)
      else
        // CALL SET_WORDS(1,0,0,0,1); (4479)
        {
          putBITp (8, mSET_WORDSxOPPARITY, fixedToBit (32, (int32_t)(1)));
          putBITp (8, mSET_WORDSxMATCHED_OPS, fixedToBit (32, (int32_t)(0)));
          putBITp (16, mSET_WORDSxTERMINALp, fixedToBit (32, (int32_t)(0)));
          putBITp (8, mSET_WORDSxTAG, fixedToBit (32, (int32_t)(0)));
          putBITp (8, mSET_WORDSxSPECIAL, fixedToBit (32, (int32_t)(1)));
          SET_WORDS (0);
        }
    es9:;
    } // End of DO block
  {
    reentryGuard = 0;
    return 0;
  }
}
