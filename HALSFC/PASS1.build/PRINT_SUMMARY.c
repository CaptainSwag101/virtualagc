/*
  File PRINT_SUMMARY.c generated by XCOM-I, 2024-08-09 12:38:15.
*/

#include "runtimeC.h"

int32_t
PRINT_SUMMARY (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "PRINT_SUMMARY");
  // CALL OUTPUT_WRITER; (14131)
  OUTPUT_WRITER (0);
  // STMT_PTR = -1; (14132)
  {
    int32_t numberRHS = (int32_t)(-1);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mSTMT_PTR, bitRHS);
    bitRHS->inUse = 0;
  }
  // CALL OUTPUT_WRITER; (14133)
  OUTPUT_WRITER (0);
  // CALL OUTPUT_GROUP; (14134)
  OUTPUT_GROUP (0);
  // IF LISTING2 THEN (14135)
  if (1 & (bitToFixed (getBIT (1, mLISTING2))))
    // CALL MONITOR(0, 2); (14136)
    MONITOR0 (2);
  // IF INCLUDE_OPENED THEN (14137)
  if (1 & (bitToFixed (getBIT (1, mINCLUDE_OPENED))))
    // CALL MONITOR(3, 4); (14138)
    MONITOR3 (4);
  // IF SDF_OPEN THEN (14139)
  if (1 & (bitToFixed (getBIT (1, mSDF_OPEN))))
    // CALL MONITOR(22, 1); (14140)
    MONITOR22 (1);
  // IF MEMORY_FAILURE THEN (14141)
  if (1 & (bitToFixed (getBIT (1, mMEMORY_FAILURE))))
    // GO TO NO_DUMPS; (14142)
    goto NO_DUMPS;
  // EJECT_PAGE; (14143)
  {
    descriptor_t *stringRHS;
    stringRHS = getCHARACTER (mPAGE);
    OUTPUT (1, stringRHS);
    stringRHS->inUse = 0;
  }
  // CALL SYT_DUMP; (14144)
  SYT_DUMP (0);
  // IF RECORD_ALLOC(INIT_APGAREA) >0 THEN (14145)
  if (1
      & (xGT (COREWORD (xadd (ADDR ("INIT_APGAREA", 0x80000000, NULL, 0), 8)),
              0)))
    // DO; (14146)
    {
    rs1:;
      // RECORD_FREE(INIT_AFCBAREA); (14147)
      {
        putFIXED (m_RECORD_FREExDOPE,
                  ADDR ("INIT_AFCBAREA", 0x80000000, NULL, 0));
        _RECORD_FREE (0);
      }
      // RECORD_FREE(INIT_APGAREA); (14148)
      {
        putFIXED (m_RECORD_FREExDOPE,
                  ADDR ("INIT_APGAREA", 0x80000000, NULL, 0));
        _RECORD_FREE (0);
      }
    es1:;
    } // End of DO block
  // RECORD_FREE(MACRO_TEXTS); (14149)
  {
    putFIXED (m_RECORD_FREExDOPE, ADDR ("MACRO_TEXTS", 0x80000000, NULL, 0));
    _RECORD_FREE (0);
  }
  // RECORD_FREE(LINK_SORT); (14150)
  {
    putFIXED (m_RECORD_FREExDOPE, ADDR ("LINK_SORT", 0x80000000, NULL, 0));
    _RECORD_FREE (0);
  }
  // RECORD_FREE(OUTER_REF_TABLE); (14151)
  {
    putFIXED (m_RECORD_FREExDOPE,
              ADDR ("OUTER_REF_TABLE", 0x80000000, NULL, 0));
    _RECORD_FREE (0);
  }
  // DO ; (14152)
  {
  rs2:;
    // IF COREWORD ( ADDR ( SYM_TAB ) + 12 ) >= COREWORD ( ADDR ( SYM_TAB ) + 8
    // ) THEN (14153)
    if (1
        & (xGE (COREWORD (xadd (ADDR ("SYM_TAB", 0x80000000, NULL, 0), 12)),
                COREWORD (xadd (ADDR ("SYM_TAB", 0x80000000, NULL, 0), 8)))))
      // CALL _NEEDMORE_SPACE ( ADDR ( SYM_TAB )  ) ; (14154)
      {
        putFIXED (m_NEEDMORE_SPACExDOPE,
                  ADDR ("SYM_TAB", 0x80000000, NULL, 0));
        _NEEDMORE_SPACE (0);
      }
    // COREWORD ( ADDR ( SYM_TAB ) + 12 ) = COREWORD ( ADDR ( SYM_TAB ) + 12 )
    // + 1 ; (14155)
    {
      int32_t numberRHS = (int32_t)(xadd (
          COREWORD (xadd (ADDR ("SYM_TAB", 0x80000000, NULL, 0), 12)), 1));
      COREWORD2 (xadd (ADDR ("SYM_TAB", 0x80000000, NULL, 0), 12), numberRHS);
    }
  es2:;
  } // End of DO block
  // RECORD_SEAL(SYM_TAB); (14156)
  {
    putFIXED (m_RECORD_SEALxDOPE, ADDR ("SYM_TAB", 0x80000000, NULL, 0));
    _RECORD_SEAL (0);
  }
  // RECORD_SEAL(DOWN_INFO); (14157)
  {
    putFIXED (m_RECORD_SEALxDOPE, ADDR ("DOWN_INFO", 0x80000000, NULL, 0));
    _RECORD_SEAL (0);
  }
  // RECORD_SEAL(CROSS_REF); (14158)
  {
    putFIXED (m_RECORD_SEALxDOPE, ADDR ("CROSS_REF", 0x80000000, NULL, 0));
    _RECORD_SEAL (0);
  }
  // RECORD_SEAL(SYM_ADD); (14159)
  {
    putFIXED (m_RECORD_SEALxDOPE, ADDR ("SYM_ADD", 0x80000000, NULL, 0));
    _RECORD_SEAL (0);
  }
  // RECORD_SEAL(CSECT_LENGTHS); (14160)
  {
    putFIXED (m_RECORD_SEALxDOPE, ADDR ("CSECT_LENGTHS", 0x80000000, NULL, 0));
    _RECORD_SEAL (0);
  }
  // IF CONTROL(14) THEN (14161)
  if (1 & (bitToFixed (getBIT (1, mCONTROL + 1 * 14))))
    // CALL LIT_DUMP; (14162)
    LIT_DUMP (0);
// NO_DUMPS: (14163)
NO_DUMPS:
  // EJECT_PAGE; (14164)
  {
    descriptor_t *stringRHS;
    stringRHS = getCHARACTER (mPAGE);
    OUTPUT (1, stringRHS);
    stringRHS->inUse = 0;
  }
  // CALL DUMPIT; (14165)
  DUMPIT (0);
  // CALL PRINT_DATE_AND_TIME('END OF HAL/S PHASE 1, ', DATE, TIME); (14166)
  {
    putCHARACTERp (mPRINT_DATE_AND_TIMExMESSAGE,
                   cToDescriptor (NULL, "END OF HAL/S PHASE 1, "));
    putFIXED (mPRINT_DATE_AND_TIMExD, DATE ());
    putFIXED (mPRINT_DATE_AND_TIMExT, TIME ());
    PRINT_DATE_AND_TIME (0);
  }
  // OUTPUT = ''; (14167)
  {
    descriptor_t *stringRHS;
    stringRHS = cToDescriptor (NULL, "");
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT = CARD_COUNT || ' CARDS WERE PROCESSED.'; (14168)
  {
    descriptor_t *stringRHS;
    stringRHS = xsCAT (fixedToCharacter (getFIXED (mCARD_COUNT)),
                       cToDescriptor (NULL, " CARDS WERE PROCESSED."));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // IF ERROR_COUNT = 0 THEN (14169)
  if (1 & (xEQ (getFIXED (mERROR_COUNT), 0)))
    // OUTPUT = 'NO ERRORS WERE DETECTED DURING PHASE 1 .'; (14170)
    {
      descriptor_t *stringRHS;
      stringRHS
          = cToDescriptor (NULL, "NO ERRORS WERE DETECTED DURING PHASE 1 .");
      OUTPUT (0, stringRHS);
      stringRHS->inUse = 0;
    }
  // ELSE (14171)
  else
    // DO; (14172)
    {
    rs3:;
      // IF ERROR_COUNT=1 THEN (14173)
      if (1 & (xEQ (getFIXED (mERROR_COUNT), 1)))
        // S='ONE ERROR WAS'; (14174)
        {
          descriptor_t *stringRHS;
          stringRHS = cToDescriptor (NULL, "ONE ERROR WAS");
          putCHARACTER (mS, stringRHS);
          stringRHS->inUse = 0;
        }
      // ELSE (14175)
      else
        // S=ERROR_COUNT||' ERRORS WERE'; (14176)
        {
          descriptor_t *stringRHS;
          stringRHS = xsCAT (fixedToCharacter (getFIXED (mERROR_COUNT)),
                             cToDescriptor (NULL, " ERRORS WERE"));
          putCHARACTER (mS, stringRHS);
          stringRHS->inUse = 0;
        }
      // OUTPUT=S||' DETECTED IN PHASE 1.'; (14177)
      {
        descriptor_t *stringRHS;
        stringRHS = xsCAT (getCHARACTER (mS),
                           cToDescriptor (NULL, " DETECTED IN PHASE 1."));
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
      // CALL ERROR_SUMMARY; (14178)
      ERROR_SUMMARY (0);
    es3:;
    } // End of DO block
  // IF VMEM_LOC_CNT ~= 0 THEN (14179)
  if (1 & (xNEQ (getFIXED (mVMEM_LOC_CNT), 0)))
    // DO; (14180)
    {
    rs4:;
      // DOUBLE_SPACE; (14181)
      {
        descriptor_t *stringRHS;
        stringRHS = getCHARACTER (mDOUBLE);
        OUTPUT (1, stringRHS);
        stringRHS->inUse = 0;
      }
      // OUTPUT = 'NUMBER OF FILE 6 LOCATES          = '||VMEM_LOC_CNT; (14182)
      {
        descriptor_t *stringRHS;
        stringRHS = xsCAT (
            cToDescriptor (NULL, "NUMBER OF FILE 6 LOCATES          = "),
            fixedToCharacter (getFIXED (mVMEM_LOC_CNT)));
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
      // OUTPUT = 'NUMBER OF FILE 6 READS            = '||VMEM_READ_CNT;
      // (14183)
      {
        descriptor_t *stringRHS;
        stringRHS = xsCAT (
            cToDescriptor (NULL, "NUMBER OF FILE 6 READS            = "),
            fixedToCharacter (getFIXED (mVMEM_READ_CNT)));
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
      // OUTPUT = 'NUMBER OF FILE 6 WRITES           = '||VMEM_WRITE_CNT;
      // (14184)
      {
        descriptor_t *stringRHS;
        stringRHS = xsCAT (
            cToDescriptor (NULL, "NUMBER OF FILE 6 WRITES           = "),
            fixedToCharacter (getFIXED (mVMEM_WRITE_CNT)));
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
    es4:;
    } // End of DO block
  // DOUBLE_SPACE; (14185)
  {
    descriptor_t *stringRHS;
    stringRHS = getCHARACTER (mDOUBLE);
    OUTPUT (1, stringRHS);
    stringRHS->inUse = 0;
  }
  // CLOCK(3)=MONITOR(18); (14186)
  {
    int32_t numberRHS = (int32_t)(MONITOR18 ());
    putFIXED (mCLOCK + 4 * (3), numberRHS);
  }
  // DO I = 1 TO 3; (14187)
  {
    int32_t from179, to179, by179;
    from179 = 1;
    to179 = 3;
    by179 = 1;
    for (putFIXED (mPRINT_SUMMARYxI, from179);
         getFIXED (mPRINT_SUMMARYxI) <= to179;
         putFIXED (mPRINT_SUMMARYxI, getFIXED (mPRINT_SUMMARYxI) + by179))
      {
        // IF CLOCK(I) < CLOCK(I-1) THEN (14188)
        if (1
            & (xLT (
                getFIXED (mCLOCK + 4 * getFIXED (mPRINT_SUMMARYxI)),
                getFIXED (mCLOCK
                          + 4 * xsubtract (getFIXED (mPRINT_SUMMARYxI), 1)))))
          // CLOCK(I) = CLOCK(I) + 8640000; (14189)
          {
            int32_t numberRHS = (int32_t)(xadd (
                getFIXED (mCLOCK + 4 * getFIXED (mPRINT_SUMMARYxI)), 8640000));
            putFIXED (mCLOCK + 4 * (getFIXED (mPRINT_SUMMARYxI)), numberRHS);
          }
      }
  } // End of DO for-loop block
  // CALL PRINT_TIME('TOTAL CPU TIME FOR PHASE 1      ',CLOCK(3)-CLOCK(0));
  // (14190)
  {
    putCHARACTERp (mPRINT_TIMExMESSAGE,
                   cToDescriptor (NULL, "TOTAL CPU TIME FOR PHASE 1      "));
    putFIXED (mPRINT_TIMExT, xsubtract (getFIXED (mCLOCK + 4 * 3),
                                        getFIXED (mCLOCK + 4 * 0)));
    PRINT_TIME (0);
  }
  // CALL PRINT_TIME('CPU TIME FOR PHASE 1 SET UP     ',CLOCK(1)-CLOCK(0));
  // (14191)
  {
    putCHARACTERp (mPRINT_TIMExMESSAGE,
                   cToDescriptor (NULL, "CPU TIME FOR PHASE 1 SET UP     "));
    putFIXED (mPRINT_TIMExT, xsubtract (getFIXED (mCLOCK + 4 * 1),
                                        getFIXED (mCLOCK + 4 * 0)));
    PRINT_TIME (0);
  }
  // CALL PRINT_TIME('CPU TIME FOR PHASE 1 PROCESSING ',CLOCK(2)-CLOCK(1));
  // (14192)
  {
    putCHARACTERp (mPRINT_TIMExMESSAGE,
                   cToDescriptor (NULL, "CPU TIME FOR PHASE 1 PROCESSING "));
    putFIXED (mPRINT_TIMExT, xsubtract (getFIXED (mCLOCK + 4 * 2),
                                        getFIXED (mCLOCK + 4 * 1)));
    PRINT_TIME (0);
  }
  // CALL PRINT_TIME('CPU TIME FOR PHASE 1 CLEAN UP   ',CLOCK(3)-CLOCK(2));
  // (14193)
  {
    putCHARACTERp (mPRINT_TIMExMESSAGE,
                   cToDescriptor (NULL, "CPU TIME FOR PHASE 1 CLEAN UP   "));
    putFIXED (mPRINT_TIMExT, xsubtract (getFIXED (mCLOCK + 4 * 3),
                                        getFIXED (mCLOCK + 4 * 2)));
    PRINT_TIME (0);
  }
  // IF CLOCK(2) > CLOCK(1) THEN (14194)
  if (1 & (xGT (getFIXED (mCLOCK + 4 * 2), getFIXED (mCLOCK + 4 * 1))))
    // OUTPUT = 'PROCESSING RATE: ' || 6000*CARD_COUNT/(CLOCK(2)-CLOCK(1)) || '
    // CARDS PER MINUTE.'; (14195)
    {
      descriptor_t *stringRHS;
      stringRHS = xsCAT (xsCAT (cToDescriptor (NULL, "PROCESSING RATE: "),
                                fixedToCharacter (xdivide (
                                    xmultiply (6000, getFIXED (mCARD_COUNT)),
                                    xsubtract (getFIXED (mCLOCK + 4 * 2),
                                               getFIXED (mCLOCK + 4 * 1))))),
                         cToDescriptor (NULL, " CARDS PER MINUTE."));
      OUTPUT (0, stringRHS);
      stringRHS->inUse = 0;
    }
  // DOUBLE_SPACE; (14196)
  {
    descriptor_t *stringRHS;
    stringRHS = getCHARACTER (mDOUBLE);
    OUTPUT (1, stringRHS);
    stringRHS->inUse = 0;
  }
  // IF TPL_FLAG<3 THEN (14197)
  if (1 & (xLT (COREHALFWORD (mTPL_FLAG), 3)))
    // IF (COMPILING& 128)=0|MAX_SEVERITY>0 THEN (14198)
    if (1
        & (xOR (xEQ (xAND (BYTE0 (mCOMPILING), 128), 0),
                xGT (getFIXED (mMAX_SEVERITY), 0))))
      // DO; (14199)
      {
      rs6:;
        // TPL_FLAG=3; (14200)
        {
          int32_t numberRHS = (int32_t)(3);
          descriptor_t *bitRHS;
          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
          putBIT (16, mTPL_FLAG, bitRHS);
          bitRHS->inUse = 0;
        }
        // OUTPUT='*******  COMPILATION ERRORS INHIBITED TEMPLATE GENERATION';
        // (14201)
        {
          descriptor_t *stringRHS;
          stringRHS = cToDescriptor (
              NULL,
              "*******  COMPILATION ERRORS INHIBITED TEMPLATE GENERATION");
          OUTPUT (0, stringRHS);
          stringRHS->inUse = 0;
        }
      es6:;
      } // End of DO block
  // IF TPL_FLAG = 3 THEN (14202)
  if (1 & (xEQ (COREHALFWORD (mTPL_FLAG), 3)))
    // DO; (14203)
    {
    rs7:;
      // CALL MONITOR(0, 6); (14204)
      MONITOR0 (6);
      // RETURN; (14205)
      {
        reentryGuard = 0;
        return 0;
      }
    es7:;
    } // End of DO block
  // CALL MONITOR(16, 128); (14206)
  MONITOR16 (128);
  // IF ~TPL_FLAG THEN (14207)
  if (1 & (xNOT (COREHALFWORD (mTPL_FLAG))))
    // DO; (14208)
    {
    rs8:;
      // CALL MONITOR(1,6,TPL_NAME); (14209)
      MONITOR1 (6, getCHARACTER (mTPL_NAME));
      // CALL MONITOR(16, 64); (14210)
      MONITOR16 (64);
    es8:;
    } // End of DO block
  // ELSE (14211)
  else
    // CALL MONITOR(0, 6); (14212)
    MONITOR0 (6);
  // DO CASE TPL_FLAG; (14213)
  {
  rs9:
    switch (COREHALFWORD (mTPL_FLAG))
      {
      case 0:
        // DO; (14215)
        {
        rs9s1:;
          // S=' NOT FOUND - ADDED '; (14215)
          {
            descriptor_t *stringRHS;
            stringRHS = cToDescriptor (NULL, " NOT FOUND - ADDED ");
            putCHARACTER (mS, stringRHS);
            stringRHS->inUse = 0;
          }
        es9s1:;
        } // End of DO block
        break;
      case 1:
        // S=' FOUND - CHANGE NOT REQUIRED '; (14217)
        {
          descriptor_t *stringRHS;
          stringRHS = cToDescriptor (NULL, " FOUND - CHANGE NOT REQUIRED ");
          putCHARACTER (mS, stringRHS);
          stringRHS->inUse = 0;
        }
        break;
      case 2:
        // DO; (14218)
        {
        rs9s2:;
          // S=' FOUND AND CHANGED '; (14218)
          {
            descriptor_t *stringRHS;
            stringRHS = cToDescriptor (NULL, " FOUND AND CHANGED ");
            putCHARACTER (mS, stringRHS);
            stringRHS->inUse = 0;
          }
        es9s2:;
        } // End of DO block
        break;
      }
  } // End of DO CASE block
  // IF ~SDL_OPTION THEN (14219)
  if (1 & (xNOT (BYTE0 (mSDL_OPTION))))
    // S = S || ', VERSION=' || SYT_LOCK#(BLOCK_SYTREF(1)); (14220)
    {
      descriptor_t *stringRHS;
      stringRHS = xsCAT (
          xsCAT (getCHARACTER (mS), cToDescriptor (NULL, ", VERSION=")),
          bitToCharacter (
              getBIT (8, getFIXED (mSYM_TAB)
                             + 34 * (COREHALFWORD (mBLOCK_SYTREF + 2 * 1)) + 31
                             + 1 * (0))));
      putCHARACTER (mS, stringRHS);
      stringRHS->inUse = 0;
    }
  // OUTPUT='******* TEMPLATE LIBRARY MEMBER '||TPL_NAME||S; (14221)
  {
    descriptor_t *stringRHS;
    stringRHS = xsCAT (
        xsCAT (cToDescriptor (NULL, "******* TEMPLATE LIBRARY MEMBER "),
               getCHARACTER (mTPL_NAME)),
        getCHARACTER (mS));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  {
    reentryGuard = 0;
    return 0;
  }
}
