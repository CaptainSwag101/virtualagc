/*
  File SCANxID_LOOP.c generated by XCOM-I, 2024-08-09 12:38:15.
*/

#include "runtimeC.h"

int32_t
SCANxID_LOOP (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "SCANxID_LOOP");
  // S1=NEXT_CHAR=BYTE('_'); (6760)
  {
    int32_t numberRHS = (int32_t)(xEQ (BYTE0 (mNEXT_CHAR),
                                       BYTE1 (cToDescriptor (NULL, "_"))));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mSCANxS1, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF LENGTH(BCD) < ID_LIMIT THEN (6761)
  if (1 & (xLT (LENGTH (getCHARACTER (mBCD)), 32)))
    // DO; (6762)
    {
    rs1:;
      // CALL BUILD_BCD; (6763)
      SCANxBUILD_BCD (0);
      // IF OVER_PUNCH ~= 0 THEN (6764)
      if (1 & (xNEQ (BYTE0 (mOVER_PUNCH), 0)))
        // DO; (6765)
        {
        rs1s1:;
          // IF IMPLIED_TYPE > 0 THEN (6766)
          if (1 & (xGT (COREHALFWORD (mIMPLIED_TYPE), 0)))
            // CALL ERROR(CLASS_MO,3); (6767)
            {
              putBITp (16, mERRORxCLASS, getBIT (16, mCLASS_MO));
              putBITp (8, mERRORxNUM, fixedToBit (32, (int32_t)(3)));
              ERROR (0);
            }
          // ELSE (6768)
          else
            // DO; (6769)
            {
            rs1s1s1:;
              // DO I = 1 TO OVER_PUNCH_SIZE; (6770)
              {
                int32_t from105, to105, by105;
                from105 = 1;
                to105 = 4;
                by105 = 1;
                for (putFIXED (mI, from105); getFIXED (mI) <= to105;
                     putFIXED (mI, getFIXED (mI) + by105))
                  {
                    // IF OVER_PUNCH = OVER_PUNCH_TYPE(I) THEN (6771)
                    if (1
                        & (xEQ (
                            BYTE0 (mOVER_PUNCH),
                            getFIXED (mOVER_PUNCH_TYPE + 4 * getFIXED (mI)))))
                      // DO; (6772)
                      {
                      rs1s1s1s1s1:;
                        // IMPLIED_TYPE = I; (6773)
                        {
                          int32_t numberRHS = (int32_t)(getFIXED (mI));
                          descriptor_t *bitRHS;
                          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                          putBIT (16, mIMPLIED_TYPE, bitRHS);
                          bitRHS->inUse = 0;
                        }
                        // GO TO NEW_CHAR; (6774)
                        goto NEW_CHAR;
                      es1s1s1s1s1:;
                      } // End of DO block
                  }
              } // End of DO for-loop block
              // CALL ERROR(CLASS_MO,4); (6775)
              {
                putBITp (16, mERRORxCLASS, getBIT (16, mCLASS_MO));
                putBITp (8, mERRORxNUM, fixedToBit (32, (int32_t)(4)));
                ERROR (0);
              }
              // OVER_PUNCH = 0; (6776)
              {
                int32_t numberRHS = (int32_t)(0);
                descriptor_t *bitRHS;
                bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                putBIT (8, mOVER_PUNCH, bitRHS);
                bitRHS->inUse = 0;
              }
            es1s1s1:;
            } // End of DO block
        es1s1:;
        } // End of DO block
    es1:;
    } // End of DO block
  // ELSE (6777)
  else
    // DO; (6778)
    {
    rs2:;
      // IF ~STRING_OVERFLOW THEN (6779)
      if (1 & (xNOT (BYTE0 (mSTRING_OVERFLOW))))
        // DO; (6780)
        {
        rs2s1:;
          // CALL ERROR(CLASS_IL,2); (6781)
          {
            putBITp (16, mERRORxCLASS, getBIT (16, mCLASS_IL));
            putBITp (8, mERRORxNUM, fixedToBit (32, (int32_t)(2)));
            ERROR (0);
          }
          // STRING_OVERFLOW = TRUE; (6782)
          {
            int32_t numberRHS = (int32_t)(1);
            descriptor_t *bitRHS;
            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
            putBIT (1, mSTRING_OVERFLOW, bitRHS);
            bitRHS->inUse = 0;
          }
        es2s1:;
        } // End of DO block
    es2:;
    } // End of DO block
// NEW_CHAR: (6783)
NEW_CHAR:
  // CALL STREAM; (6784)
  STREAM (0);
  {
    reentryGuard = 0;
    return 0;
  }
}
