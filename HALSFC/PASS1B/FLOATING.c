/*
  File FLOATING.c generated by XCOM-I, 2024-08-09 12:40:41.
*/

#include "runtimeC.h"

int32_t
FLOATING (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "FLOATING");
  // DW(0)=DW(8); (1229)
  {
    int32_t numberRHS
        = (int32_t)(getFIXED (getFIXED (mFOR_DW) + 4 * (8) + 0 + 4 * (0)));
    putFIXED (getFIXED (mFOR_DW) + 4 * (0) + 0 + 4 * (0), numberRHS);
  }
  // IF VAL<0 THEN (1230)
  if (1 & (xLT (getFIXED (mFLOATINGxVAL), 0)))
    // DO; (1231)
    {
    rs1:;
      // VAL=-VAL; (1232)
      {
        int32_t numberRHS = (int32_t)(xminus (getFIXED (mFLOATINGxVAL)));
        putFIXED (mFLOATINGxVAL, numberRHS);
      }
      {   // (46) CALL INLINE( 88,1,0,DW_AD);
        { // File:      patch46.c
          // For:       FLOATING.c
          // Notes:     1. Page references are from IBM "ESA/390 Principles of
          //               Operation", SA22-7201-08, Ninth Edition, June 2003.
          //            2. Labels are of the form p%d_%d, where the 1st number
          //               indicates the leading patch number of the block, and
          //               the 2nd is the byte offset of the instruction within
          //               within the block.
          //            3. Known-problematic translations are marked with the
          //               string  "* * * F I X M E * * *" (without spaces).
          // History:   2024-07-17 RSB  Auto-generated by XCOM-I --guess=....
          //                            Inspected.

          p46_0:;
      // (46)          CALL INLINE("58",1,0,DW_AD);
      address360B = (mDW_AD)&0xFFFFFF;
      // Type RX, p. 7-7:		L	1,mDW_AD(0,0)
      detailedInlineBefore (46, "L	1,mDW_AD(0,0)");
      GR[1] = COREWORD (address360B);
      detailedInlineAfter ();

    p46_4:;
      // (47)          CALL INLINE("97",8,0,1,0);
      address360A = (GR[1] + 0) & 0xFFFFFF;
      // Type SI, p. 7-74:		XI	0(1),128
      detailedInlineBefore (47, "XI	0(1),128");
      scratch = 128 ^ memory[address360A];
      CC = (scratch != 0);
      memory[address360A] = scratch;
      detailedInlineAfter ();

    p46_8:;
    }
}; // (47) CALL INLINE( 151,8,0,1,0);
es1:;
} // End of DO block
// DW(1)=VAL; (1235)
{
  int32_t numberRHS = (int32_t)(getFIXED (mFLOATINGxVAL));
  putFIXED (getFIXED (mFOR_DW) + 4 * (1) + 0 + 4 * (0), numberRHS);
}
{   // (48) CALL INLINE( 88,1,0,DW_AD);
  { // File:      patch48.c
    // For:       FLOATING.c
    // Notes:     1. Page references are from IBM "ESA/390 Principles of
    //               Operation", SA22-7201-08, Ninth Edition, June 2003.
    //            2. Labels are of the form p%d_%d, where the 1st number
    //               indicates the leading patch number of the block, and
    //               the 2nd is the byte offset of the instruction within
    //               within the block.
    //            3. Known-problematic translations are marked with the
    //               string  "* * * F I X M E * * *" (without spaces).
    // History:   2024-07-17 RSB  Auto-generated by XCOM-I --guess=....
    //                            Inspected.

    p48_0:;
// (48)       CALL INLINE("58",1,0,DW_AD);                          /* L
// 1,DW_AD  */
address360B = (mDW_AD)&0xFFFFFF;
// Type RX, p. 7-7:		L	1,mDW_AD(0,0)
detailedInlineBefore (48, "L	1,mDW_AD(0,0)");
GR[1] = COREWORD (address360B);
detailedInlineAfter ();

p48_4:;
// (49)       CALL INLINE("2B",0,0);                                /* SDR  0,0
// */ Type RR, p. 18-23:		SDR	0,0
detailedInlineBefore (49, "SDR	0,0");
scratchd = FR[0] - FR[0];
setCCd ();
FR[0] = scratchd;
detailedInlineAfter ();

p48_6:;
// (50)       CALL INLINE("6A",0,0,1,0);                            /* AD
// 0,0(0,1) */
address360B = (GR[1] + 0) & 0xFFFFFF;
// Type RX, p. 18-8:		AD	0,0(0,1)
detailedInlineBefore (50, "AD	0,0(0,1)");
scratchd = FR[0];
scratchd += fromFloatIBM (COREWORD (address360B), COREWORD (address360B + 4));
setCCd ();
FR[0] = scratchd;
detailedInlineAfter ();

p48_10:;
// (51)       CALL INLINE("60",0,0,1,0);                            /* STD
// 0,0(0,1) */
address360B = (GR[1] + 0) & 0xFFFFFF;
// Type RX, p. 9-11:		STD	0,0(0,1)
detailedInlineBefore (51, "STD	0,0(0,1)");
std (0, address360B);
detailedInlineAfter ();

p48_14:;
}
}
; // (49) CALL INLINE( 43,0,0);
; // (50) CALL INLINE( 106,0,0,1,0);
; // (51) CALL INLINE( 96,0,0,1,0);
{
  reentryGuard = 0;
  return 0;
}
}
