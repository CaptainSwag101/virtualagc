/*
  File PASS1xSET_RAND_NOOSExINTERVENING_CB.c generated by XCOM-I, 2024-08-08
  04:32:08.
*/

#include "runtimeC.h"

descriptor_t *
PASS1xSET_RAND_NOOSExINTERVENING_CB (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (descriptor_t *)0;
    }
  reentryGuard
      = guardReentry (reentryGuard, "PASS1xSET_RAND_NOOSExINTERVENING_CB");
  // TEMP_PTR1, TEMP_PTR2 = STACK_PTR; (1407)
  {
    descriptor_t *bitRHS = getBIT (16, mSTACK_PTR);
    putBIT (16, mPASS1xSET_RAND_NOOSExINTERVENING_CBxTEMP_PTR1, bitRHS);
    putBIT (16, mPASS1xSET_RAND_NOOSExINTERVENING_CBxTEMP_PTR2, bitRHS);
    bitRHS->inUse = 0;
  }
  // DO WHILE TRUE; (1408)
  while (1 & (1))
    {
      // IF FRAME_START(TEMP_PTR1) <= FINISH THEN (1409)
      if (1
          & (xLE (
              COREHALFWORD (
                  getFIXED (mSTACK_FRAME)
                  + 32
                        * (COREHALFWORD (
                            mPASS1xSET_RAND_NOOSExINTERVENING_CBxTEMP_PTR1))
                  + 4 + 2 * (0)),
              COREHALFWORD (mPASS1xSET_RAND_NOOSExINTERVENING_CBxFINISH))))
        // GO TO EXIT_FF_LOOP; (1410)
        goto EXIT_FF_LOOP;
      // TEMP_PTR1 = TEMP_PTR1 - 1; (1411)
      {
        int32_t numberRHS = (int32_t)(xsubtract (
            COREHALFWORD (mPASS1xSET_RAND_NOOSExINTERVENING_CBxTEMP_PTR1), 1));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mPASS1xSET_RAND_NOOSExINTERVENING_CBxTEMP_PTR1, bitRHS);
        bitRHS->inUse = 0;
      }
    } // End of DO WHILE block
// EXIT_FF_LOOP: (1412)
EXIT_FF_LOOP:
  // DO WHILE TRUE; (1413)
  while (1 & (1))
    {
      // IF FRAME_START(TEMP_PTR2) <= START THEN (1414)
      if (1
          & (xLE (
              COREHALFWORD (
                  getFIXED (mSTACK_FRAME)
                  + 32
                        * (COREHALFWORD (
                            mPASS1xSET_RAND_NOOSExINTERVENING_CBxTEMP_PTR2))
                  + 4 + 2 * (0)),
              COREHALFWORD (mPASS1xSET_RAND_NOOSExINTERVENING_CBxSTART))))
        // GO TO EXIT_FS_LOOP; (1415)
        goto EXIT_FS_LOOP;
      // TEMP_PTR2 = TEMP_PTR2 - 1; (1416)
      {
        int32_t numberRHS = (int32_t)(xsubtract (
            COREHALFWORD (mPASS1xSET_RAND_NOOSExINTERVENING_CBxTEMP_PTR2), 1));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mPASS1xSET_RAND_NOOSExINTERVENING_CBxTEMP_PTR2, bitRHS);
        bitRHS->inUse = 0;
      }
      if (0)
        {
        rs2:
          continue;
        es2:
          break;
        } // block labeled EXIT_FF_LOOP
    }     // End of DO WHILE block
// EXIT_FS_LOOP: (1417)
EXIT_FS_LOOP:
  // IF TEMP_PTR1 = TEMP_PTR2 THEN (1418)
  if (1
      & (xEQ (COREHALFWORD (mPASS1xSET_RAND_NOOSExINTERVENING_CBxTEMP_PTR1),
              COREHALFWORD (mPASS1xSET_RAND_NOOSExINTERVENING_CBxTEMP_PTR2))))
    // RETURN FALSE; (1419)
    {
      reentryGuard = 0;
      return fixedToBit (32, (int32_t)(0));
    }
  // WORK1 = TEMP_PTR1; (1420)
  {
    descriptor_t *bitRHS
        = getBIT (16, mPASS1xSET_RAND_NOOSExINTERVENING_CBxTEMP_PTR1);
    int32_t numberRHS;
    numberRHS = bitToFixed (bitRHS);
    putFIXED (mWORK1, numberRHS);
    bitRHS->inUse = 0;
  }
  // DO WHILE TRUE; (1421)
  while (1 & (1))
    {
      // IF FRAME_TYPE(WORK1) = CASE_TYPE THEN (1422)
      if (1
          & (xEQ (BYTE0 (getFIXED (mSTACK_FRAME) + 32 * (getFIXED (mWORK1))
                         + 30 + 1 * (0)),
                  3)))
        // RETURN TRUE; (1423)
        {
          reentryGuard = 0;
          return fixedToBit (32, (int32_t)(1));
        }
      // IF FRAME_TYPE(WORK1) = BLOCK_TYPE THEN (1424)
      if (1
          & (xEQ (BYTE0 (getFIXED (mSTACK_FRAME) + 32 * (getFIXED (mWORK1))
                         + 30 + 1 * (0)),
                  1)))
        // RETURN FALSE; (1425)
        {
          reentryGuard = 0;
          return fixedToBit (32, (int32_t)(0));
        }
      // WORK1 = WORK1 - 1; (1426)
      {
        int32_t numberRHS = (int32_t)(xsubtract (getFIXED (mWORK1), 1));
        putFIXED (mWORK1, numberRHS);
      }
      // IF WORK1 = TEMP_PTR2 THEN (1427)
      if (1
          & (xEQ (
              getFIXED (mWORK1),
              COREHALFWORD (mPASS1xSET_RAND_NOOSExINTERVENING_CBxTEMP_PTR2))))
        // RETURN FALSE; (1428)
        {
          reentryGuard = 0;
          return fixedToBit (32, (int32_t)(0));
        }
    } // End of DO WHILE block
  {
    reentryGuard = 0;
    return 0;
  }
}
