/*
  File PASS1xDECODE_HALRATOR.c generated by XCOM-I, 2024-08-08 04:32:08.
*/

#include "runtimeC.h"

int32_t
PASS1xDECODE_HALRATOR (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "PASS1xDECODE_HALRATOR");
  // TEMP_MAT = HALMAT(OP); (1251)
  {
    int32_t numberRHS = (int32_t)(getFIXED (
        mHALMAT + 4 * COREHALFWORD (mPASS1xDECODE_HALRATORxOP)));
    putFIXED (mTEMP_MAT, numberRHS);
  }
  // IF (TEMP_MAT & 1) ~= 0 THEN (1252)
  if (1 & (xNEQ (xAND (getFIXED (mTEMP_MAT), 1), 0)))
    // CALL ERRORS (CLASS_BI, 403, ' '||CURR_HALMAT_BLOCK - 1||':'||OP); (1253)
    {
      putBITp (16, mERRORSxCLASS, getBIT (16, mCLASS_BI));
      putBITp (16, mERRORSxNUM, fixedToBit (32, (int32_t)(403)));
      putCHARACTERp (
          mERRORSxTEXT,
          xsCAT (xsCAT (xsCAT (cToDescriptor (NULL, " "),
                               fixedToCharacter (xsubtract (
                                   COREHALFWORD (mCURR_HALMAT_BLOCK), 1))),
                        cToDescriptor (NULL, ":")),
                 bitToCharacter (getBIT (16, mPASS1xDECODE_HALRATORxOP))));
      ERRORS (0);
    }
  // HALRATOR_TAG2 = TEMP_MAT &  15; (1254)
  {
    int32_t numberRHS = (int32_t)(xAND (getFIXED (mTEMP_MAT), 15));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (8, mHALRATOR_TAG2, bitRHS);
    bitRHS->inUse = 0;
  }
  // HALRATOR = SHR(TEMP_MAT, 4) &  255; (1255)
  {
    int32_t numberRHS = (int32_t)(xAND (SHR (getFIXED (mTEMP_MAT), 4), 255));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mHALRATOR, bitRHS);
    bitRHS->inUse = 0;
  }
  // HALRATOR_CLASS = SHR(TEMP_MAT, 12) &  15; (1256)
  {
    int32_t numberRHS = (int32_t)(xAND (SHR (getFIXED (mTEMP_MAT), 12), 15));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (8, mHALRATOR_CLASS, bitRHS);
    bitRHS->inUse = 0;
  }
  // HALRATOR_#RANDS = SHR(TEMP_MAT, 16) &  255; (1257)
  {
    int32_t numberRHS = (int32_t)(xAND (SHR (getFIXED (mTEMP_MAT), 16), 255));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (8, mHALRATOR_pRANDS, bitRHS);
    bitRHS->inUse = 0;
  }
  // HALRATOR_TAG1 = SHR(TEMP_MAT, 24) &  255; (1258)
  {
    int32_t numberRHS = (int32_t)(xAND (SHR (getFIXED (mTEMP_MAT), 24), 255));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (8, mHALRATOR_TAG1, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF OPCODE_TRACE THEN (1259)
  if (1 & (bitToFixed (getBIT (1, mOPCODE_TRACE))))
    // OUTPUT = TRACE_MSG( 'HALRATOR =' || HEX(HALRATOR_CLASS, 1) ||
    // HEX(HALRATOR, 2), OP ); (1260)
    {
      descriptor_t *stringRHS;
      stringRHS
          = (putCHARACTERp (
                 mTRACE_MSGxMSG,
                 xsCAT (xsCAT (cToDescriptor (NULL, "HALRATOR ="),
                               (putBITp (16, mHEXxNUMBER,
                                         getBIT (8, mHALRATOR_CLASS)),
                                putBITp (16, mHEXxTOTAL_LENGTH,
                                         fixedToBit (32, (int32_t)(1))),
                                HEX (0))),
                        (putBITp (16, mHEXxNUMBER, getBIT (16, mHALRATOR)),
                         putBITp (16, mHEXxTOTAL_LENGTH,
                                  fixedToBit (32, (int32_t)(2))),
                         HEX (0)))),
             putBITp (16, mTRACE_MSGxHALMATp,
                      getBIT (16, mPASS1xDECODE_HALRATORxOP)),
             TRACE_MSG (0));
      OUTPUT (0, stringRHS);
      stringRHS->inUse = 0;
    }
  {
    reentryGuard = 0;
    return 0;
  }
}
