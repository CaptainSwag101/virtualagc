/*
  File REARRANGE_HALMAT.c generated by XCOM-I, 2024-08-08 04:34:00.
*/

#include "runtimeC.h"

int32_t
REARRANGE_HALMAT (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "REARRANGE_HALMAT");
  // IF TRACE THEN (4506)
  if (1 & (bitToFixed (getBIT (8, mTRACE))))
    // OUTPUT = 'REARRANGE_HALMAT: PRESENT_HALMAT '|| PRESENT_HALMAT||'
    // PREVIOUS_HALMAT '||PREVIOUS_HALMAT; (4507)
    {
      descriptor_t *stringRHS;
      stringRHS = xsCAT (
          xsCAT (
              xsCAT (cToDescriptor (NULL, "REARRANGE_HALMAT: PRESENT_HALMAT "),
                     bitToCharacter (getBIT (16, mPRESENT_HALMAT))),
              cToDescriptor (NULL, " PREVIOUS_HALMAT ")),
          bitToCharacter (getBIT (16, mPREVIOUS_HALMAT)));
      OUTPUT (0, stringRHS);
      stringRHS->inUse = 0;
    }
  // FORWARD = FALSE; (4508)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (8, mFORWARD, bitRHS);
    bitRHS->inUse = 0;
  }
  // PREVIOUS_TWIN = TWIN_HALMATTED(LAST_OP(PREVIOUS_HALMAT)); (4509)
  {
    descriptor_t *bitRHS
        = (putBITp (16, mTWIN_HALMATTEDxPTR,
                    fixedToBit (
                        32, (int32_t)((putBITp (16, mLAST_OPxPTR,
                                                getBIT (16, mPREVIOUS_HALMAT)),
                                       LAST_OP (0))))),
           TWIN_HALMATTED (0));
    putBIT (8, mPREVIOUS_TWIN, bitRHS);
    bitRHS->inUse = 0;
  }
  // TOPTAG = HALMAT_FLAG(PREVIOUS_HALMAT) ; (4510)
  {
    descriptor_t *bitRHS
        = (putBITp (16, mHALMAT_FLAGxPTR, getBIT (16, mPREVIOUS_HALMAT)),
           HALMAT_FLAG (0));
    putBIT (8, mTOPTAG, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF TOPTAG THEN (4511)
  if (1 & (bitToFixed (getBIT (8, mTOPTAG))))
    // IF PREVIOUS_TWIN THEN (4512)
    if (1 & (bitToFixed (getBIT (8, mPREVIOUS_TWIN))))
      // TOPTAG = ( (NODE(PREVIOUS_NODE) & MATCHED_TAG) = MATCHED_TAG); (4513)
      {
        int32_t numberRHS = (int32_t)(xEQ (
            xAND (getFIXED (mNODE + 4 * COREHALFWORD (mPREVIOUS_NODE)),
                  getFIXED (mMATCHED_TAG)),
            getFIXED (mMATCHED_TAG)));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (8, mTOPTAG, bitRHS);
        bitRHS->inUse = 0;
      }
  // TOTAL_MATCH_PREV = FALSE; (4514)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (8, mTOTAL_MATCH_PREV, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF PNPARITY0# + PNPARITY1# = CSE_FOUND_INX - 1 THEN (4515)
  if (1
      & (xEQ (xadd (COREHALFWORD (mPNPARITY0p), COREHALFWORD (mPNPARITY1p)),
              xsubtract (COREHALFWORD (mCSE_FOUND_INX), 1))))
    // DO; (4516)
    {
    rs1:;
      // TOTAL_MATCH_PREV = TRUE; (4517)
      {
        int32_t numberRHS = (int32_t)(1);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (8, mTOTAL_MATCH_PREV, bitRHS);
        bitRHS->inUse = 0;
      }
      // IF TWIN_MATCH THEN (4518)
      if (1 & (bitToFixed (getBIT (8, mTWIN_MATCH))))
        // NEW_NODE_PTR = PRESENT_NODE_PTR; (4519)
        {
          descriptor_t *bitRHS = getBIT (16, mPRESENT_NODE_PTR);
          putBIT (16, mNEW_NODE_PTR, bitRHS);
          bitRHS->inUse = 0;
        }
      // ELSE (4520)
      else
        // NEW_NODE_PTR = PREVIOUS_NODE_PTR; (4521)
        {
          descriptor_t *bitRHS = getBIT (16, mPREVIOUS_NODE_PTR);
          putBIT (16, mNEW_NODE_PTR, bitRHS);
          bitRHS->inUse = 0;
        }
    es1:;
    } // End of DO block
  // ELSE (4522)
  else
    // IF TOTAL_MATCH_PRES THEN (4523)
    if (1 & (bitToFixed (getBIT (8, mTOTAL_MATCH_PRES))))
      // NEW_NODE_PTR = PRESENT_NODE_PTR; (4524)
      {
        descriptor_t *bitRHS = getBIT (16, mPRESENT_NODE_PTR);
        putBIT (16, mNEW_NODE_PTR, bitRHS);
        bitRHS->inUse = 0;
      }
  // IF TOTAL_MATCH_PREV THEN (4525)
  if (1 & (bitToFixed (getBIT (8, mTOTAL_MATCH_PREV))))
    // DO; (4526)
    {
    rs2:;
      // HALMAT_PTR,HALMAT_NODE_START = PREVIOUS_HALMAT; (4527)
      {
        descriptor_t *bitRHS = getBIT (16, mPREVIOUS_HALMAT);
        putBIT (16, mHALMAT_PTR, bitRHS);
        putBIT (16, mHALMAT_NODE_START, bitRHS);
        bitRHS->inUse = 0;
      }
    es2:;
    } // End of DO block
  // ELSE (4528)
  else
    // DO; (4529)
    {
    rs3:;
      // CALL COLLECT_MATCHES(PREVIOUS_HALMAT,PNPARITY0#,PNPARITY1#); (4530)
      {
        putBITp (16, mCOLLECT_MATCHESxH_PTR, getBIT (16, mPREVIOUS_HALMAT));
        putBITp (16, mCOLLECT_MATCHESxNPARITY0p, getBIT (16, mPNPARITY0p));
        putBITp (16, mCOLLECT_MATCHESxNPARITY1p, getBIT (16, mPNPARITY1p));
        COLLECT_MATCHES (0);
      }
      // NODE(NEW_NODE_PTR) = PTR_TO_VAC(HALMAT_PTR); (4531)
      {
        int32_t numberRHS = (int32_t)((
            putBITp (16, mPTR_TO_VACxPTR, getBIT (16, mHALMAT_PTR)),
            PTR_TO_VAC (0)));
        putFIXED (mNODE + 4 * (COREHALFWORD (mNEW_NODE_PTR)), numberRHS);
      }
      // IF ~ TOTAL_MATCH_PRES THEN (4532)
      if (1 & (xNOT (BYTE0 (mTOTAL_MATCH_PRES))))
        // N_INX = N_INX + 1; (4533)
        {
          int32_t numberRHS = (int32_t)(xadd (COREHALFWORD (mN_INX), 1));
          descriptor_t *bitRHS;
          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
          putBIT (16, mN_INX, bitRHS);
          bitRHS->inUse = 0;
        }
    es3:;
    } // End of DO block
  // MULTIPLE_MATCH = TOTAL_MATCH_PREV & TOPTAG ; (4534)
  {
    int32_t numberRHS
        = (int32_t)(xAND (BYTE0 (mTOTAL_MATCH_PREV), BYTE0 (mTOPTAG)));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (8, mMULTIPLE_MATCH, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF TOTAL_MATCH_PREV THEN (4535)
  if (1 & (bitToFixed (getBIT (8, mTOTAL_MATCH_PREV))))
    // IF ~MULTIPLE_MATCH AND ~PREVIOUS_TWIN THEN (4536)
    if (1
        & (xAND (xNOT (BYTE0 (mMULTIPLE_MATCH)),
                 xNOT (BYTE0 (mPREVIOUS_TWIN)))))
      // CALL SET_HALMAT_FLAG(PREVIOUS_HALMAT); (4537)
      {
        putBITp (16, mSET_HALMAT_FLAGxPTR, getBIT (16, mPREVIOUS_HALMAT));
        SET_HALMAT_FLAG (0);
      }
  // IF TWIN_MATCH THEN (4538)
  if (1 & (bitToFixed (getBIT (8, mTWIN_MATCH))))
    // NODE_PTR = PREVIOUS_NODE_PTR; (4539)
    {
      descriptor_t *bitRHS = getBIT (16, mPREVIOUS_NODE_PTR);
      putBIT (16, mREARRANGE_HALMATxNODE_PTR, bitRHS);
      bitRHS->inUse = 0;
    }
  // ELSE (4540)
  else
    // NODE_PTR = NEW_NODE_PTR; (4541)
    {
      descriptor_t *bitRHS = getBIT (16, mNEW_NODE_PTR);
      putBIT (16, mREARRANGE_HALMATxNODE_PTR, bitRHS);
      bitRHS->inUse = 0;
    }
  // IF ~MULTIPLE_MATCH AND ~PREVIOUS_TWIN THEN (4542)
  if (1
      & (xAND (xNOT (BYTE0 (mMULTIPLE_MATCH)), xNOT (BYTE0 (mPREVIOUS_TWIN)))))
    // CALL SET_VAC_REF(REFERENCE(HALMAT_PTR),NODE_PTR,1); (4543)
    {
      putBITp (16, mSET_VAC_REFxHALMAT_PTR,
               (putBITp (16, mREFERENCExPTR, getBIT (16, mHALMAT_PTR)),
                REFERENCE (0)));
      putBITp (16, mSET_VAC_REFxPREVIOUS_HALMAT,
               getBIT (16, mREARRANGE_HALMATxNODE_PTR));
      putBITp (16, mSET_VAC_REFxTAG, fixedToBit (32, (int32_t)(1)));
      SET_VAC_REF (0);
    }
  // IF TWIN_MATCH THEN (4544)
  if (1 & (bitToFixed (getBIT (8, mTWIN_MATCH))))
    // CALL PUT_BFNC_TWIN(PREVIOUS_HALMAT); (4545)
    {
      putBITp (16, mPUT_BFNC_TWINxPTR, getBIT (16, mPREVIOUS_HALMAT));
      PUT_BFNC_TWIN (0);
    }
  // ELSE (4546)
  else
    // IF ~PREVIOUS_TWIN THEN (4547)
    if (1 & (xNOT (BYTE0 (mPREVIOUS_TWIN))))
      // IF TOPTAG THEN (4548)
      if (1 & (bitToFixed (getBIT (8, mTOPTAG))))
        // CALL SET_HALMAT_FLAG(PREVIOUS_HALMAT); (4549)
        {
          putBITp (16, mSET_HALMAT_FLAGxPTR, getBIT (16, mPREVIOUS_HALMAT));
          SET_HALMAT_FLAG (0);
        }
  // HP = HALMAT_PTR; (4550)
  {
    descriptor_t *bitRHS = getBIT (16, mHALMAT_PTR);
    putBIT (16, mHP, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF WATCH THEN (4551)
  if (1 & (bitToFixed (getBIT (8, mWATCH))))
    // IF ~MULTIPLE_MATCH THEN (4552)
    if (1 & (xNOT (BYTE0 (mMULTIPLE_MATCH))))
      // CALL PRINT_SENTENCE(HALMAT_NODE_START); (4553)
      {
        putBITp (16, mPRINT_SENTENCExPTR, getBIT (16, mHALMAT_NODE_START));
        PRINT_SENTENCE (0);
      }
  // IF LOOP_PULL THEN (4554)
  if (1 & (bitToFixed (getBIT (8, mREARRANGE_HALMATxLOOP_PULL))))
    // DO; (4555)
    {
    rs4:;
      // LOOP_PULL = FALSE; (4556)
      {
        int32_t numberRHS = (int32_t)(0);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (8, mREARRANGE_HALMATxLOOP_PULL, bitRHS);
        bitRHS->inUse = 0;
      }
      // RETURN; (4557)
      {
        reentryGuard = 0;
        return 0;
      }
    es4:;
    } // End of DO block
  // FORWARD = TRUE; (4558)
  {
    int32_t numberRHS = (int32_t)(1);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (8, mFORWARD, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF TOTAL_MATCH_PRES THEN (4559)
  if (1 & (bitToFixed (getBIT (8, mTOTAL_MATCH_PRES))))
    // HALMAT_PTR = PRESENT_HALMAT; (4560)
    {
      descriptor_t *bitRHS = getBIT (16, mPRESENT_HALMAT);
      putBIT (16, mHALMAT_PTR, bitRHS);
      bitRHS->inUse = 0;
    }
  // ELSE (4561)
  else
    // DO; (4562)
    {
    rs5:;
      // CALL COLLECT_MATCHES(PRESENT_HALMAT,FNPARITY0#,FNPARITY1#); (4563)
      {
        putBITp (16, mCOLLECT_MATCHESxH_PTR, getBIT (16, mPRESENT_HALMAT));
        putBITp (16, mCOLLECT_MATCHESxNPARITY0p, getBIT (16, mFNPARITY0p));
        putBITp (16, mCOLLECT_MATCHESxNPARITY1p, getBIT (16, mFNPARITY1p));
        COLLECT_MATCHES (0);
      }
    es5:;
    } // End of DO block
  // TAG_BIT_TEMP = TAG_BIT & OPR(HALMAT_PTR); (4564)
  {
    int32_t numberRHS
        = (int32_t)(xAND (getFIXED (mTAG_BIT),
                          getFIXED (mOPR + 4 * COREHALFWORD (mHALMAT_PTR))));
    putFIXED (mREARRANGE_HALMATxTAG_BIT_TEMP, numberRHS);
  }
  // CALL PUT_NOP(HALMAT_PTR); (4565)
  {
    putBITp (16, mPUT_NOPxPTR, getBIT (16, mHALMAT_PTR));
    PUT_NOP (0);
  }
  // TEMP = REFERENCE(HALMAT_PTR); (4566)
  {
    descriptor_t *bitRHS
        = (putBITp (16, mREFERENCExPTR, getBIT (16, mHALMAT_PTR)),
           REFERENCE (0));
    putBIT (16, mREARRANGE_HALMATxTEMP, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF REVERSE THEN (4567)
  if (1 & (bitToFixed (getBIT (8, mREVERSE))))
    // DO; (4568)
    {
    rs6:;
      // IF FORWARD_UNMATCHED_PLUS | ~FORWARD_MATCHED_MINUS THEN (4569)
      if (1
          & (xOR (xGT (COREHALFWORD (mFNPARITY0p), COREHALFWORD (mMPARITY1p)),
                  xNOT (xGT (COREHALFWORD (mMPARITY0p), 0)))))
        // DO; (4570)
        {
        rs6s1:;
          // IF FORWARD_MATCHED_PLUS & FORWARD_MATCHED_MINUS THEN (4571)
          if (1
              & (xAND (xGT (COREHALFWORD (mMPARITY1p), 0),
                       xGT (COREHALFWORD (mMPARITY0p), 0))))
            // DO; (4572)
            {
            rs6s1s1:;
              // CALL SWITCH(TEMP,TEMP + 1); (4573)
              {
                putBITp (16, mSWITCHxORIG,
                         getBIT (16, mREARRANGE_HALMATxTEMP));
                putBITp (
                    16, mSWITCHxPTR,
                    fixedToBit (
                        32, (int32_t)(xadd (
                                COREHALFWORD (mREARRANGE_HALMATxTEMP), 1))));
                SWITCH (0);
              }
              // CALL SET_VAC_REF(TEMP + 1,NEW_NODE_PTR,1); (4574)
              {
                putBITp (
                    16, mSET_VAC_REFxHALMAT_PTR,
                    fixedToBit (
                        32, (int32_t)(xadd (
                                COREHALFWORD (mREARRANGE_HALMATxTEMP), 1))));
                putBITp (16, mSET_VAC_REFxPREVIOUS_HALMAT,
                         getBIT (16, mNEW_NODE_PTR));
                putBITp (16, mSET_VAC_REFxTAG, fixedToBit (32, (int32_t)(1)));
                SET_VAC_REF (0);
              }
              // OPR(TEMP - 1) = OPR(TEMP - 1) &  4294901775 |
              // SHL(REVERSE_OP,4); (4575)
              {
                int32_t numberRHS = (int32_t)(xOR (
                    xAND (getFIXED (
                              mOPR
                              + 4
                                    * xsubtract (
                                        COREHALFWORD (mREARRANGE_HALMATxTEMP),
                                        1)),
                          4294901775),
                    SHL (COREHALFWORD (mREVERSE_OP), 4)));
                putFIXED (
                    mOPR
                        + 4
                              * (xsubtract (
                                  COREHALFWORD (mREARRANGE_HALMATxTEMP), 1)),
                    numberRHS);
              }
            es6s1s1:;
            } // End of DO block
          // ELSE (4576)
          else
            // CALL SET_VAC_REF(TEMP,NEW_NODE_PTR,1); (4577)
            {
              putBITp (16, mSET_VAC_REFxHALMAT_PTR,
                       getBIT (16, mREARRANGE_HALMATxTEMP));
              putBITp (16, mSET_VAC_REFxPREVIOUS_HALMAT,
                       getBIT (16, mNEW_NODE_PTR));
              putBITp (16, mSET_VAC_REFxTAG, fixedToBit (32, (int32_t)(1)));
              SET_VAC_REF (0);
            }
        es6s1:;
        } // End of DO block
      // ELSE (4578)
      else
        // DO; (4579)
        {
        rs6s2:;
          // IF OPTYPE = SSPR THEN (4580)
          if (1 & (xEQ (COREHALFWORD (mOPTYPE), COREHALFWORD (mSSPR))))
            // DO; (4581)
            {
            rs6s2s1:;
              // OPR(HALMAT_PTR) =  154336; (4582)
              {
                int32_t numberRHS = (int32_t)(154336);
                putFIXED (mOPR + 4 * (COREHALFWORD (mHALMAT_PTR)), numberRHS);
              }
              // OPR(HALMAT_PTR + 1) = SHL(GET_LIT_ONE,16) |  81; (4583)
              {
                int32_t numberRHS = (int32_t)(xOR (
                    SHL (bitToFixed (GET_LIT_ONE (0)), 16), 81));
                putFIXED (mOPR + 4 * (xadd (COREHALFWORD (mHALMAT_PTR), 1)),
                          numberRHS);
              }
              // CALL SET_VAC_REF(HALMAT_PTR + 2,NEW_NODE_PTR,1,1); (4584)
              {
                putBITp (16, mSET_VAC_REFxHALMAT_PTR,
                         fixedToBit (32, (int32_t)(xadd (
                                             COREHALFWORD (mHALMAT_PTR), 2))));
                putBITp (16, mSET_VAC_REFxPREVIOUS_HALMAT,
                         getBIT (16, mNEW_NODE_PTR));
                putBITp (16, mSET_VAC_REFxTAG, fixedToBit (32, (int32_t)(1)));
                putBITp (8, mSET_VAC_REFxNOTYPE,
                         fixedToBit (32, (int32_t)(1)));
                SET_VAC_REF (0);
              }
            es6s2s1:;
            } // End of DO block
          // ELSE (4585)
          else
            // DO; (4586)
            {
            rs6s2s2:;
              // IF OPTYPE = SADD THEN (4587)
              if (1 & (xEQ (COREHALFWORD (mOPTYPE), COREHALFWORD (mSADD))))
                // OPR(HALMAT_PTR) =  88832; (4588)
                {
                  int32_t numberRHS = (int32_t)(88832);
                  putFIXED (mOPR + 4 * (COREHALFWORD (mHALMAT_PTR)),
                            numberRHS);
                }
              // ELSE (4589)
              else
                // IF OPTYPE = IADD THEN (4590)
                if (1 & (xEQ (COREHALFWORD (mOPTYPE), COREHALFWORD (mIADD))))
                  // OPR(HALMAT_PTR) =  93440; (4591)
                  {
                    int32_t numberRHS = (int32_t)(93440);
                    putFIXED (mOPR + 4 * (COREHALFWORD (mHALMAT_PTR)),
                              numberRHS);
                  }
                // ELSE (4592)
                else
                  // OPR(HALMAT_PTR) =  66624 | SHL(OPTYPE,4) &  61440 |
                  // TAG_BIT_TEMP; (4593)
                  {
                    int32_t numberRHS = (int32_t)(xOR (
                        xOR (66624,
                             xAND (SHL (COREHALFWORD (mOPTYPE), 4), 61440)),
                        getFIXED (mREARRANGE_HALMATxTAG_BIT_TEMP)));
                    putFIXED (mOPR + 4 * (COREHALFWORD (mHALMAT_PTR)),
                              numberRHS);
                  }
              // CALL SET_VAC_REF(HALMAT_PTR + 1,NEW_NODE_PTR,1,1); (4594)
              {
                putBITp (16, mSET_VAC_REFxHALMAT_PTR,
                         fixedToBit (32, (int32_t)(xadd (
                                             COREHALFWORD (mHALMAT_PTR), 1))));
                putBITp (16, mSET_VAC_REFxPREVIOUS_HALMAT,
                         getBIT (16, mNEW_NODE_PTR));
                putBITp (16, mSET_VAC_REFxTAG, fixedToBit (32, (int32_t)(1)));
                putBITp (8, mSET_VAC_REFxNOTYPE,
                         fixedToBit (32, (int32_t)(1)));
                SET_VAC_REF (0);
              }
            es6s2s2:;
            } // End of DO block
          // TEMP = HALMAT_PTR; (4595)
          {
            descriptor_t *bitRHS = getBIT (16, mHALMAT_PTR);
            putBIT (16, mREARRANGE_HALMATxTEMP, bitRHS);
            bitRHS->inUse = 0;
          }
        es6s2:;
        } // End of DO block
    es6:;
    } // End of DO block
  // ELSE (4596)
  else
    // DO; (4597)
    {
    rs7:;
      // CALL SET_VAC_REF(TEMP,NEW_NODE_PTR,1); (4598)
      {
        putBITp (16, mSET_VAC_REFxHALMAT_PTR,
                 getBIT (16, mREARRANGE_HALMATxTEMP));
        putBITp (16, mSET_VAC_REFxPREVIOUS_HALMAT, getBIT (16, mNEW_NODE_PTR));
        putBITp (16, mSET_VAC_REFxTAG, fixedToBit (32, (int32_t)(1)));
        SET_VAC_REF (0);
      }
    es7:;
    } // End of DO block
  // IF TEMP < (NODE(NODE_PTR) &  65535) THEN (4599)
  if (1
      & (xLT (COREHALFWORD (mREARRANGE_HALMATxTEMP),
              xAND (getFIXED (mNODE
                              + 4 * COREHALFWORD (mREARRANGE_HALMATxNODE_PTR)),
                    65535))))
    // DO; (4600)
    {
    rs8:;
      // HP = LAST_OP(HP); (4601)
      {
        int32_t numberRHS = (int32_t)((
            putBITp (16, mLAST_OPxPTR, getBIT (16, mHP)), LAST_OP (0)));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mHP, bitRHS);
        bitRHS->inUse = 0;
      }
      // HIGH = BOTTOM(HP,TEMP); (4602)
      {
        int32_t numberRHS = (int32_t)((
            putBITp (16, mBOTTOMxPTR, getBIT (16, mHP)),
            putBITp (16, mBOTTOMxORIG, getBIT (16, mREARRANGE_HALMATxTEMP)),
            BOTTOM (0)));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mREARRANGE_HALMATxHIGH, bitRHS);
        bitRHS->inUse = 0;
      }
      // CALL MOVE_LIMB(HALMAT_PTR,HIGH,HP + NO_OPERANDS(HP) + 1 - HIGH);
      // (4603)
      {
        putBITp (16, mMOVE_LIMBxLOW, getBIT (16, mHALMAT_PTR));
        putBITp (16, mMOVE_LIMBxHIGH, getBIT (16, mREARRANGE_HALMATxHIGH));
        putBITp (
            16, mMOVE_LIMBxBIG,
            fixedToBit (
                32, (int32_t)(xsubtract (
                        xadd (xadd (COREHALFWORD (mHP),
                                    bitToFixed ((putBITp (16, mNO_OPERANDSxPTR,
                                                          getBIT (16, mHP)),
                                                 NO_OPERANDS (0)))),
                              1),
                        COREHALFWORD (mREARRANGE_HALMATxHIGH)))));
        MOVE_LIMB (0);
      }
    es8:;
    } // End of DO block
  // IF WATCH THEN (4604)
  if (1 & (bitToFixed (getBIT (8, mWATCH))))
    // CALL PRINT_SENTENCE(HALMAT_NODE_START); (4605)
    {
      putBITp (16, mPRINT_SENTENCExPTR, getBIT (16, mHALMAT_NODE_START));
      PRINT_SENTENCE (0);
    }
  {
    reentryGuard = 0;
    return 0;
  }
}
