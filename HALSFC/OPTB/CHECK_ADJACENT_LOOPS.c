/*
  File CHECK_ADJACENT_LOOPS.c generated by XCOM-I, 2024-08-09 12:41:08.
*/

#include "runtimeC.h"

descriptor_t *
CHECK_ADJACENT_LOOPS (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (descriptor_t *)0;
    }
  reentryGuard = guardReentry (reentryGuard, "CHECK_ADJACENT_LOOPS");
  // IF C_TRACE THEN (2439)
  if (1 & (bitToFixed (getBIT (8, mC_TRACE))))
    // OUTPUT = 'CHECK_ADJACENT_LOOPS:  '||PTR||','||TAG; (2440)
    {
      descriptor_t *stringRHS;
      stringRHS = xsCAT (
          xsCAT (
              xsCAT (cToDescriptor (NULL, "CHECK_ADJACENT_LOOPS:  "),
                     bitToCharacter (getBIT (16, mCHECK_ADJACENT_LOOPSxPTR))),
              cToDescriptor (NULL, ",")),
          bitToCharacter (getBIT (8, mCHECK_ADJACENT_LOOPSxTAG)));
      OUTPUT (0, stringRHS);
      stringRHS->inUse = 0;
    }
  // IF PTR = 0 THEN (2441)
  if (1 & (xEQ (COREHALFWORD (mCHECK_ADJACENT_LOOPSxPTR), 0)))
    // RETURN FALSE; (2442)
    {
      reentryGuard = 0;
      return fixedToBit (32, (int32_t)(0));
    }
  // TEMP = NOP; (2443)
  {
    descriptor_t *bitRHS = getBIT (16, mNOP);
    putBIT (16, mCHECK_ADJACENT_LOOPSxTEMP, bitRHS);
    bitRHS->inUse = 0;
  }
  // DO WHILE TEMP <= EXTN | (TEMP = SMRK & CROSS_STATEMENTS); (2444)
  while (1
         & (xOR (xLE (COREHALFWORD (mCHECK_ADJACENT_LOOPSxTEMP),
                      COREHALFWORD (mEXTN)),
                 xAND (xEQ (COREHALFWORD (mCHECK_ADJACENT_LOOPSxTEMP),
                            COREHALFWORD (mSMRK)),
                       BYTE0 (mCROSS_STATEMENTS)))))
    {
      // IF TAG ~= 2 THEN (2445)
      if (1 & (xNEQ (BYTE0 (mCHECK_ADJACENT_LOOPSxTAG), 2)))
        // PTR = LAST_OP(PTR - 1); (2446)
        {
          int32_t numberRHS = (int32_t)((
              putBITp (
                  16, mLAST_OPxPTR,
                  fixedToBit (
                      32, (int32_t)(xsubtract (
                              COREHALFWORD (mCHECK_ADJACENT_LOOPSxPTR), 1)))),
              LAST_OP (0)));
          descriptor_t *bitRHS;
          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
          putBIT (16, mCHECK_ADJACENT_LOOPSxPTR, bitRHS);
          bitRHS->inUse = 0;
        }
      // ELSE (2447)
      else
        // PTR = LAST_OPERAND(PTR) + 1; (2448)
        {
          int32_t numberRHS = (int32_t)(xadd (
              bitToFixed ((putBITp (16, mLAST_OPERANDxPTR,
                                    getBIT (16, mCHECK_ADJACENT_LOOPSxPTR)),
                           LAST_OPERAND (0))),
              1));
          descriptor_t *bitRHS;
          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
          putBIT (16, mCHECK_ADJACENT_LOOPSxPTR, bitRHS);
          bitRHS->inUse = 0;
        }
      // TEMP = OPOP(PTR); (2449)
      {
        descriptor_t *bitRHS
            = (putBITp (16, mOPOPxPTR, getBIT (16, mCHECK_ADJACENT_LOOPSxPTR)),
               OPOP (0));
        putBIT (16, mCHECK_ADJACENT_LOOPSxTEMP, bitRHS);
        bitRHS->inUse = 0;
      }
    } // End of DO WHILE block
  // IF ~TAG THEN (2450)
  if (1 & (xNOT (BYTE0 (mCHECK_ADJACENT_LOOPSxTAG))))
    // TEMP = TEMP = DLPE; (2451)
    {
      int32_t numberRHS = (int32_t)(xEQ (
          COREHALFWORD (mCHECK_ADJACENT_LOOPSxTEMP), COREHALFWORD (mDLPE)));
      descriptor_t *bitRHS;
      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
      putBIT (16, mCHECK_ADJACENT_LOOPSxTEMP, bitRHS);
      bitRHS->inUse = 0;
    }
  // ELSE (2452)
  else
    // TEMP = TEMP = ADLP & ((OPR(PTR + 1) & VDLP_TAG) = 0); (2453)
    {
      int32_t numberRHS = (int32_t)(xAND (
          xEQ (COREHALFWORD (mCHECK_ADJACENT_LOOPSxTEMP),
               COREHALFWORD (mADLP)),
          xEQ (xAND (getFIXED (mOPR
                               + 4
                                     * xadd (COREHALFWORD (
                                                 mCHECK_ADJACENT_LOOPSxPTR),
                                             1)),
                     COREHALFWORD (mVDLP_TAG)),
               0)));
      descriptor_t *bitRHS;
      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
      putBIT (16, mCHECK_ADJACENT_LOOPSxTEMP, bitRHS);
      bitRHS->inUse = 0;
    }
  // TAG = 0; (2454)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (8, mCHECK_ADJACENT_LOOPSxTAG, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF C_TRACE THEN (2455)
  if (1 & (bitToFixed (getBIT (8, mC_TRACE))))
    // OUTPUT = '   RETURNS '||TEMP; (2456)
    {
      descriptor_t *stringRHS;
      stringRHS
          = xsCAT (cToDescriptor (NULL, "   RETURNS "),
                   bitToCharacter (getBIT (16, mCHECK_ADJACENT_LOOPSxTEMP)));
      OUTPUT (0, stringRHS);
      stringRHS->inUse = 0;
    }
  // RETURN TEMP; (2457)
  {
    reentryGuard = 0;
    return getBIT (16, mCHECK_ADJACENT_LOOPSxTEMP);
  }
}
