/*
  File COMPACTIFY.c generated by XCOM-I, 2024-08-09 12:40:16.
*/

#include "runtimeC.h"

int32_t
COMPACTIFY (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "COMPACTIFY");
  // IF LOWER_BOUND = 0 THEN (432)
  if (1 & (xEQ (getFIXED (mCOMPACTIFYxLOWER_BOUND), 0)))
    // LOWER_BOUND = FREEBASE; (433)
    {
      int32_t numberRHS = (int32_t)(FREEBASE ());
      putFIXED (mCOMPACTIFYxLOWER_BOUND, numberRHS);
    }
  // GO TO START; (434)
  goto START;
  {   // (0) CALL INLINE( 80, 2, 0, LOWER_BOUND);
    { /*
       * File:      patch0.c
       * For:       COMPACTIFY.c
       * Notes:     1. Page references are from IBM "ESA/390 Principles of
       *               Operation", SA22-7201-08, Ninth Edition, June 2003.
       *            2. Labels are of the form p%d_%d, where the 1st number
       *               indicates the leading patch number of the block, and
       *               the 2nd is the byte offset of the instruction within
       *               within the block.
       *            3. Known-problematic translations are marked with the
       *               string  "* * * F I X M E * * *" (without spaces).
       * History:   2024-07-18 RSB  Auto-generated by XCOM-I --guess=....
       *                            Inspected.
       */

      p0_0:;
  // (0)    CALL INLINE("50", 2, 0, LOWER_BOUND);
  address360B = (mCOMPACTIFYxLOWER_BOUND)&0xFFFFFF;
  // Type RX, p. 7-122:		ST	2,mCOMPACTIFYxLOWER_BOUND(0,0)
  detailedInlineBefore (0, "ST	2,mCOMPACTIFYxLOWER_BOUND(0,0)");
  COREWORD2 (address360B, GR[2]);
  detailedInlineAfter ();

p0_4:;
}
}
// MODE = 1; (436)
{
  int32_t numberRHS = (int32_t)(1);
  putFIXED (mCOMPACTIFYxMODE, numberRHS);
}
// START: (437)
START:
// UPPER_BOUND = FREELIMIT + 512; (438)
{
  int32_t numberRHS = (int32_t)(xadd (FREELIMIT (), 512));
  putFIXED (mCOMPACTIFYxUPPER_BOUND, numberRHS);
}
// _DX_TOTAL=DX_SIZE+TOTAL_RDESC; (439)
{
  int32_t numberRHS
      = (int32_t)(xadd (getFIXED (mDX_SIZE), getFIXED (mTOTAL_RDESC)));
  putFIXED (m_DX_TOTAL, numberRHS);
}
// IF _DX_TOTAL ~= _PREV_DX_TOTAL THEN (440)
if (1 & (xNEQ (getFIXED (m_DX_TOTAL), getFIXED (m_PREV_DX_TOTAL))))
  // DO; (441)
  {
  rs1:;
    // IF ACTUAL_DX_TOTAL>0 THEN (442)
    if (1 & (xGT (getFIXED (mCOMPACTIFYxACTUAL_DX_TOTAL), 0)))
      // CALL MONITOR(7,ADDR(DX),SHL(ACTUAL_DX_TOTAL,2)); (443)
      MONITOR7 (ADDR ("DX", 0x80000000, NULL, 0),
                SHL (getFIXED (mCOMPACTIFYxACTUAL_DX_TOTAL), 2));
    // I=MONITOR(21); (444)
    {
      int32_t numberRHS = (int32_t)(MONITOR21 ());
      putFIXED (mCOMPACTIFYxI, numberRHS);
    }
    // J=SHL(_DX_TOTAL+1,2); (445)
    {
      int32_t numberRHS = (int32_t)(SHL (xadd (getFIXED (m_DX_TOTAL), 1), 2));
      putFIXED (mCOMPACTIFYxJ, numberRHS);
    }
    // IF I>J THEN (446)
    if (1 & (xGT (getFIXED (mCOMPACTIFYxI), getFIXED (mCOMPACTIFYxJ))))
      // I=J; (447)
      {
        int32_t numberRHS = (int32_t)(getFIXED (mCOMPACTIFYxJ));
        putFIXED (mCOMPACTIFYxI, numberRHS);
      }
    // ACTUAL_DX_TOTAL=SHR(I,2); (448)
    {
      int32_t numberRHS = (int32_t)(SHR (getFIXED (mCOMPACTIFYxI), 2));
      putFIXED (mCOMPACTIFYxACTUAL_DX_TOTAL, numberRHS);
    }
    // IF MONITOR(6,ADDR(DX),I) THEN (449)
    if (1
        & (MONITOR6 (ADDR ("DX", 0x80000000, NULL, 0),
                     getFIXED (mCOMPACTIFYxI))))
      // DO; (450)
      {
      rs1s1:;
        // OUTPUT='BI006 SEVERITY 3  BUG IN COMPACTIFY***  ABORTING'; (451)
        {
          descriptor_t *stringRHS;
          stringRHS = cToDescriptor (
              NULL, "BI006 SEVERITY 3  BUG IN COMPACTIFY***  ABORTING");
          OUTPUT (0, stringRHS);
          stringRHS->inUse = 0;
        }
        // CALL EXIT; (452)
        EXIT ();
      es1s1:;
      } // End of DO block
    // _PREV_DX_TOTAL=_DX_TOTAL; (453)
    {
      int32_t numberRHS = (int32_t)(getFIXED (m_DX_TOTAL));
      putFIXED (m_PREV_DX_TOTAL, numberRHS);
    }
  es1:;
  } // End of DO block
// DO TRIED = 0 TO 1; (454)
{
  int32_t from8, to8, by8;
  from8 = 0;
  to8 = 1;
  by8 = 1;
  for (putBIT (1, mCOMPACTIFYxTRIED, fixedToBit (1, from8));
       bitToFixed (getBIT (1, mCOMPACTIFYxTRIED)) <= to8; putBIT (
           1, mCOMPACTIFYxTRIED,
           fixedToBit (1, bitToFixed (getBIT (1, mCOMPACTIFYxTRIED)) + by8)))
    {
      // IF FORCE_MAJOR THEN (455)
      if (1 & (bitToFixed (getBIT (1, mFORCE_MAJOR))))
        // DO; (456)
        {
        rs2s1:;
          // FORCE_MAJOR=_FALSE; (457)
          {
            int32_t numberRHS = (int32_t)(0);
            descriptor_t *bitRHS;
            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
            putBIT (1, mFORCE_MAJOR, bitRHS);
            bitRHS->inUse = 0;
          }
          // LOWER_BOUND=FREEBASE; (458)
          {
            int32_t numberRHS = (int32_t)(FREEBASE ());
            putFIXED (mCOMPACTIFYxLOWER_BOUND, numberRHS);
          }
          // TRIED=1; (459)
          {
            int32_t numberRHS = (int32_t)(1);
            descriptor_t *bitRHS;
            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
            putBIT (1, mCOMPACTIFYxTRIED, bitRHS);
            bitRHS->inUse = 0;
          }
        es2s1:;
        } // End of DO block
      // COMPACTIFIES(TRIED) = COMPACTIFIES(TRIED) + 1; (460)
      {
        int32_t numberRHS = (int32_t)(xadd (
            COREHALFWORD (mCOMPACTIFIES + 2 * BYTE0 (mCOMPACTIFYxTRIED)), 1));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mCOMPACTIFIES + 2 * (BYTE0 (mCOMPACTIFYxTRIED)), bitRHS);
        bitRHS->inUse = 0;
      }
      // ND = -1; (461)
      {
        int32_t numberRHS = (int32_t)(-1);
        putFIXED (mCOMPACTIFYxND, numberRHS);
      }
      // DO J = 0 TO 6 BY 2; (462)
      {
        int32_t from9, to9, by9;
        from9 = 0;
        to9 = 6;
        by9 = 2;
        for (putFIXED (mCOMPACTIFYxJ, from9); getFIXED (mCOMPACTIFYxJ) <= to9;
             putFIXED (mCOMPACTIFYxJ, getFIXED (mCOMPACTIFYxJ) + by9))
          {
            // K = DESCRIPTOR_DESCRIPTOR(J); (463)
            {
              int32_t numberRHS = (int32_t)(getFIXED (
                  mDESCRIPTOR_DESCRIPTOR + 4 * getFIXED (mCOMPACTIFYxJ)));
              putFIXED (mCOMPACTIFYxK, numberRHS);
            }
            // DO I = K TO K + DESCRIPTOR_DESCRIPTOR(J + 1) - 1 BY 4; (464)
            {
              int32_t from10, to10, by10;
              from10 = getFIXED (mCOMPACTIFYxK);
              to10 = xsubtract (
                  xadd (getFIXED (mCOMPACTIFYxK),
                        getFIXED (mDESCRIPTOR_DESCRIPTOR
                                  + 4 * xadd (getFIXED (mCOMPACTIFYxJ), 1))),
                  1);
              by10 = 4;
              for (putFIXED (mCOMPACTIFYxI, from10);
                   getFIXED (mCOMPACTIFYxI) <= to10;
                   putFIXED (mCOMPACTIFYxI, getFIXED (mCOMPACTIFYxI) + by10))
                {
                  // CALL ADD_DESC(I); (465)
                  {
                    putFIXED (mCOMPACTIFYxADD_DESCxI,
                              getFIXED (mCOMPACTIFYxI));
                    COMPACTIFYxADD_DESC (0);
                  }
                }
            } // End of DO for-loop block
          }
      } // End of DO for-loop block
      // L=FIRSTRECORD; (466)
      {
        int32_t numberRHS = (int32_t)(getFIXED (mFIRSTRECORD));
        putFIXED (mCOMPACTIFYxL, numberRHS);
      }
      // DO WHILE L ~= 0; (467)
      while (1 & (xNEQ (getFIXED (mCOMPACTIFYxL), 0)))
        {
          // IF COREHALFWORD ( L + 6 ) > 0 THEN (468)
          if (1 & (xGT (COREHALFWORD (xadd (getFIXED (mCOMPACTIFYxL), 6)), 0)))
            // IF COREWORD(L+12) > 0 THEN (469)
            if (1 & (xGT (COREWORD (xadd (getFIXED (mCOMPACTIFYxL), 12)), 0)))
              // DO; (470)
              {
              rs2s3s1:;
                // DP=_DOPE_POINTER(L); (471)
                {
                  int32_t numberRHS
                      = (int32_t)(COREWORD (getFIXED (mCOMPACTIFYxL)));
                  putFIXED (mCOMPACTIFYxDP, numberRHS);
                }
                // DW=_DOPE_WIDTH(L); (472)
                {
                  int32_t numberRHS = (int32_t)(COREHALFWORD (
                      xadd (getFIXED (mCOMPACTIFYxL), 4)));
                  putFIXED (mCOMPACTIFYxDW, numberRHS);
                }
                // DO J=DP TO DP+DW*(_DOPE_USED(L)-1) BY DW; (473)
                {
                  int32_t from11, to11, by11;
                  from11 = getFIXED (mCOMPACTIFYxDP);
                  to11 = xadd (
                      getFIXED (mCOMPACTIFYxDP),
                      xmultiply (getFIXED (mCOMPACTIFYxDW),
                                 xsubtract (COREWORD (xadd (
                                                getFIXED (mCOMPACTIFYxL), 12)),
                                            1)));
                  by11 = getFIXED (mCOMPACTIFYxDW);
                  for (putFIXED (mCOMPACTIFYxJ, from11);
                       getFIXED (mCOMPACTIFYxJ) <= to11; putFIXED (
                           mCOMPACTIFYxJ, getFIXED (mCOMPACTIFYxJ) + by11))
                    {
                      // DO K=J TO J+4*(_DOPE_#DESCRIPTORS(L)-1) BY 4; (474)
                      {
                        int32_t from12, to12, by12;
                        from12 = getFIXED (mCOMPACTIFYxJ);
                        to12 = xadd (
                            getFIXED (mCOMPACTIFYxJ),
                            xmultiply (
                                4,
                                xsubtract (COREHALFWORD (xadd (
                                               getFIXED (mCOMPACTIFYxL), 6)),
                                           1)));
                        by12 = 4;
                        for (putFIXED (mCOMPACTIFYxK, from12);
                             getFIXED (mCOMPACTIFYxK) <= to12;
                             putFIXED (mCOMPACTIFYxK,
                                       getFIXED (mCOMPACTIFYxK) + by12))
                          {
                            // CALL ADD_DESC(K); (475)
                            {
                              putFIXED (mCOMPACTIFYxADD_DESCxI,
                                        getFIXED (mCOMPACTIFYxK));
                              COMPACTIFYxADD_DESC (0);
                            }
                          }
                      } // End of DO for-loop block
                    }
                } // End of DO for-loop block
              es2s3s1:;
              } // End of DO block
          // L=_DOPE_NEXT(L); (476)
          {
            int32_t numberRHS
                = (int32_t)(COREWORD (xadd (getFIXED (mCOMPACTIFYxL), 16)));
            putFIXED (mCOMPACTIFYxL, numberRHS);
          }
        } // End of DO WHILE block
      // FREEPOINT = LOWER_BOUND; (477)
      {
        int32_t numberRHS = (int32_t)(getFIXED (mCOMPACTIFYxLOWER_BOUND));
        FREEPOINT2 (numberRHS);
      }
      // IF ND >= 0 THEN (478)
      if (1 & (xGE (getFIXED (mCOMPACTIFYxND), 0)))
        // DO; (479)
        {
        rs2s4:;
          // K = SHR(ND+1,1); (480)
          {
            int32_t numberRHS
                = (int32_t)(SHR (xadd (getFIXED (mCOMPACTIFYxND), 1), 1));
            putFIXED (mCOMPACTIFYxK, numberRHS);
          }
          // DO WHILE K > 0; (481)
          while (1 & (xGT (getFIXED (mCOMPACTIFYxK), 0)))
            {
              // DO J = 0 TO ND-K; (482)
              {
                int32_t from13, to13, by13;
                from13 = 0;
                to13 = xsubtract (getFIXED (mCOMPACTIFYxND),
                                  getFIXED (mCOMPACTIFYxK));
                by13 = 1;
                for (putFIXED (mCOMPACTIFYxJ, from13);
                     getFIXED (mCOMPACTIFYxJ) <= to13;
                     putFIXED (mCOMPACTIFYxJ, getFIXED (mCOMPACTIFYxJ) + by13))
                  {
                    // I = J; (483)
                    {
                      int32_t numberRHS = (int32_t)(getFIXED (mCOMPACTIFYxJ));
                      putFIXED (mCOMPACTIFYxI, numberRHS);
                    }
                    // DO WHILE (COREWORD(DX(I)) & MASK) > (COREWORD(DX(I+K)) &
                    // MASK); (484)
                    while (1
                           & (xGT (
                               xAND (COREWORD (getFIXED (
                                         getFIXED (mDX)
                                         + 4 * getFIXED (mCOMPACTIFYxI))),
                                     getFIXED (mCOMPACTIFYxMASK)),
                               xAND (COREWORD (getFIXED (
                                         getFIXED (mDX)
                                         + 4
                                               * xadd (
                                                   getFIXED (mCOMPACTIFYxI),
                                                   getFIXED (mCOMPACTIFYxK)))),
                                     getFIXED (mCOMPACTIFYxMASK)))))
                      {
                        // L = DX(I); (485)
                        {
                          int32_t numberRHS = (int32_t)(getFIXED (
                              getFIXED (mDX) + 4 * getFIXED (mCOMPACTIFYxI)));
                          putFIXED (mCOMPACTIFYxL, numberRHS);
                        }
                        // DX(I) = DX(I+K); (486)
                        {
                          int32_t numberRHS = (int32_t)(getFIXED (
                              getFIXED (mDX)
                              + 4
                                    * xadd (getFIXED (mCOMPACTIFYxI),
                                            getFIXED (mCOMPACTIFYxK))));
                          putFIXED (getFIXED (mDX)
                                        + 4 * (getFIXED (mCOMPACTIFYxI)),
                                    numberRHS);
                        }
                        // DX(I+K) = L; (487)
                        {
                          int32_t numberRHS
                              = (int32_t)(getFIXED (mCOMPACTIFYxL));
                          putFIXED (
                              getFIXED (mDX)
                                  + 4
                                        * (xadd (getFIXED (mCOMPACTIFYxI),
                                                 getFIXED (mCOMPACTIFYxK))),
                              numberRHS);
                        }
                        // I = I - K; (488)
                        {
                          int32_t numberRHS = (int32_t)(xsubtract (
                              getFIXED (mCOMPACTIFYxI),
                              getFIXED (mCOMPACTIFYxK)));
                          putFIXED (mCOMPACTIFYxI, numberRHS);
                        }
                        // IF I < 0 THEN (489)
                        if (1 & (xLT (getFIXED (mCOMPACTIFYxI), 0)))
                          // ESCAPE; (490)
                          break;
                      } // End of DO WHILE block
                  }
              } // End of DO for-loop block
              // K = SHR(K,1); (491)
              {
                int32_t numberRHS
                    = (int32_t)(SHR (getFIXED (mCOMPACTIFYxK), 1));
                putFIXED (mCOMPACTIFYxK, numberRHS);
              }
            } // End of DO WHILE block
          // TC, DELTA = 0; (492)
          {
            int32_t numberRHS = (int32_t)(0);
            putFIXED (mCOMPACTIFYxTC, numberRHS);
            putFIXED (mCOMPACTIFYxDELTA, numberRHS);
          }
          // BC = 1; (493)
          {
            int32_t numberRHS = (int32_t)(1);
            putFIXED (mCOMPACTIFYxBC, numberRHS);
          }
          // DO I = 0 TO ND; (494)
          {
            int32_t from14, to14, by14;
            from14 = 0;
            to14 = getFIXED (mCOMPACTIFYxND);
            by14 = 1;
            for (putFIXED (mCOMPACTIFYxI, from14);
                 getFIXED (mCOMPACTIFYxI) <= to14;
                 putFIXED (mCOMPACTIFYxI, getFIXED (mCOMPACTIFYxI) + by14))
              {
                // J = COREWORD(DX(I)); (495)
                {
                  int32_t numberRHS = (int32_t)(COREWORD (getFIXED (
                      getFIXED (mDX) + 4 * getFIXED (mCOMPACTIFYxI))));
                  putFIXED (mCOMPACTIFYxJ, numberRHS);
                }
                // IF (J & MASK) - 1 > TC THEN (496)
                if (1
                    & (xGT (xsubtract (xAND (getFIXED (mCOMPACTIFYxJ),
                                             getFIXED (mCOMPACTIFYxMASK)),
                                       1),
                            getFIXED (mCOMPACTIFYxTC))))
                  // DO; (497)
                  {
                  rs2s4s2s1:;
                    // IF DELTA > 0 THEN (498)
                    if (1 & (xGT (getFIXED (mCOMPACTIFYxDELTA), 0)))
                      // DO K = BC TO TC; (499)
                      {
                        int32_t from15, to15, by15;
                        from15 = getFIXED (mCOMPACTIFYxBC);
                        to15 = getFIXED (mCOMPACTIFYxTC);
                        by15 = 1;
                        for (putFIXED (mCOMPACTIFYxK, from15);
                             getFIXED (mCOMPACTIFYxK) <= to15;
                             putFIXED (mCOMPACTIFYxK,
                                       getFIXED (mCOMPACTIFYxK) + by15))
                          {
                            // COREBYTE(K-DELTA) = COREBYTE(K); (500)
                            {
                              int32_t numberRHS = (int32_t)(COREBYTE (
                                  getFIXED (mCOMPACTIFYxK)));
                              COREBYTE2 (
                                  xsubtract (getFIXED (mCOMPACTIFYxK),
                                             getFIXED (mCOMPACTIFYxDELTA)),
                                  numberRHS);
                            }
                          }
                      } // End of DO for-loop block
                    // FREEPOINT = FREEPOINT + TC - BC + 1; (501)
                    {
                      int32_t numberRHS = (int32_t)(xadd (
                          xsubtract (
                              xadd (FREEPOINT (), getFIXED (mCOMPACTIFYxTC)),
                              getFIXED (mCOMPACTIFYxBC)),
                          1));
                      FREEPOINT2 (numberRHS);
                    }
                    // BC = J & MASK; (502)
                    {
                      int32_t numberRHS
                          = (int32_t)(xAND (getFIXED (mCOMPACTIFYxJ),
                                            getFIXED (mCOMPACTIFYxMASK)));
                      putFIXED (mCOMPACTIFYxBC, numberRHS);
                    }
                    // DELTA = BC - FREEPOINT; (503)
                    {
                      int32_t numberRHS = (int32_t)(xsubtract (
                          getFIXED (mCOMPACTIFYxBC), FREEPOINT ()));
                      putFIXED (mCOMPACTIFYxDELTA, numberRHS);
                    }
                  es2s4s2s1:;
                  } // End of DO block
                // COREWORD (DX(I)) = J - DELTA; (504)
                {
                  int32_t numberRHS = (int32_t)(xsubtract (
                      getFIXED (mCOMPACTIFYxJ), getFIXED (mCOMPACTIFYxDELTA)));
                  COREWORD2 (
                      getFIXED (getFIXED (mDX) + 4 * getFIXED (mCOMPACTIFYxI)),
                      numberRHS);
                }
                // L = (J & MASK) + SHR(J, 24); (505)
                {
                  int32_t numberRHS
                      = (int32_t)(xadd (xAND (getFIXED (mCOMPACTIFYxJ),
                                              getFIXED (mCOMPACTIFYxMASK)),
                                        SHR (getFIXED (mCOMPACTIFYxJ), 24)));
                  putFIXED (mCOMPACTIFYxL, numberRHS);
                }
                // IF TC < L THEN (506)
                if (1
                    & (xLT (getFIXED (mCOMPACTIFYxTC),
                            getFIXED (mCOMPACTIFYxL))))
                  // TC = L; (507)
                  {
                    int32_t numberRHS = (int32_t)(getFIXED (mCOMPACTIFYxL));
                    putFIXED (mCOMPACTIFYxTC, numberRHS);
                  }
              }
          } // End of DO for-loop block
          // DO K = BC TO TC; (508)
          {
            int32_t from16, to16, by16;
            from16 = getFIXED (mCOMPACTIFYxBC);
            to16 = getFIXED (mCOMPACTIFYxTC);
            by16 = 1;
            for (putFIXED (mCOMPACTIFYxK, from16);
                 getFIXED (mCOMPACTIFYxK) <= to16;
                 putFIXED (mCOMPACTIFYxK, getFIXED (mCOMPACTIFYxK) + by16))
              {
                // COREBYTE(K-DELTA) = COREBYTE(K); (509)
                {
                  int32_t numberRHS
                      = (int32_t)(COREBYTE (getFIXED (mCOMPACTIFYxK)));
                  COREBYTE2 (xsubtract (getFIXED (mCOMPACTIFYxK),
                                        getFIXED (mCOMPACTIFYxDELTA)),
                             numberRHS);
                }
              }
          } // End of DO for-loop block
          // FREEPOINT = FREEPOINT + TC - BC + 1; (510)
          {
            int32_t numberRHS = (int32_t)(xadd (
                xsubtract (xadd (FREEPOINT (), getFIXED (mCOMPACTIFYxTC)),
                           getFIXED (mCOMPACTIFYxBC)),
                1));
            FREEPOINT2 (numberRHS);
          }
        es2s4:;
        } // End of DO block
      // IF MODE THEN (511)
      if (1 & (getFIXED (mCOMPACTIFYxMODE)))
        // DO; (512)
        {
        rs2s5:;
          // IF ACTUAL_DX_TOTAL>0 THEN (513)
          if (1 & (xGT (getFIXED (mCOMPACTIFYxACTUAL_DX_TOTAL), 0)))
            // CALL MONITOR(7, ADDR(DX), SHL(ACTUAL_DX_TOTAL , 2)); (514)
            MONITOR7 (ADDR ("DX", 0x80000000, NULL, 0),
                      SHL (getFIXED (mCOMPACTIFYxACTUAL_DX_TOTAL), 2));
          // I = ADDR(DESCRIPTOR_DESCRIPTOR); (515)
          {
            int32_t numberRHS
                = (int32_t)(ADDR (NULL, 0, "DESCRIPTOR_DESCRIPTOR", 0));
            putFIXED (mCOMPACTIFYxI, numberRHS);
          }
          // K=FIRSTRECORD; (516)
          {
            int32_t numberRHS = (int32_t)(getFIXED (mFIRSTRECORD));
            putFIXED (mCOMPACTIFYxK, numberRHS);
          }
          // IF K ~= 0 THEN (517)
          if (1 & (xNEQ (getFIXED (mCOMPACTIFYxK), 0)))
            // K=K| 2147483648; (518)
            {
              int32_t numberRHS
                  = (int32_t)(xOR (getFIXED (mCOMPACTIFYxK), 2147483648));
              putFIXED (mCOMPACTIFYxK, numberRHS);
            }
          {   // (1) CALL INLINE( 88, 0, 0, LOWER_BOUND);
            { /*
               * File:      patch1.c
               * For:       COMPACTIFY.c
               * Notes:     1. Page references are from IBM "ESA/390 Principles
               * of Operation", SA22-7201-08, Ninth Edition, June 2003.
               *            2. Labels are of the form p%d_%d, where the 1st
               * number indicates the leading patch number of the block, and
               *               the 2nd is the byte offset of the instruction
               * within within the block.
               *            3. Known-problematic translations are marked with
               * the string  "* * * F I X M E * * *" (without spaces). History:
               * 2024-07-18 RSB  Auto-generated by XCOM-I --guess=....
               *                            Inspected.
               */

              p1_0:;
          // (1)          CALL INLINE("58", 0, 0, LOWER_BOUND);
          address360B = (mCOMPACTIFYxLOWER_BOUND)&0xFFFFFF;
          // Type RX, p. 7-7:		L	0,mCOMPACTIFYxLOWER_BOUND(0,0)
          detailedInlineBefore (1, "L	0,mCOMPACTIFYxLOWER_BOUND(0,0)");
          GR[0] = COREWORD (address360B);
          detailedInlineAfter ();

        p1_4:;
          // (2)          CALL INLINE("58", 2, 0, I);
          address360B = (mCOMPACTIFYxI)&0xFFFFFF;
          // Type RX, p. 7-7:		L	2,mCOMPACTIFYxI(0,0)
          detailedInlineBefore (2, "L	2,mCOMPACTIFYxI(0,0)");
          GR[2] = COREWORD (address360B);
          detailedInlineAfter ();

        p1_8:;
          // (3)          CALL INLINE("58", 4, 0, UPPER_BOUND);  /* CORETOP
          // PASSED IN R4 */
          address360B = (mCOMPACTIFYxUPPER_BOUND)&0xFFFFFF;
          // Type RX, p. 7-7:		L	4,mCOMPACTIFYxUPPER_BOUND(0,0)
          detailedInlineBefore (3, "L	4,mCOMPACTIFYxUPPER_BOUND(0,0)");
          GR[4] = COREWORD (address360B);
          detailedInlineAfter ();

        p1_12:;
          // (4)          CALL INLINE("58", 5, 0, K);
          address360B = (mCOMPACTIFYxK)&0xFFFFFF;
          // Type RX, p. 7-7:		L	5,mCOMPACTIFYxK(0,0)
          detailedInlineBefore (4, "L	5,mCOMPACTIFYxK(0,0)");
          GR[5] = COREWORD (address360B);
          detailedInlineAfter ();

        p1_16:;
        }
    }; // (2) CALL INLINE( 88, 2, 0, I);
  ;    // (3) CALL INLINE( 88, 4, 0, UPPER_BOUND);
  ;    // (4) CALL INLINE( 88, 5, 0, K);
  // RETURN FREEPOINT; (523)
  {
    reentryGuard = 0;
    return FREEPOINT ();
  }
es2s5:;
} // End of DO block
// _LAST_COMPACTIFY_FOUND=FREELIMIT-FREEPOINT; (524)
{
  int32_t numberRHS = (int32_t)(xsubtract (FREELIMIT (), FREEPOINT ()));
  putFIXED (m_LAST_COMPACTIFY_FOUND, numberRHS);
}
// IF (SHL(FREELIMIT-FREEPOINT, 4) < FREELIMIT-FREEBASE) | FREELIMIT-FREEPOINT
// < FREESTRING_TRIGGER THEN (525)
if (1
    & (xOR (xLT (SHL (xsubtract (FREELIMIT (), FREEPOINT ()), 4),
                 xsubtract (FREELIMIT (), FREEBASE ())),
            xLT (xsubtract (FREELIMIT (), FREEPOINT ()),
                 getFIXED (mFREESTRING_TRIGGER)))))
  // DO; (526)
  {
  rs2s6:;
    // LOWER_BOUND = FREEBASE; (527)
    {
      int32_t numberRHS = (int32_t)(FREEBASE ());
      putFIXED (mCOMPACTIFYxLOWER_BOUND, numberRHS);
    }
  es2s6:;
  } // End of DO block
// ELSE (528)
else
  // DO; (529)
  {
  rs2s7:;
    // LOWER_BOUND = FREEPOINT; (530)
    {
      int32_t numberRHS = (int32_t)(FREEPOINT ());
      putFIXED (mCOMPACTIFYxLOWER_BOUND, numberRHS);
    }
    // RETURN ND; (531)
    {
      reentryGuard = 0;
      return getFIXED (mCOMPACTIFYxND);
    }
  es2s7:;
  } // End of DO block
}
} // End of DO for-loop block
// IF _LAST_COMPACTIFY_FOUND < FREESTRING_TRIGGER THEN (532)
if (1
    & (xLT (getFIXED (m_LAST_COMPACTIFY_FOUND),
            getFIXED (mFREESTRING_TRIGGER))))
  // DO; (533)
  {
  rs3:;
    // _IN_COMPACTIFY=_TRUE; (534)
    {
      int32_t numberRHS = (int32_t)(1);
      descriptor_t *bitRHS;
      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
      putBIT (1, m_IN_COMPACTIFY, bitRHS);
      bitRHS->inUse = 0;
    }
    // K=_SPACE_ROUND(FREESTRING_TARGET - _LAST_COMPACTIFY_FOUND); (535)
    {
      int32_t numberRHS = (int32_t)((
          putFIXED (m_SPACE_ROUNDxBYTES,
                    xsubtract (getFIXED (mFREESTRING_TARGET),
                               getFIXED (m_LAST_COMPACTIFY_FOUND))),
          _SPACE_ROUND (0)));
      putFIXED (mCOMPACTIFYxK, numberRHS);
    }
    // IF FREEBYTES < K THEN (536)
    if (1 & (xLT (getFIXED (mFREEBYTES), getFIXED (mCOMPACTIFYxK))))
      // CALL _TAKE_BACK(K-FREEBYTES); (537)
      {
        putFIXED (m_TAKE_BACKxNBYTES,
                  xsubtract (getFIXED (mCOMPACTIFYxK), getFIXED (mFREEBYTES)));
        _TAKE_BACK (0);
      }
    // IF FREEBYTES+_LAST_COMPACTIFY_FOUND < FREESTRING_MIN THEN (538)
    if (1
        & (xLT (
            xadd (getFIXED (mFREEBYTES), getFIXED (m_LAST_COMPACTIFY_FOUND)),
            getFIXED (mFREESTRING_MIN))))
      // DO; (539)
      {
      rs3s1:;
        // OUTPUT='BI007 SEVERITY 3 NOT ENOUGH SPACE AVAILABLE -- ' || 'TRY
        // LARGER REGION.'; (540)
        {
          descriptor_t *stringRHS;
          stringRHS = cToDescriptor (NULL, "BI007 SEVERITY 3 NOT ENOUGH SPACE "
                                           "AVAILABLE -- TRY LARGER REGION.");
          OUTPUT (0, stringRHS);
          stringRHS->inUse = 0;
        }
        // CALL EXIT; (541)
        EXIT ();
      es3s1:;
      } // End of DO block
    // IF K > FREEBYTES THEN (542)
    if (1 & (xGT (getFIXED (mCOMPACTIFYxK), getFIXED (mFREEBYTES))))
      // K=FREEBYTES; (543)
      {
        int32_t numberRHS = (int32_t)(getFIXED (mFREEBYTES));
        putFIXED (mCOMPACTIFYxK, numberRHS);
      }
    // CALL _RETURN_TO_FREESTRING(K); (544)
    {
      putFIXED (m_RETURN_TO_FREESTRINGxNBYTES, getFIXED (mCOMPACTIFYxK));
      _RETURN_TO_FREESTRING (0);
    }
    // _IN_COMPACTIFY=_FALSE; (545)
    {
      int32_t numberRHS = (int32_t)(0);
      descriptor_t *bitRHS;
      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
      putBIT (1, m_IN_COMPACTIFY, bitRHS);
      bitRHS->inUse = 0;
    }
  es3:;
  } // End of DO block
// _LAST_COMPACTIFY_FOUND=FREELIMIT-FREEPOINT; (546)
{
  int32_t numberRHS = (int32_t)(xsubtract (FREELIMIT (), FREEPOINT ()));
  putFIXED (m_LAST_COMPACTIFY_FOUND, numberRHS);
}
// IF _LAST_COMPACTIFY_FOUND < FREESTRING_MIN THEN (547)
if (1 & (xLT (getFIXED (m_LAST_COMPACTIFY_FOUND), getFIXED (mFREESTRING_MIN))))
  // DO; (548)
  {
  rs4:;
    // OUTPUT = 'BI008 SEVERITY 3 NOTICE FROM COMPACTIFY: ' || 'INSUFFICIENT
    // MEMORY FOR STRING STORAGE. JOB ABANDONED.'; (549)
    {
      descriptor_t *stringRHS;
      stringRHS = cToDescriptor (
          NULL, "BI008 SEVERITY 3 NOTICE FROM COMPACTIFY: INSUFFICIENT MEMORY "
                "FOR STRING STORAGE. JOB ABANDONED.");
      OUTPUT (0, stringRHS);
      stringRHS->inUse = 0;
    }
    // CALL EXIT; (550)
    EXIT ();
  es4:;
  } // End of DO block
// RETURN ND; (551)
{
  reentryGuard = 0;
  return getFIXED (mCOMPACTIFYxND);
}
}
