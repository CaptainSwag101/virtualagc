/*
  File PASS1xCLASS_0xCLASS_00.c generated by XCOM-I, 2024-08-08 04:32:08.
*/

#include "../AUXP/runtimeC.h"

int32_t
PASS1xCLASS_0xCLASS_00 (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "PASS1xCLASS_0xCLASS_00");
  // DO CASE HALRATOR &  15; (2105)
  {
  rs1:
    switch (xAND (COREHALFWORD (mHALRATOR), 15))
      {
      case 0:
        // DO FOR WORK1 = 1 TO HALRATOR_#RANDS; (2107)
        {
          int32_t from49, to49, by49;
          from49 = 1;
          to49 = bitToFixed (getBIT (8, mHALRATOR_pRANDS));
          by49 = 1;
          for (putFIXED (mWORK1, from49); getFIXED (mWORK1) <= to49;
               putFIXED (mWORK1, getFIXED (mWORK1) + by49))
            {
              // HALMAT(HALMAT_PTR + WORK1) = 1; (2107)
              {
                int32_t numberRHS = (int32_t)(1);
                putFIXED (mHALMAT
                              + 4
                                    * (xadd (COREHALFWORD (mHALMAT_PTR),
                                             getFIXED (mWORK1))),
                          numberRHS);
              }
            }
        } // End of DO for-loop block
        break;
      case 1:
        // DO; (2109)
        {
        rs1s2:;
          // CALL DECODE_HALRAND(1); (2109)
          {
            putBITp (16, mPASS1xDECODE_HALRANDxOP,
                     fixedToBit (32, (int32_t)(1)));
            PASS1xDECODE_HALRAND (0);
          }
          // IF HALRAND_QUALIFIER = VAC THEN (2110)
          if (1 & (xEQ (BYTE0 (mHALRAND_QUALIFIER), 3)))
            // CALL SET_RAND_NOOSE(1, 0, 1); (2111)
            {
              putBITp (16, mPASS1xSET_RAND_NOOSExRANDp,
                       fixedToBit (32, (int32_t)(1)));
              putBITp (8, mPASS1xSET_RAND_NOOSExVAL_CHANGE,
                       fixedToBit (32, (int32_t)(0)));
              putBITp (8, mPASS1xSET_RAND_NOOSExDO_NOT_DECODE,
                       fixedToBit (32, (int32_t)(1)));
              PASS1xSET_RAND_NOOSE (0);
            }
        es1s2:;
        } // End of DO block
        break;
      case 2:
        // DO; (2113)
        {
        rs1s3:;
          // IF (HALRATOR_TAG2 & RATOR_CSE_FLAG) ~= 0 THEN (2113)
          if (1 & (xNEQ (xAND (BYTE0 (mHALRATOR_TAG2), 8), 0)))
            // DO; (2114)
            {
            rs1s3s1:;
              // BLOCK_PRIME = ON; (2115)
              {
                int32_t numberRHS = (int32_t)(1);
                descriptor_t *bitRHS;
                bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                putBIT (1, mBLOCK_PRIME, bitRHS);
                bitRHS->inUse = 0;
              }
              // XREC_PTR = HALMAT_PTR; (2116)
              {
                descriptor_t *bitRHS = getBIT (16, mHALMAT_PTR);
                putBIT (16, mXREC_PTR, bitRHS);
                bitRHS->inUse = 0;
              }
              // GEN_CODE(HALMAT_PTR) = XREC_OPCODE; (2117)
              {
                int32_t numberRHS = (int32_t)(3);
                putBIT (8,
                        getFIXED (mWORK_VARS)
                            + 11 * (COREHALFWORD (mHALMAT_PTR)) + 10 + 1 * (0),
                        fixedToBit (8, numberRHS));
              }
              // CALL NEW_HALMAT_BLOCK(HALMAT_SIZE, FALSE); (2118)
              {
                putBITp (16, mNEW_HALMAT_BLOCKxSTART,
                         fixedToBit (32, (int32_t)(1800)));
                putBITp (1, mNEW_HALMAT_BLOCKxDO_PRINT,
                         fixedToBit (32, (int32_t)(0)));
                NEW_HALMAT_BLOCK (0);
              }
              // HALMAT_PTR = HALMAT_SIZE - (HALRATOR_#RANDS + 1); (2119)
              {
                int32_t numberRHS = (int32_t)(xsubtract (
                    1800, xadd (BYTE0 (mHALRATOR_pRANDS), 1)));
                descriptor_t *bitRHS;
                bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                putBIT (16, mHALMAT_PTR, bitRHS);
                bitRHS->inUse = 0;
              }
            es1s3s1:;
            } // End of DO block
          // ELSE (2120)
          else
            // DO; (2121)
            {
            rs1s3s2:;
              // IF HALRATOR_TAG1 THEN (2122)
              if (1 & (bitToFixed (getBIT (8, mHALRATOR_TAG1))))
                // DO; (2123)
                {
                rs1s3s2s1:;
                  // AUXMATING = OFF; (2124)
                  {
                    int32_t numberRHS = (int32_t)(0);
                    descriptor_t *bitRHS;
                    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                    putBIT (1, mAUXMATING, bitRHS);
                    bitRHS->inUse = 0;
                  }
                  // GEN_CODE(HALMAT_PTR) = AUXMAT_END_OPCODE; (2125)
                  {
                    int32_t numberRHS = (int32_t)(6);
                    putBIT (8,
                            getFIXED (mWORK_VARS)
                                + 11 * (COREHALFWORD (mHALMAT_PTR)) + 10
                                + 1 * (0),
                            fixedToBit (8, numberRHS));
                  }
                es1s3s2s1:;
                } // End of DO block
              // ELSE (2126)
              else
                // GEN_CODE(HALMAT_PTR) = XREC_OPCODE; (2127)
                {
                  int32_t numberRHS = (int32_t)(3);
                  putBIT (8,
                          getFIXED (mWORK_VARS)
                              + 11 * (COREHALFWORD (mHALMAT_PTR)) + 10
                              + 1 * (0),
                          fixedToBit (8, numberRHS));
                }
              // IF HALMAT_PTR > HALMAT_SIZE THEN (2128)
              if (1 & (xGT (COREHALFWORD (mHALMAT_PTR), 1800)))
                // XREC_PRIME_PTR = HALMAT_PTR; (2129)
                {
                  descriptor_t *bitRHS = getBIT (16, mHALMAT_PTR);
                  putBIT (16, mXREC_PRIME_PTR, bitRHS);
                  bitRHS->inUse = 0;
                }
              // ELSE (2130)
              else
                // XREC_PTR = HALMAT_PTR; (2131)
                {
                  descriptor_t *bitRHS = getBIT (16, mHALMAT_PTR);
                  putBIT (16, mXREC_PTR, bitRHS);
                  bitRHS->inUse = 0;
                }
              // THIS_HALMAT_BLOCK = OFF; (2132)
              {
                int32_t numberRHS = (int32_t)(0);
                descriptor_t *bitRHS;
                bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                putBIT (1, mPASS1xTHIS_HALMAT_BLOCK, bitRHS);
                bitRHS->inUse = 0;
              }
            es1s3s2:;
            } // End of DO block
        es1s3:;
        } // End of DO block
        break;
      case 3:
        // DO; (2134)
        {
        rs1s4:;
        // DECODE_MRK: (2134)
        DECODE_MRK:
          // IF HALRATOR_TAG1 ~= 0 THEN (2135)
          if (1 & (xNEQ (BYTE0 (mHALRATOR_TAG1), 0)))
            // DO; (2136)
            {
            rs1s4s1:;
              // THIS_HALMAT_BLOCK, AUXMATING = OFF; (2137)
              {
                int32_t numberRHS = (int32_t)(0);
                descriptor_t *bitRHS;
                bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                putBIT (1, mPASS1xTHIS_HALMAT_BLOCK, bitRHS);
                bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                putBIT (1, mAUXMATING, bitRHS);
                bitRHS->inUse = 0;
              }
              // GEN_CODE(HALMAT_PTR) = AUXMAT_END_OPCODE; (2138)
              {
                int32_t numberRHS = (int32_t)(6);
                putBIT (8,
                        getFIXED (mWORK_VARS)
                            + 11 * (COREHALFWORD (mHALMAT_PTR)) + 10 + 1 * (0),
                        fixedToBit (8, numberRHS));
              }
              // IF HALMAT_PTR >= HALMAT_SIZE THEN (2139)
              if (1 & (xGE (COREHALFWORD (mHALMAT_PTR), 1800)))
                // XREC_PRIME_PTR = HALMAT_PTR; (2140)
                {
                  descriptor_t *bitRHS = getBIT (16, mHALMAT_PTR);
                  putBIT (16, mXREC_PRIME_PTR, bitRHS);
                  bitRHS->inUse = 0;
                }
              // ELSE (2141)
              else
                // XREC_PTR = HALMAT_PTR; (2142)
                {
                  descriptor_t *bitRHS = getBIT (16, mHALMAT_PTR);
                  putBIT (16, mXREC_PTR, bitRHS);
                  bitRHS->inUse = 0;
                }
            es1s4s1:;
            } // End of DO block
          // ELSE (2143)
          else
            // DO; (2144)
            {
            rs1s4s2:;
              // CALL DECODE_HALRAND(1); (2145)
              {
                putBITp (16, mPASS1xDECODE_HALRANDxOP,
                         fixedToBit (32, (int32_t)(1)));
                PASS1xDECODE_HALRAND (0);
              }
              // CURRENT_STMT = HALRAND; (2146)
              {
                descriptor_t *bitRHS = getBIT (16, mHALRAND);
                putBIT (16, mCURRENT_STMT, bitRHS);
                bitRHS->inUse = 0;
              }
              // IF HALRAND_TAG1 ~= 0 THEN (2147)
              if (1 & (xNEQ (BYTE0 (mHALRAND_TAG1), 0)))
                // CALL SET_DEBUG_SWITCH(HALRAND_TAG1); (2148)
                {
                  putBITp (8, mPASS1xSET_DEBUG_SWITCHxSWITCH,
                           getBIT (8, mHALRAND_TAG1));
                  PASS1xSET_DEBUG_SWITCH (0);
                }
            es1s4s2:;
            } // End of DO block
        es1s4:;
        } // End of DO block
        break;
      case 4:
        // GO TO DECODE_MRK; (2150)
        goto DECODE_MRK;
        break;
      case 5:
          // ; (2151)
          ;
        break;
      case 6:
          // ; (2152)
          ;
        break;
      case 7:
        // CALL PUSH_CB_FRAME; (2153)
        PASS1xPUSH_CB_FRAME (0);
        break;
      case 8:
        // DO; (2154)
        {
        rs1s5:;
          // IF HALRATOR_TAG1 THEN (2154)
          if (1 & (bitToFixed (getBIT (8, mHALRATOR_TAG1))))
            // DO; (2155)
            {
            rs1s5s1:;
              // CALL POP_CASE_FRAME('LBL*'); (2156)
              {
                putCHARACTERp (mPASS1xPOP_CASE_FRAMExPOP_IND,
                               cToDescriptor (NULL, "LBL*"));
                PASS1xPOP_CASE_FRAME (0);
              }
              // CALL POP_CB_FRAME; (2157)
              PASS1xPOP_CB_FRAME (0);
            es1s5s1:;
            } // End of DO block
          // ELSE (2158)
          else
            // DO; (2159)
            {
            rs1s5s2:;
              // CALL DECODE_HALRAND(1); (2160)
              {
                putBITp (16, mPASS1xDECODE_HALRANDxOP,
                         fixedToBit (32, (int32_t)(1)));
                PASS1xDECODE_HALRAND (0);
              }
              // IF ((HALMAT(HALMAT_PTR - 2) &  65520) =  144) &
              // ((HALMAT(HALMAT_PTR - 2) &  4278190080) ~= 0) THEN (2161)
              if (1
                  & (xAND (
                      xEQ (xAND (getFIXED (
                                     mHALMAT
                                     + 4
                                           * xsubtract (
                                               COREHALFWORD (mHALMAT_PTR), 2)),
                                 65520),
                           144),
                      xNEQ (
                          xAND (getFIXED (
                                    mHALMAT
                                    + 4
                                          * xsubtract (
                                              COREHALFWORD (mHALMAT_PTR), 2)),
                                4278190080),
                          0))))
                // CALL PUSH_CASE_FRAME('LBL', FALSE_CASE); (2162)
                {
                  putCHARACTERp (mPASS1xPUSH_CASE_FRAMExPUSH_IND,
                                 cToDescriptor (NULL, "LBL"));
                  putBITp (8, mPASS1xPUSH_CASE_FRAMExPUSH_IND_FLAG,
                           fixedToBit (32, (int32_t)(32)));
                  PASS1xPUSH_CASE_FRAME (0);
                }
              // ELSE (2163)
              else
                // IF HALRAND_QUALIFIER = SYT THEN (2164)
                if (1 & (xEQ (BYTE0 (mHALRAND_QUALIFIER), 1)))
                  // IF SYT_DIMS(HALRAND) ~= 0 THEN (2165)
                  if (1
                      & (xNEQ (COREHALFWORD (getFIXED (mSYM_TAB)
                                             + 34 * (COREHALFWORD (mHALRAND))
                                             + 18 + 2 * (0)),
                               0)))
                    // CALL FLUSH_INFO; (2166)
                    PASS1xFLUSH_INFO (0);
            es1s5s2:;
            } // End of DO block
        es1s5:;
        } // End of DO block
        break;
      case 9:
        // IF HALRATOR_TAG1 THEN (2168)
        if (1 & (bitToFixed (getBIT (8, mHALRATOR_TAG1))))
          {
            putCHARACTERp (mPASS1xPOP_CASE_FRAMExPOP_IND,
                           cToDescriptor (NULL, "BRA*"));
            PASS1xPOP_CASE_FRAME (0);
          }
        break;
      case 10:
        // DO; (2170)
        {
        rs1s6:;
          // CALL SET_RAND_NOOSE(2); (2170)
          {
            putBITp (16, mPASS1xSET_RAND_NOOSExRANDp,
                     fixedToBit (32, (int32_t)(2)));
            PASS1xSET_RAND_NOOSE (0);
          }
          // CALL PUSH_FIRST_CASE_FRAME('FBRA', TRUE_CASE); (2171)
          {
            putCHARACTERp (mPASS1xPUSH_FIRST_CASE_FRAMExPUSH_IND,
                           cToDescriptor (NULL, "FBRA"));
            putBITp (8, mPASS1xPUSH_FIRST_CASE_FRAMExPUSH_IND_FLAG,
                     fixedToBit (32, (int32_t)(16)));
            PASS1xPUSH_FIRST_CASE_FRAME (0);
          }
        es1s6:;
        } // End of DO block
        break;
      case 11:
        // DO; (2173)
        {
        rs1s7:;
          // CALL SET_RAND_NOOSE(2); (2173)
          {
            putBITp (16, mPASS1xSET_RAND_NOOSExRANDp,
                     fixedToBit (32, (int32_t)(2)));
            PASS1xSET_RAND_NOOSE (0);
          }
          // CALL PUSH_CB_FRAME; (2174)
          PASS1xPUSH_CB_FRAME (0);
          // IF HALRATOR_TAG1 THEN (2175)
          if (1 & (bitToFixed (getBIT (8, mHALRATOR_TAG1))))
            // CALL PUSH_FIRST_CASE_FRAME('DCAS'); (2176)
            {
              putCHARACTERp (mPASS1xPUSH_FIRST_CASE_FRAMExPUSH_IND,
                             cToDescriptor (NULL, "DCAS"));
              PASS1xPUSH_FIRST_CASE_FRAME (0);
            }
          // ELSE (2177)
          else
            // FRAME_FLAGS(STACK_PTR) = FRAME_FLAGS(STACK_PTR) |
            // FIRST_CASE_TBD_FLAG; (2178)
            {
              int32_t numberRHS = (int32_t)(xOR (
                  BYTE0 (getFIXED (mSTACK_FRAME)
                         + 32 * (COREHALFWORD (mSTACK_PTR)) + 31 + 1 * (0)),
                  64));
              putBIT (8,
                      getFIXED (mSTACK_FRAME)
                          + 32 * (COREHALFWORD (mSTACK_PTR)) + 31 + 1 * (0),
                      fixedToBit (8, numberRHS));
            }
        es1s7:;
        } // End of DO block
        break;
      case 12:
        // CALL POP_CB_FRAME; (2180)
        PASS1xPOP_CB_FRAME (0);
        break;
      case 13:
        // DO; (2181)
        {
        rs1s8:;
          // IF (FRAME_FLAGS(STACK_PTR) & FIRST_CASE_TBD_FLAG) ~= 0 THEN (2181)
          if (1
              & (xNEQ (xAND (BYTE0 (getFIXED (mSTACK_FRAME)
                                    + 32 * (COREHALFWORD (mSTACK_PTR)) + 31
                                    + 1 * (0)),
                             64),
                       0)))
            // DO; (2182)
            {
            rs1s8s1:;
              // FRAME_FLAGS(STACK_PTR) = FRAME_FLAGS(STACK_PTR) &
              // ~FIRST_CASE_TBD_FLAG; (2183)
              {
                int32_t numberRHS = (int32_t)(xAND (
                    BYTE0 (getFIXED (mSTACK_FRAME)
                           + 32 * (COREHALFWORD (mSTACK_PTR)) + 31 + 1 * (0)),
                    4294967231));
                putBIT (8,
                        getFIXED (mSTACK_FRAME)
                            + 32 * (COREHALFWORD (mSTACK_PTR)) + 31 + 1 * (0),
                        fixedToBit (8, numberRHS));
              }
              // CALL PUSH_FIRST_CASE_FRAME('CLBL'); (2184)
              {
                putCHARACTERp (mPASS1xPUSH_FIRST_CASE_FRAMExPUSH_IND,
                               cToDescriptor (NULL, "CLBL"));
                PASS1xPUSH_FIRST_CASE_FRAME (0);
              }
            es1s8s1:;
            } // End of DO block
          // ELSE (2185)
          else
            // IF HALRATOR_TAG1 THEN (2186)
            if (1 & (bitToFixed (getBIT (8, mHALRATOR_TAG1))))
              // CALL POP_CASE_FRAME('CLBL*'); (2187)
              {
                putCHARACTERp (mPASS1xPOP_CASE_FRAMExPOP_IND,
                               cToDescriptor (NULL, "CLBL*"));
                PASS1xPOP_CASE_FRAME (0);
              }
            // ELSE (2188)
            else
              // DO; (2189)
              {
              rs1s8s2:;
                // CALL POP_CASE_FRAME('CLBL'); (2190)
                {
                  putCHARACTERp (mPASS1xPOP_CASE_FRAMExPOP_IND,
                                 cToDescriptor (NULL, "CLBL"));
                  PASS1xPOP_CASE_FRAME (0);
                }
                // CALL PUSH_CASE_FRAME('CLBL'); (2191)
                {
                  putCHARACTERp (mPASS1xPUSH_CASE_FRAMExPUSH_IND,
                                 cToDescriptor (NULL, "CLBL"));
                  PASS1xPUSH_CASE_FRAME (0);
                }
              es1s8s2:;
              } // End of DO block
        es1s8:;
        } // End of DO block
        break;
      case 14:
          // ; (2193)
          ;
        break;
      case 15:
          // ; (2194)
          ;
        break;
      }
  } // End of DO CASE block
  {
    reentryGuard = 0;
    return 0;
  }
}
