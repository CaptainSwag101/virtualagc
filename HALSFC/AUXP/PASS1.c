/*
  File PASS1.c generated by XCOM-I, 2024-08-09 12:39:13.
*/

#include "runtimeC.h"

int32_t
PASS1 (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "PASS1");
  // THIS_HALMAT_BLOCK = ON; (1227)
  {
    int32_t numberRHS = (int32_t)(1);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (1, mPASS1xTHIS_HALMAT_BLOCK, bitRHS);
    bitRHS->inUse = 0;
  }
  // NUMOP = 0; (1228)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mPASS1xNUMOP, bitRHS);
    bitRHS->inUse = 0;
  }
  // DO WHILE THIS_HALMAT_BLOCK; (1229)
  while (1 & (bitToFixed (getBIT (1, mPASS1xTHIS_HALMAT_BLOCK))))
    {
      // HALMAT_PTR = HALMAT_PTR + NUMOP; (1230)
      {
        int32_t numberRHS = (int32_t)(xadd (COREHALFWORD (mHALMAT_PTR),
                                            COREHALFWORD (mPASS1xNUMOP)));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mHALMAT_PTR, bitRHS);
        bitRHS->inUse = 0;
      }
      // CALL DECODE_HALRATOR(HALMAT_PTR); (1231)
      {
        putBITp (16, mPASS1xDECODE_HALRATORxOP, getBIT (16, mHALMAT_PTR));
        PASS1xDECODE_HALRATOR (0);
      }
      // DO CASE HALRATOR_CLASS; (1232)
      {
      rs1s1:
        switch (BYTE0 (mHALRATOR_CLASS))
          {
          case 0:
            // CALL CLASS_0; (1234)
            PASS1xCLASS_0 (0);
            break;
          case 1:
            // CALL CLASS_1; (1235)
            PASS1xCLASS_1 (0);
            break;
          case 2:
            // CALL CLASS_2; (1236)
            PASS1xCLASS_2 (0);
            break;
          case 3:
            // CALL CLASS_3; (1237)
            PASS1xCLASS_3 (0);
            break;
          case 4:
            // CALL CLASS_4; (1238)
            PASS1xCLASS_4 (0);
            break;
          case 5:
            // CALL CLASS_5; (1239)
            PASS1xCLASS_5 (0);
            break;
          case 6:
            // CALL CLASS_6; (1240)
            PASS1xCLASS_6 (0);
            break;
          case 7:
            // CALL CLASS_7; (1241)
            PASS1xCLASS_7 (0);
            break;
          case 8:
              // ; (1242)
              ;
            break;
          }
      } // End of DO CASE block
      // NUMOP = HALRATOR_#RANDS + 1; (1242)
      {
        int32_t numberRHS = (int32_t)(xadd (BYTE0 (mHALRATOR_pRANDS), 1));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mPASS1xNUMOP, bitRHS);
        bitRHS->inUse = 0;
      }
    } // End of DO WHILE block
  // SAVE_STACK_PTR = STACK_PTR; (1243)
  {
    descriptor_t *bitRHS = getBIT (16, mSTACK_PTR);
    putBIT (16, mPASS1xSAVE_STACK_PTR, bitRHS);
    bitRHS->inUse = 0;
  }
  // DO CASE FRAME_TYPE(STACK_PTR); (1244)
  {
  rs2:
    switch (BYTE0 (getFIXED (mSTACK_FRAME) + 32 * (COREHALFWORD (mSTACK_PTR))
                   + 30 + 1 * (0)))
      {
      case 0:
          // ; (1246)
          ;
        break;
      case 1:
        // GO TO CLOSE_DOWN_DONE; (1247)
        goto CLOSE_DOWN_DONE;
        break;
      case 2:
        // CALL POP_CB_FRAME; (1248)
        PASS1xPOP_CB_FRAME (0);
        break;
      case 3:
        // CALL POP_CASE_FRAME('CLOSE DOWN'); (1249)
        {
          putCHARACTERp (mPASS1xPOP_CASE_FRAMExPOP_IND,
                         cToDescriptor (NULL, "CLOSE DOWN"));
          PASS1xPOP_CASE_FRAME (0);
        }
        break;
      }
  } // End of DO CASE block
// CLOSE_DOWN_DONE: (1249)
CLOSE_DOWN_DONE:
  // STACK_PTR = SAVE_STACK_PTR; (1250)
  {
    descriptor_t *bitRHS = getBIT (16, mPASS1xSAVE_STACK_PTR);
    putBIT (16, mSTACK_PTR, bitRHS);
    bitRHS->inUse = 0;
  }
  {
    reentryGuard = 0;
    return 0;
  }
}
