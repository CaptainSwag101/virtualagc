/*
  File GET_FREE_CELL.c generated by XCOM-I, 2024-08-08 04:32:08.
*/

#include "../AUXP/runtimeC.h"

descriptor_t *
GET_FREE_CELL (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (descriptor_t *)0;
    }
  reentryGuard = guardReentry (reentryGuard, "GET_FREE_CELL");
  // IF FREE_CELL_PTR = RECORD_TOP(LIST_STRUX) THEN (1103)
  if (1
      & (xEQ (COREHALFWORD (mFREE_CELL_PTR),
              xsubtract (COREWORD (xadd (
                             ADDR ("LIST_STRUX", 0x80000000, NULL, 0), 12)),
                         1))))
    // DO; (1104)
    {
    rs1:;
      // DO ; (1105)
      {
      rs1s1:;
        // IF COREWORD ( ADDR ( LIST_STRUX ) + 12 ) >= COREWORD ( ADDR (
        // LIST_STRUX ) + 8 ) THEN (1106)
        if (1
            & (xGE (
                COREWORD (xadd (ADDR ("LIST_STRUX", 0x80000000, NULL, 0), 12)),
                COREWORD (
                    xadd (ADDR ("LIST_STRUX", 0x80000000, NULL, 0), 8)))))
          // CALL _NEEDMORE_SPACE ( ADDR ( LIST_STRUX )  ) ; (1107)
          {
            putFIXED (m_NEEDMORE_SPACExDOPE,
                      ADDR ("LIST_STRUX", 0x80000000, NULL, 0));
            _NEEDMORE_SPACE (0);
          }
        // COREWORD ( ADDR ( LIST_STRUX ) + 12 ) = COREWORD ( ADDR ( LIST_STRUX
        // ) + 12 ) + 1 ; (1108)
        {
          int32_t numberRHS = (int32_t)(xadd (
              COREWORD (xadd (ADDR ("LIST_STRUX", 0x80000000, NULL, 0), 12)),
              1));
          COREWORD2 (xadd (ADDR ("LIST_STRUX", 0x80000000, NULL, 0), 12),
                     numberRHS);
        }
      es1s1:;
      } // End of DO block
      // CDR_CELL(FREE_CELL_PTR) = FREE_CELL_PTR + 1; (1109)
      {
        int32_t numberRHS = (int32_t)(xadd (COREHALFWORD (mFREE_CELL_PTR), 1));
        putBIT (16,
                getFIXED (mLIST_STRUX) + 8 * (COREHALFWORD (mFREE_CELL_PTR))
                    + 4 + 2 * (0),
                fixedToBit (16, numberRHS));
      }
    es1:;
    } // End of DO block
  // TEMP_PTR = FREE_CELL_PTR; (1110)
  {
    descriptor_t *bitRHS = getBIT (16, mFREE_CELL_PTR);
    putBIT (16, mGET_FREE_CELLxTEMP_PTR, bitRHS);
    bitRHS->inUse = 0;
  }
  // FREE_CELL_PTR = CDR_CELL(TEMP_PTR); (1111)
  {
    descriptor_t *bitRHS = getBIT (
        16, getFIXED (mLIST_STRUX)
                + 8 * (COREHALFWORD (mGET_FREE_CELLxTEMP_PTR)) + 4 + 2 * (0));
    putBIT (16, mFREE_CELL_PTR, bitRHS);
    bitRHS->inUse = 0;
  }
  // CELL1_FLAGS(TEMP_PTR), CELL2_FLAGS(TEMP_PTR) = 0; (1112)
  {
    int32_t numberRHS = (int32_t)(0);
    putBIT (8,
            getFIXED (mLIST_STRUX)
                + 8 * (COREHALFWORD (mGET_FREE_CELLxTEMP_PTR)) + 6 + 1 * (0),
            fixedToBit (8, numberRHS));
    putBIT (8,
            getFIXED (mLIST_STRUX)
                + 8 * (COREHALFWORD (mGET_FREE_CELLxTEMP_PTR)) + 7 + 1 * (0),
            fixedToBit (8, numberRHS));
  }
  // CELL1(TEMP_PTR), CELL2(TEMP_PTR), CDR_CELL(TEMP_PTR) = 0; (1113)
  {
    int32_t numberRHS = (int32_t)(0);
    putBIT (16,
            getFIXED (mLIST_STRUX)
                + 8 * (COREHALFWORD (mGET_FREE_CELLxTEMP_PTR)) + 0 + 2 * (0),
            fixedToBit (16, numberRHS));
    putBIT (16,
            getFIXED (mLIST_STRUX)
                + 8 * (COREHALFWORD (mGET_FREE_CELLxTEMP_PTR)) + 2 + 2 * (0),
            fixedToBit (16, numberRHS));
    putBIT (16,
            getFIXED (mLIST_STRUX)
                + 8 * (COREHALFWORD (mGET_FREE_CELLxTEMP_PTR)) + 4 + 2 * (0),
            fixedToBit (16, numberRHS));
  }
  // RETURN TEMP_PTR; (1114)
  {
    reentryGuard = 0;
    return getBIT (16, mGET_FREE_CELLxTEMP_PTR);
  }
}
