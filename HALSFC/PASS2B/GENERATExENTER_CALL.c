/*
  File GENERATExENTER_CALL.c generated by XCOM-I, 2024-08-09 12:41:32.
*/

#include "runtimeC.h"

descriptor_t *
GENERATExENTER_CALL (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (descriptor_t *)0;
    }
  reentryGuard = guardReentry (reentryGuard, "GENERATExENTER_CALL");
  // NAME = LIBNAME(NAME); (3779)
  {
    descriptor_t *stringRHS;
    stringRHS = (putCHARACTERp (mGENERATExLIBNAMExNAME,
                                getCHARACTER (mGENERATExENTER_CALLxNAME)),
                 GENERATExLIBNAME (0));
    putCHARACTER (mGENERATExENTER_CALLxNAME, stringRHS);
    stringRHS->inUse = 0;
  }
  // J = HASH(NAME); (3780)
  {
    int32_t numberRHS = (int32_t)((
        putCHARACTERp (mHASHxNAME, getCHARACTER (mGENERATExENTER_CALLxNAME)),
        HASH (0)));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mGENERATExENTER_CALLxJ, bitRHS);
    bitRHS->inUse = 0;
  }
  // I = ESD_START(J); (3781)
  {
    descriptor_t *bitRHS
        = getBIT (16, mESD_START + 2 * COREHALFWORD (mGENERATExENTER_CALLxJ));
    putBIT (16, mGENERATExENTER_CALLxI, bitRHS);
    bitRHS->inUse = 0;
  }
  // DO WHILE I ~= 0; (3782)
  while (1 & (xNEQ (COREHALFWORD (mGENERATExENTER_CALLxI), 0)))
    {
      // IF ESD_TABLE(I) = NAME THEN (3783)
      if (1
          & (xsEQ ((putBITp (16, mESD_TABLExPTR,
                             getBIT (16, mGENERATExENTER_CALLxI)),
                    ESD_TABLE (0)),
                   getCHARACTER (mGENERATExENTER_CALLxNAME))))
        // RETURN I; (3784)
        {
          reentryGuard = 0;
          return getBIT (16, mGENERATExENTER_CALLxI);
        }
      // I = ESD_LINK(I); (3785)
      {
        descriptor_t *bitRHS = getBIT (
            16, mESD_LINK + 2 * COREHALFWORD (mGENERATExENTER_CALLxI));
        putBIT (16, mGENERATExENTER_CALLxI, bitRHS);
        bitRHS->inUse = 0;
      }
    } // End of DO WHILE block
  // ESD_MAX = ESD_MAX + 1; (3786)
  {
    int32_t numberRHS = (int32_t)(xadd (COREHALFWORD (mESD_MAX), 1));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mESD_MAX, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF ESD_MAX > ESD_LIMIT THEN (3787)
  if (1 & (xGT (COREHALFWORD (mESD_MAX), 400)))
    // DO; (3788)
    {
    rs2:;
      // ESD_MAX = ESD_LIMIT; (3789)
      {
        int32_t numberRHS = (int32_t)(400);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mESD_MAX, bitRHS);
        bitRHS->inUse = 0;
      }
      // CALL ERRORS(CLASS_BS,110); (3790)
      {
        putBITp (16, mERRORSxCLASS, getBIT (8, mCLASS_BS));
        putBITp (16, mERRORSxNUM, fixedToBit (32, (int32_t)(110)));
        ERRORS (0);
      }
    es2:;
    } // End of DO block
  // CALL ENTER_ESD(NAME, ESD_MAX, 2, LIBRARY_CSECT_TYPE); (3791)
  {
    putCHARACTERp (mENTER_ESDxNAME, getCHARACTER (mGENERATExENTER_CALLxNAME));
    putBITp (16, mENTER_ESDxPTR, getBIT (16, mESD_MAX));
    putBITp (16, mENTER_ESDxTYP, fixedToBit (32, (int32_t)(2)));
    putBITp (8, mENTER_ESDxCSECT_TYPE, fixedToBit (32, (int32_t)(160)));
    ENTER_ESD (0);
  }
  // ESD_LINK(ESD_MAX) = ESD_START(J); (3792)
  {
    descriptor_t *bitRHS
        = getBIT (16, mESD_START + 2 * COREHALFWORD (mGENERATExENTER_CALLxJ));
    putBIT (16, mESD_LINK + 2 * (COREHALFWORD (mESD_MAX)), bitRHS);
    bitRHS->inUse = 0;
  }
  // ESD_START(J) = ESD_MAX; (3793)
  {
    descriptor_t *bitRHS = getBIT (16, mESD_MAX);
    putBIT (16, mESD_START + 2 * (COREHALFWORD (mGENERATExENTER_CALLxJ)),
            bitRHS);
    bitRHS->inUse = 0;
  }
  // RETURN ESD_MAX; (3794)
  {
    reentryGuard = 0;
    return getBIT (16, mESD_MAX);
  }
}
