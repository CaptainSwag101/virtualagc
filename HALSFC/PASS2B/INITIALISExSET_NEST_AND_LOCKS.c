/*
  File INITIALISExSET_NEST_AND_LOCKS.c generated by XCOM-I, 2024-08-09
  12:41:32.
*/

#include "runtimeC.h"

int32_t
INITIALISExSET_NEST_AND_LOCKS (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "INITIALISExSET_NEST_AND_LOCKS");
  // TAG2, SYT_DISP(OP1)=SYT_SCOPE(OP1); (2045)
  {
    descriptor_t *bitRHS = getBIT (
        8, getFIXED (mSYM_TAB) + 34 * (COREHALFWORD (mOP1)) + 29 + 1 * (0));
    putBIT (16, mTAG2, bitRHS);
    putBIT (16, getFIXED (mP2SYMS) + 12 * (COREHALFWORD (mOP1)) + 6 + 2 * (0),
            bitRHS);
    bitRHS->inUse = 0;
  }
  // OP2=PROC_LINK(TAG2); (2046)
  {
    descriptor_t *bitRHS = getBIT (16, mPROC_LINK + 2 * COREHALFWORD (mTAG2));
    putBIT (16, mOP2, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF OP2~=0 THEN (2047)
  if (1 & (xNEQ (COREHALFWORD (mOP2), 0)))
    // SYT_LEVEL(OP2)=OP1; (2048)
    {
      descriptor_t *bitRHS = getBIT (16, mOP1);
      putBIT (16,
              getFIXED (mP2SYMS) + 12 * (COREHALFWORD (mOP2)) + 10 + 2 * (0),
              bitRHS);
      bitRHS->inUse = 0;
    }
  // PROC_LINK(TAG2)=OP1; (2049)
  {
    descriptor_t *bitRHS = getBIT (16, mOP1);
    putBIT (16, mPROC_LINK + 2 * (COREHALFWORD (mTAG2)), bitRHS);
    bitRHS->inUse = 0;
  }
  // IF PROGPOINT > 0 & TAG2 >= PROGPOINT THEN (2050)
  if (1
      & (xAND (xGT (COREHALFWORD (mPROGPOINT), 0),
               xGE (COREHALFWORD (mTAG2), COREHALFWORD (mPROGPOINT)))))
    // IF LASTBASE(TAG2) = TEMPBASE THEN (2051)
    if (1
        & (xEQ (COREHALFWORD (mLASTBASE + 2 * COREHALFWORD (mTAG2)),
                BYTE0 (mTEMPBASE))))
      // DO; (2052)
      {
      rs1:;
        // IF (SYT_FLAGS(OP1) & AUTO_FLAG) = 0 THEN (2053)
        if (1
            & (xEQ (
                xAND (getFIXED (getFIXED (mSYM_TAB)
                                + 34 * (COREHALFWORD (mOP1)) + 8 + 4 * (0)),
                      getFIXED (mAUTO_FLAG)),
                0)))
          // SYT_DISP(OP1) = DATAPOINT; (2054)
          {
            descriptor_t *bitRHS = getBIT (16, mINITIALISExDATAPOINT);
            putBIT (16,
                    getFIXED (mP2SYMS) + 12 * (COREHALFWORD (mOP1)) + 6
                        + 2 * (0),
                    bitRHS);
            bitRHS->inUse = 0;
          }
      es1:;
      } // End of DO block
    // ELSE (2055)
    else
      // IF TAG2 = PROGPOINT THEN (2056)
      if (1 & (xEQ (COREHALFWORD (mTAG2), COREHALFWORD (mPROGPOINT))))
        // SYT_DISP(OP1) = DATAPOINT; (2057)
        {
          descriptor_t *bitRHS = getBIT (16, mINITIALISExDATAPOINT);
          putBIT (16,
                  getFIXED (mP2SYMS) + 12 * (COREHALFWORD (mOP1)) + 6
                      + 2 * (0),
                  bitRHS);
          bitRHS->inUse = 0;
        }
      // ELSE (2058)
      else
        // IF SYT_CONST(OP1) ~= 0 & (SYT_FLAGS(OP1)&NAME_FLAG) = 0 THEN (2059)
        if (1
            & (xAND (
                xNEQ (getFIXED (getFIXED (mP2SYMS) + 12 * (COREHALFWORD (mOP1))
                                + 0 + 4 * (0)),
                      0),
                xEQ (xAND (getFIXED (getFIXED (mSYM_TAB)
                                     + 34 * (COREHALFWORD (mOP1)) + 8
                                     + 4 * (0)),
                           getFIXED (mNAME_FLAG)),
                     0))))
          // SYT_DISP(OP1) = DATAPOINT; (2060)
          {
            descriptor_t *bitRHS = getBIT (16, mINITIALISExDATAPOINT);
            putBIT (16,
                    getFIXED (mP2SYMS) + 12 * (COREHALFWORD (mOP1)) + 6
                        + 2 * (0),
                    bitRHS);
            bitRHS->inUse = 0;
          }
  // IF DATA_REMOTE THEN (2061)
  if (1 & (bitToFixed (getBIT (1, mDATA_REMOTE))))
    // IF (CSECT_TYPE(OP1,0)=REMOTE#R)& ((SYT_FLAGS(OP1)&NAME_FLAG)=0) THEN
    // (2062)
    if (1
        & (xAND (
            xEQ (bitToFixed ((putBITp (16, mCSECT_TYPExPTR, getBIT (16, mOP1)),
                              putBITp (16, mCSECT_TYPExOP,
                                       fixedToBit (32, (int32_t)(0))),
                              CSECT_TYPE (0))),
                 5),
            xEQ (xAND (getFIXED (getFIXED (mSYM_TAB)
                                 + 34 * (COREHALFWORD (mOP1)) + 8 + 4 * (0)),
                       getFIXED (mNAME_FLAG)),
                 0))))
      // DO; (2063)
      {
      rs2:;
        // SYT_FLAGS(OP1) = SYT_FLAGS(OP1) & ~REMOTE_FLAG; (2064)
        {
          int32_t numberRHS = (int32_t)(xAND (
              getFIXED (getFIXED (mSYM_TAB) + 34 * (COREHALFWORD (mOP1)) + 8
                        + 4 * (0)),
              xNOT (getFIXED (mREMOTE_FLAG))));
          putFIXED (getFIXED (mSYM_TAB) + 34 * (COREHALFWORD (mOP1)) + 8
                        + 4 * (0),
                    numberRHS);
        }
      es2:;
      } // End of DO block
  // IF ((SYT_FLAGS(OP1) & NAME_OR_REMOTE) = REMOTE_FLAG) & ((SYT_FLAGS(OP1) &
  // INCLUDED_REMOTE) = 0) THEN (2065)
  if (1
      & (xAND (
          xEQ (xAND (getFIXED (getFIXED (mSYM_TAB) + 34 * (COREHALFWORD (mOP1))
                               + 8 + 4 * (0)),
                     getFIXED (mNAME_OR_REMOTE)),
               getFIXED (mREMOTE_FLAG)),
          xEQ (xAND (getFIXED (getFIXED (mSYM_TAB) + 34 * (COREHALFWORD (mOP1))
                               + 8 + 4 * (0)),
                     getFIXED (mINCLUDED_REMOTE)),
               0))))
    // DO; (2066)
    {
    rs3:;
      // IF PROGPOINT > 0 & TAG2 >= PROGPOINT THEN (2067)
      if (1
          & (xAND (xGT (COREHALFWORD (mPROGPOINT), 0),
                   xGE (COREHALFWORD (mTAG2), COREHALFWORD (mPROGPOINT)))))
        // DO; (2068)
        {
        rs3s1:;
          // SYT_DISP(OP1) = DATAPOINT; (2069)
          {
            descriptor_t *bitRHS = getBIT (16, mINITIALISExDATAPOINT);
            putBIT (16,
                    getFIXED (mP2SYMS) + 12 * (COREHALFWORD (mOP1)) + 6
                        + 2 * (0),
                    bitRHS);
            bitRHS->inUse = 0;
          }
          // REMOTE_LEVEL = TRUE; (2070)
          {
            int32_t numberRHS = (int32_t)(1);
            descriptor_t *bitRHS;
            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
            putBIT (8, mREMOTE_LEVEL, bitRHS);
            bitRHS->inUse = 0;
          }
        es3s1:;
        } // End of DO block
      // ELSE (2071)
      else
        // IF REMOTE_LEVEL(TAG2) = 0 THEN (2072)
        if (1 & (xEQ (BYTE0 (mREMOTE_LEVEL + 1 * COREHALFWORD (mTAG2)), 0)))
          // DO; (2073)
          {
          rs3s2:;
            // REMOTE_LEVEL(TAG2), DATALIMIT = DATALIMIT + 1; (2074)
            {
              int32_t numberRHS
                  = (int32_t)(xadd (COREHALFWORD (mDATALIMIT), 1));
              descriptor_t *bitRHS;
              bitRHS = fixedToBit (32, (int32_t)(numberRHS));
              putBIT (8, mREMOTE_LEVEL + 1 * (COREHALFWORD (mTAG2)), bitRHS);
              bitRHS = fixedToBit (32, (int32_t)(numberRHS));
              putBIT (16, mDATALIMIT, bitRHS);
              bitRHS->inUse = 0;
            }
            // CALL ENTER_ESD(PROGNAME(PROC_LEVEL(TAG2), 11), DATALIMIT, 2,
            // DATA_CSECT_TYPE); (2075)
            {
              putCHARACTERp (
                  mENTER_ESDxNAME,
                  (putBITp (
                       16, mPROGNAMExENTRY,
                       getBIT (16, mPROC_LEVEL + 2 * COREHALFWORD (mTAG2))),
                   putBITp (16, mPROGNAMExFLAG,
                            fixedToBit (32, (int32_t)(11))),
                   PROGNAME (0)));
              putBITp (16, mENTER_ESDxPTR, getBIT (16, mDATALIMIT));
              putBITp (16, mENTER_ESDxTYP, fixedToBit (32, (int32_t)(2)));
              putBITp (8, mENTER_ESDxCSECT_TYPE,
                       fixedToBit (32, (int32_t)(64)));
              ENTER_ESD (0);
            }
          es3s2:;
          } // End of DO block
    // LINK_REMOTE: (2076)
    LINK_REMOTE:
      // SYT_LINK1(OP1) = 0; (2077)
      {
        int32_t numberRHS = (int32_t)(0);
        putBIT (16,
                getFIXED (mSYM_TAB) + 34 * (COREHALFWORD (mOP1)) + 24
                    + 2 * (0),
                fixedToBit (16, numberRHS));
      }
      // IF LASTREMOTE > 0 THEN (2078)
      if (1 & (xGT (COREHALFWORD (mLASTREMOTE), 0)))
        // SYT_LINK1(LASTREMOTE) = OP1; (2079)
        {
          descriptor_t *bitRHS = getBIT (16, mOP1);
          putBIT (16,
                  getFIXED (mSYM_TAB) + 34 * (COREHALFWORD (mLASTREMOTE)) + 24
                      + 2 * (0),
                  bitRHS);
          bitRHS->inUse = 0;
        }
      // ELSE (2080)
      else
        // FIRSTREMOTE = OP1; (2081)
        {
          descriptor_t *bitRHS = getBIT (16, mOP1);
          putBIT (16, mFIRSTREMOTE, bitRHS);
          bitRHS->inUse = 0;
        }
      // LASTREMOTE = OP1; (2082)
      {
        descriptor_t *bitRHS = getBIT (16, mOP1);
        putBIT (16, mLASTREMOTE, bitRHS);
        bitRHS->inUse = 0;
      }
    es3:;
    } // End of DO block
  // ELSE (2083)
  else
    // IF ((SYT_FLAGS(PROC_LEVEL(TAG2)) & REMOTE_FLAG) ~= 0) &
    // (SYT_TYPE(PROC_LEVEL(TAG2)) = COMPOOL_LABEL) THEN (2084)
    if (1
        & (xAND (xNEQ (xAND (getFIXED (getFIXED (mSYM_TAB)
                                       + 34
                                             * (COREHALFWORD (
                                                 mPROC_LEVEL
                                                 + 2 * COREHALFWORD (mTAG2)))
                                       + 8 + 4 * (0)),
                             getFIXED (mREMOTE_FLAG)),
                       0),
                 xEQ (BYTE0 (getFIXED (mSYM_TAB)
                             + 34
                                   * (COREHALFWORD (
                                       mPROC_LEVEL + 2 * COREHALFWORD (mTAG2)))
                             + 32 + 1 * (0)),
                      BYTE0 (mCOMPOOL_LABEL)))))
      // GO TO LINK_REMOTE; (2085)
      goto LINK_REMOTE;
  {
    reentryGuard = 0;
    return 0;
  }
}
