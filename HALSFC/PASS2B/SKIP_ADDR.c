/*
  File SKIP_ADDR.c generated by XCOM-I, 2024-08-09 12:41:33.
*/

#include "runtimeC.h"

int32_t
SKIP_ADDR (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "SKIP_ADDR");
  // CALL NEXT_REC(1); (14357)
  {
    putBITp (16, mNEXT_RECxI, fixedToBit (32, (int32_t)(1)));
    NEXT_REC (0);
  }
  // IF LHS(1) = CSYM THEN (14358)
  if (1 & (xEQ (COREHALFWORD (mLHS + 2 * 1), BYTE0 (mCSYM))))
    // DO; (14359)
    {
    rs1:;
      // IF RHS(1) = PRELBASE THEN (14360)
      if (1 & (xEQ (COREHALFWORD (mRHS + 2 * 1), BYTE0 (mPRELBASE))))
        // DO; (14361)
        {
        rs1s1:;
          // IF EMITTING THEN (14362)
          if (1 & (bitToFixed (getBIT (1, mEMITTING))))
            // DO; (14363)
            {
            rs1s1s1:;
              // CALL NEXT_REC(1); (14364)
              {
                putBITp (16, mNEXT_RECxI, fixedToBit (32, (int32_t)(1)));
                NEXT_REC (0);
              }
              // TEMP = TEMP + PROGDELTA; (14365)
              {
                int32_t numberRHS = (int32_t)(xadd (
                    getFIXED (mTEMP), COREHALFWORD (mPROGDELTA)));
                putFIXED (mTEMP, numberRHS);
              }
              // CODE(GET_CODE(CODE_LINE-1)) = TEMP; (14366)
              {
                int32_t numberRHS = (int32_t)(getFIXED (mTEMP));
                putFIXED (
                    mCODE
                        + 4
                              * ((putFIXED (
                                      mGET_CODExCTR,
                                      xsubtract (getFIXED (mCODE_LINE), 1)),
                                  GET_CODE (0))),
                    numberRHS);
              }
            es1s1s1:;
            } // End of DO block
          // ELSE (14367)
          else
            // CALL SKIP(1); (14368)
            {
              putBITp (16, mSKIPxN, fixedToBit (32, (int32_t)(1)));
              SKIP (0);
            }
        es1s1:;
        } // End of DO block
      // ELSE (14369)
      else
        // CALL SKIP(1); (14370)
        {
          putBITp (16, mSKIPxN, fixedToBit (32, (int32_t)(1)));
          SKIP (0);
        }
    es1:;
    } // End of DO block
  {
    reentryGuard = 0;
    return 0;
  }
}
