/*
  File PRINTSUMMARY.c generated by XCOM-I, 2024-08-09 12:41:32.
*/

#include "runtimeC.h"

int32_t
PRINTSUMMARY (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "PRINTSUMMARY");
  // CALL MONITOR(0, 3); (14027)
  MONITOR0 (3);
  // IF MAX_SEVERITY < 2 THEN (14028)
  if (1 & (xLT (COREHALFWORD (mMAX_SEVERITY), 2)))
    // DO; (14029)
    {
    rs1:;
      // IF CODE_LISTING THEN (14030)
      if (1 & (bitToFixed (getBIT (1, mCODE_LISTING))))
        // DO; (14031)
        {
        rs1s1:;
          // CALL SYT_DUMP; (14032)
          PRINTSUMMARYxSYT_DUMP (0);
          // CALL TEMPLATE_DUMP; (14033)
          PRINTSUMMARYxTEMPLATE_DUMP (0);
          // CALL ALIGN_DUMP; (14034)
          PRINTSUMMARYxALIGN_DUMP (0);
          // OUTPUT(1) = '-INSTRUCTION FREQUENCIES'; (14035)
          {
            descriptor_t *stringRHS;
            stringRHS = cToDescriptor (NULL, "-INSTRUCTION FREQUENCIES");
            OUTPUT (1, stringRHS);
            stringRHS->inUse = 0;
          }
          // OUTPUT(1) = '0INSN  COUNT'; (14036)
          {
            descriptor_t *stringRHS;
            stringRHS = cToDescriptor (NULL, "0INSN  COUNT");
            OUTPUT (1, stringRHS);
            stringRHS->inUse = 0;
          }
          // DO T = 0 TO OPMAX; (14037)
          {
            int32_t from130, to130, by130;
            from130 = 0;
            to130 = 205;
            by130 = 1;
            for (putFIXED (mPRINTSUMMARYxT, from130);
                 getFIXED (mPRINTSUMMARYxT) <= to130; putFIXED (
                     mPRINTSUMMARYxT, getFIXED (mPRINTSUMMARYxT) + by130))
              {
                // IF OPCOUNT(T) > 0 THEN (14038)
                if (1
                    & (xGT (COREHALFWORD (mOPCOUNT
                                          + 2 * getFIXED (mPRINTSUMMARYxT)),
                            0)))
                  // DO; (14039)
                  {
                  rs1s1s1s1:;
                    // IF T = 39 | T = 55 THEN (14040)
                    if (1
                        & (xOR (xEQ (getFIXED (mPRINTSUMMARYxT), 39),
                                xEQ (getFIXED (mPRINTSUMMARYxT), 55))))
                      // OPCOUNT(T+4)= OPCOUNT(T) + OPCOUNT(T+4); (14041)
                      {
                        int32_t numberRHS = (int32_t)(xadd (
                            COREHALFWORD (mOPCOUNT
                                          + 2 * getFIXED (mPRINTSUMMARYxT)),
                            COREHALFWORD (
                                mOPCOUNT
                                + 2 * xadd (getFIXED (mPRINTSUMMARYxT), 4))));
                        descriptor_t *bitRHS;
                        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                        putBIT (
                            16,
                            mOPCOUNT
                                + 2 * (xadd (getFIXED (mPRINTSUMMARYxT), 4)),
                            bitRHS);
                        bitRHS->inUse = 0;
                      }
                    // ELSE (14042)
                    else
                      // IF T = 135 THEN (14043)
                      if (1 & (xEQ (getFIXED (mPRINTSUMMARYxT), 135)))
                        // DO; (14044)
                        {
                        rs1s1s1s1s1:;
                          // IF BCB_COUNT > 0 THEN (14045)
                          if (1 & (xGT (COREHALFWORD (mBCB_COUNT), 0)))
                            // OUTPUT = 'BCB   '||X2||BCB_COUNT; (14046)
                            {
                              descriptor_t *stringRHS;
                              stringRHS = xsCAT (
                                  xsCAT (cToDescriptor (NULL, "BCB   "),
                                         getCHARACTER (mX2)),
                                  bitToCharacter (getBIT (16, mBCB_COUNT)));
                              OUTPUT (0, stringRHS);
                              stringRHS->inUse = 0;
                            }
                          // IF (OPCOUNT(T)-BCB_COUNT) > 0 THEN (14047)
                          if (1
                              & (xGT (
                                  xsubtract (
                                      COREHALFWORD (
                                          mOPCOUNT
                                          + 2 * getFIXED (mPRINTSUMMARYxT)),
                                      COREHALFWORD (mBCB_COUNT)),
                                  0)))
                            // OUTPUT = 'BCF   '||X2||(OPCOUNT(T)-BCB_COUNT);
                            // (14048)
                            {
                              descriptor_t *stringRHS;
                              stringRHS = xsCAT (
                                  xsCAT (cToDescriptor (NULL, "BCF   "),
                                         getCHARACTER (mX2)),
                                  fixedToCharacter (xsubtract (
                                      COREHALFWORD (
                                          mOPCOUNT
                                          + 2 * getFIXED (mPRINTSUMMARYxT)),
                                      COREHALFWORD (mBCB_COUNT))));
                              OUTPUT (0, stringRHS);
                              stringRHS->inUse = 0;
                            }
                          // OBJECT_INSTRUCTIONS = OBJECT_INSTRUCTIONS +
                          // OPCOUNT(T); (14049)
                          {
                            int32_t numberRHS = (int32_t)(xadd (
                                getFIXED (mCOMM + 4 * 21),
                                COREHALFWORD (
                                    mOPCOUNT
                                    + 2 * getFIXED (mPRINTSUMMARYxT))));
                            putFIXED (mCOMM + 4 * (21), numberRHS);
                          }
                        es1s1s1s1s1:;
                        } // End of DO block
                      // ELSE (14050)
                      else
                        // DO; (14051)
                        {
                        rs1s1s1s1s2:;
                          // OUTPUT = INSTRUCTION(T) || X2 || OPCOUNT(T);
                          // (14052)
                          {
                            descriptor_t *stringRHS;
                            stringRHS = xsCAT (
                                xsCAT (
                                    (putBITp (16, mINSTRUCTIONxOPCODE,
                                              fixedToBit (
                                                  32, (int32_t)(getFIXED (
                                                          mPRINTSUMMARYxT)))),
                                     INSTRUCTION (0)),
                                    getCHARACTER (mX2)),
                                bitToCharacter (getBIT (
                                    16,
                                    mOPCOUNT
                                        + 2 * getFIXED (mPRINTSUMMARYxT))));
                            OUTPUT (0, stringRHS);
                            stringRHS->inUse = 0;
                          }
                          // OBJECT_INSTRUCTIONS = OBJECT_INSTRUCTIONS +
                          // OPCOUNT(T); (14053)
                          {
                            int32_t numberRHS = (int32_t)(xadd (
                                getFIXED (mCOMM + 4 * 21),
                                COREHALFWORD (
                                    mOPCOUNT
                                    + 2 * getFIXED (mPRINTSUMMARYxT))));
                            putFIXED (mCOMM + 4 * (21), numberRHS);
                          }
                        es1s1s1s1s2:;
                        } // End of DO block
                  es1s1s1s1:;
                  } // End of DO block
              }
          } // End of DO for-loop block
        es1s1:;
        } // End of DO block
      // ELSE (14054)
      else
        // CALL STACK_DUMP; (14055)
        PRINTSUMMARYxSTACK_DUMP (0);
    es1:;
    } // End of DO block
  // OBJECT_MACHINE = 1; (14056)
  {
    int32_t numberRHS = (int32_t)(1);
    putFIXED (mCOMM + 4 * (20), numberRHS);
  }
  // OUTPUT(1) = '-       OPTIONAL TABLE SIZES'; (14057)
  {
    descriptor_t *stringRHS;
    stringRHS = cToDescriptor (NULL, "-       OPTIONAL TABLE SIZES");
    OUTPUT (1, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT(1) = '0NAME       REQUESTED    USED'; (14058)
  {
    descriptor_t *stringRHS;
    stringRHS = cToDescriptor (NULL, "0NAME       REQUESTED    USED");
    OUTPUT (1, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT(1) = '+____       _________    ____'; (14059)
  {
    descriptor_t *stringRHS;
    stringRHS = cToDescriptor (NULL, "+____       _________    ____");
    OUTPUT (1, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT = BLANK; (14060)
  {
    descriptor_t *stringRHS;
    stringRHS = getCHARACTER (mBLANK);
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT = FORM_UP('LITSTRINGS' ,LIT_CHAR_SIZE,LIT_CHAR_USED); (14061)
  {
    descriptor_t *stringRHS;
    stringRHS
        = (putCHARACTERp (mPRINTSUMMARYxFORM_UPxMSG,
                          cToDescriptor (NULL, "LITSTRINGS")),
           putFIXED (mPRINTSUMMARYxFORM_UPxVAL1,
                     getFIXED (getFIXED (mVALS) + 4 * 5)),
           putFIXED (mPRINTSUMMARYxFORM_UPxVAL2, getFIXED (mCOMM + 4 * 1)),
           PRINTSUMMARYxFORM_UP (0));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT = FORM_UP('LABELSIZE ', STATNOLIMIT, STATNO); (14062)
  {
    descriptor_t *stringRHS;
    stringRHS
        = (putCHARACTERp (mPRINTSUMMARYxFORM_UPxMSG,
                          cToDescriptor (NULL, "LABELSIZE ")),
           putFIXED (mPRINTSUMMARYxFORM_UPxVAL1, COREHALFWORD (mSTATNOLIMIT)),
           putFIXED (mPRINTSUMMARYxFORM_UPxVAL2, COREHALFWORD (mSTATNO)),
           PRINTSUMMARYxFORM_UP (0));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT=BLANK; (14063)
  {
    descriptor_t *stringRHS;
    stringRHS = getCHARACTER (mBLANK);
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // IF ERROR# > 0 THEN (14064)
  if (1 & (xGT (COREHALFWORD (mERRORp), 0)))
    // OUTPUT='***  '||ERROR#||' ERROR(S) DETECTED IN PHASE 2'; (14065)
    {
      descriptor_t *stringRHS;
      stringRHS
          = xsCAT (xsCAT (cToDescriptor (NULL, "***  "),
                          bitToCharacter (getBIT (16, mERRORp))),
                   cToDescriptor (NULL, " ERROR(S) DETECTED IN PHASE 2"));
      OUTPUT (0, stringRHS);
      stringRHS->inUse = 0;
    }
  // IF (TOGGLE& 128)=0 THEN (14066)
  if (1 & (xEQ (xAND (getFIXED (mCOMM + 4 * 6), 128), 0)))
    // DO; (14067)
    {
    rs2:;
      // IF MAX_SEVERITY~=0 THEN (14068)
      if (1 & (xNEQ (COREHALFWORD (mMAX_SEVERITY), 0)))
        // OUTPUT= '***  CONVERSION ERRORS INHIBITED OBJECT MODULE GENERATION';
        // (14069)
        {
          descriptor_t *stringRHS;
          stringRHS = cToDescriptor (
              NULL,
              "***  CONVERSION ERRORS INHIBITED OBJECT MODULE GENERATION");
          OUTPUT (0, stringRHS);
          stringRHS->inUse = 0;
        }
    es2:;
    } // End of DO block
  // ELSE (14070)
  else
    // DO; (14071)
    {
    rs3:;
      // MAX_SEVERITY=3; (14072)
      {
        int32_t numberRHS = (int32_t)(3);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mMAX_SEVERITY, bitRHS);
        bitRHS->inUse = 0;
      }
      // OUTPUT='***  PHASE 1 INHIBITED EXECUTION'; (14073)
      {
        descriptor_t *stringRHS;
        stringRHS = cToDescriptor (NULL, "***  PHASE 1 INHIBITED EXECUTION");
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
    es3:;
    } // End of DO block
  // IF MAX_SEVERITY = 0 THEN (14074)
  if (1 & (xEQ (COREHALFWORD (mMAX_SEVERITY), 0)))
    // DO; (14075)
    {
    rs4:;
      // OUTPUT=BLANK; (14076)
      {
        descriptor_t *stringRHS;
        stringRHS = getCHARACTER (mBLANK);
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
      // OBJECT_MODULE_NAME = 'OBJECT MODULE MEMBER ' || OBJECT_MODULE_NAME ||
      // ' HAS BEEN '; (14077)
      {
        descriptor_t *stringRHS;
        stringRHS
            = xsCAT (xsCAT (cToDescriptor (NULL, "OBJECT MODULE MEMBER "),
                            getCHARACTER (mOBJECT_MODULE_NAME)),
                     cToDescriptor (NULL, " HAS BEEN "));
        putCHARACTER (mOBJECT_MODULE_NAME, stringRHS);
        stringRHS->inUse = 0;
      }
      // IF (OBJECT_MODULE_STATUS & 1) ~= 0 THEN (14078)
      if (1 & (xNEQ (xAND (BYTE0 (mOBJECT_MODULE_STATUS), 1), 0)))
        // OBJECT_MODULE_NAME = OBJECT_MODULE_NAME || REPLACED ; (14079)
        {
          descriptor_t *stringRHS;
          stringRHS = xsCAT (getCHARACTER (mOBJECT_MODULE_NAME),
                             getCHARACTER (mPRINTSUMMARYxREPLACED));
          putCHARACTER (mOBJECT_MODULE_NAME, stringRHS);
          stringRHS->inUse = 0;
        }
      // ELSE (14080)
      else
        // OBJECT_MODULE_NAME = OBJECT_MODULE_NAME || 'CREATED'; (14081)
        {
          descriptor_t *stringRHS;
          stringRHS = xsCAT (getCHARACTER (mOBJECT_MODULE_NAME),
                             cToDescriptor (NULL, "CREATED"));
          putCHARACTER (mOBJECT_MODULE_NAME, stringRHS);
          stringRHS->inUse = 0;
        }
      // OUTPUT = BLANK; (14082)
      {
        descriptor_t *stringRHS;
        stringRHS = getCHARACTER (mBLANK);
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
      // IF PCEBASE THEN (14083)
      if (1 & (bitToFixed (getBIT (16, mPCEBASE))))
        // DO; (14084)
        {
        rs4s1:;
          // OUTPUT = OBJECT_MODULE_NAME; (14085)
          {
            descriptor_t *stringRHS;
            stringRHS = getCHARACTER (mOBJECT_MODULE_NAME);
            OUTPUT (0, stringRHS);
            stringRHS->inUse = 0;
          }
          // OBJECT_MODULE_NAME = SUBSTR(OBJECT_MODULE_NAME, 0, 21) ||POUND_Z||
          // SUBSTR(OBJECT_MODULE_NAME,23,16); (14086)
          {
            descriptor_t *stringRHS;
            stringRHS = xsCAT (
                xsCAT (SUBSTR (getCHARACTER (mOBJECT_MODULE_NAME), 0, 21),
                       getCHARACTER (mPOUND_Z)),
                SUBSTR (getCHARACTER (mOBJECT_MODULE_NAME), 23, 16));
            putCHARACTER (mOBJECT_MODULE_NAME, stringRHS);
            stringRHS->inUse = 0;
          }
          // IF (OBJECT_MODULE_STATUS & 2) ~= 0 THEN (14087)
          if (1 & (xNEQ (xAND (BYTE0 (mOBJECT_MODULE_STATUS), 2), 0)))
            // OBJECT_MODULE_NAME = OBJECT_MODULE_NAME|| REPLACED; (14088)
            {
              descriptor_t *stringRHS;
              stringRHS = xsCAT (getCHARACTER (mOBJECT_MODULE_NAME),
                                 getCHARACTER (mPRINTSUMMARYxREPLACED));
              putCHARACTER (mOBJECT_MODULE_NAME, stringRHS);
              stringRHS->inUse = 0;
            }
          // ELSE (14089)
          else
            // OBJECT_MODULE_NAME = OBJECT_MODULE_NAME || CREATED; (14090)
            {
              descriptor_t *stringRHS;
              stringRHS = xsCAT (getCHARACTER (mOBJECT_MODULE_NAME),
                                 getCHARACTER (mPRINTSUMMARYxCREATED));
              putCHARACTER (mOBJECT_MODULE_NAME, stringRHS);
              stringRHS->inUse = 0;
            }
        es4s1:;
        } // End of DO block
      // OUTPUT = OBJECT_MODULE_NAME; (14091)
      {
        descriptor_t *stringRHS;
        stringRHS = getCHARACTER (mOBJECT_MODULE_NAME);
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
      // OUTPUT = BLANK; (14092)
      {
        descriptor_t *stringRHS;
        stringRHS = getCHARACTER (mBLANK);
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
      // OUTPUT=PP||' HALMAT OPERATORS CONVERTED'; (14093)
      {
        descriptor_t *stringRHS;
        stringRHS
            = xsCAT (fixedToCharacter (getFIXED (mPP)),
                     cToDescriptor (NULL, " HALMAT OPERATORS CONVERTED"));
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
      // OUTPUT = BLANK; (14094)
      {
        descriptor_t *stringRHS;
        stringRHS = getCHARACTER (mBLANK);
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
      // OUTPUT = OBJECT_INSTRUCTIONS || ' INSTRUCTIONS GENERATED'; (14095)
      {
        descriptor_t *stringRHS;
        stringRHS = xsCAT (fixedToCharacter (getFIXED (mCOMM + 4 * 21)),
                           cToDescriptor (NULL, " INSTRUCTIONS GENERATED"));
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
      // OUTPUT=BLANK; (14096)
      {
        descriptor_t *stringRHS;
        stringRHS = getCHARACTER (mBLANK);
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
      // OUTPUT = PROGCODE || ' HALFWORDS OF PROGRAM, ' ||
      // PROGDATA+PROGDATA(1)||' HALFWORDS OF DATA.'; (14097)
      {
        descriptor_t *stringRHS;
        stringRHS = xsCAT (
            xsCAT (xsCAT (fixedToCharacter (getFIXED (mPROGCODE)),
                          cToDescriptor (NULL, " HALFWORDS OF PROGRAM, ")),
                   fixedToCharacter (xadd (getFIXED (mPROGDATA),
                                           getFIXED (mPROGDATA + 4 * 1)))),
            cToDescriptor (NULL, " HALFWORDS OF DATA."));
        OUTPUT (0, stringRHS);
        stringRHS->inUse = 0;
      }
    es4:;
    } // End of DO block
  // OUTPUT = BLANK; (14098)
  {
    descriptor_t *stringRHS;
    stringRHS = getCHARACTER (mBLANK);
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT='MAX. OPERAND STACK SIZE            ='||STACK_MAX; (14099)
  {
    descriptor_t *stringRHS;
    stringRHS
        = xsCAT (cToDescriptor (NULL, "MAX. OPERAND STACK SIZE            ="),
                 bitToCharacter (getBIT (16, mSTACK_MAX)));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // T=0; (14100)
  {
    int32_t numberRHS = (int32_t)(0);
    putFIXED (mPRINTSUMMARYxT, numberRHS);
  }
  // DO WHILE STACK_PTR~=0; (14101)
  while (1 & (xNEQ (COREHALFWORD (mSTACK_PTR), 0)))
    {
      // STACK_PTR = STACK_PTR(STACK_PTR); (14102)
      {
        descriptor_t *bitRHS
            = getBIT (16, mSTACK_PTR + 2 * COREHALFWORD (mSTACK_PTR));
        putBIT (16, mSTACK_PTR, bitRHS);
        bitRHS->inUse = 0;
      }
      // T=T+1; (14103)
      {
        int32_t numberRHS = (int32_t)(xadd (getFIXED (mPRINTSUMMARYxT), 1));
        putFIXED (mPRINTSUMMARYxT, numberRHS);
      }
      // IF T > STACK_SIZE THEN (14104)
      if (1 & (xGT (getFIXED (mPRINTSUMMARYxT), 100)))
        // DO; (14105)
        {
        rs5s1:;
          // CALL ERRORS(CLASS_BI,504); (14106)
          {
            putBITp (16, mERRORSxCLASS, getBIT (8, mCLASS_BI));
            putBITp (16, mERRORSxNUM, fixedToBit (32, (int32_t)(504)));
            ERRORS (0);
          }
          // STACK_PTR = 0; (14107)
          {
            int32_t numberRHS = (int32_t)(0);
            descriptor_t *bitRHS;
            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
            putBIT (16, mSTACK_PTR, bitRHS);
            bitRHS->inUse = 0;
          }
        es5s1:;
        } // End of DO block
    }     // End of DO WHILE block
  // OUTPUT='END  OPERAND STACK SIZE            ='||STACK_SIZE-T; (14108)
  {
    descriptor_t *stringRHS;
    stringRHS = xsCAT (
        cToDescriptor (NULL, "END  OPERAND STACK SIZE            ="),
        fixedToCharacter (xsubtract (100, getFIXED (mPRINTSUMMARYxT))));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT='MAX. STORAGE DESCRIPTOR STACK SIZE ='||FULLTEMP; (14109)
  {
    descriptor_t *stringRHS;
    stringRHS
        = xsCAT (cToDescriptor (NULL, "MAX. STORAGE DESCRIPTOR STACK SIZE ="),
                 bitToCharacter (getBIT (16, mFULLTEMP)));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // T = 0; (14110)
  {
    int32_t numberRHS = (int32_t)(0);
    putFIXED (mPRINTSUMMARYxT, numberRHS);
  }
  // DO FOR TMP = 0 TO FULLTEMP; (14111)
  {
    int32_t from131, to131, by131;
    from131 = 0;
    to131 = bitToFixed (getBIT (16, mFULLTEMP));
    by131 = 1;
    for (putFIXED (mTMP, from131); getFIXED (mTMP) <= to131;
         putFIXED (mTMP, getFIXED (mTMP) + by131))
      {
        // IF UPPER(TMP) > 0 THEN (14112)
        if (1 & (xGT (getFIXED (mUPPER + 4 * getFIXED (mTMP)), 0)))
          // T = T + 1; (14113)
          {
            int32_t numberRHS
                = (int32_t)(xadd (getFIXED (mPRINTSUMMARYxT), 1));
            putFIXED (mPRINTSUMMARYxT, numberRHS);
          }
      }
  } // End of DO for-loop block
  // CALL DOWNGRADE_SUMMARY; (14114)
  DOWNGRADE_SUMMARY (0);
  // OUTPUT='END  STORAGE DESCRIPTOR STACK SIZE ='||T; (14115)
  {
    descriptor_t *stringRHS;
    stringRHS
        = xsCAT (cToDescriptor (NULL, "END  STORAGE DESCRIPTOR STACK SIZE ="),
                 fixedToCharacter (getFIXED (mPRINTSUMMARYxT)));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT='EXTERNAL SYMBOL DICTIONARY MAXIMUM ='||ESD_MAX; (14116)
  {
    descriptor_t *stringRHS;
    stringRHS
        = xsCAT (cToDescriptor (NULL, "EXTERNAL SYMBOL DICTIONARY MAXIMUM ="),
                 bitToCharacter (getBIT (16, mESD_MAX)));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT='NUMBER OF MINOR COMPACTIFIES       ='||COMPACTIFIES; (14117)
  {
    descriptor_t *stringRHS;
    stringRHS
        = xsCAT (cToDescriptor (NULL, "NUMBER OF MINOR COMPACTIFIES       ="),
                 bitToCharacter (getBIT (16, mCOMPACTIFIES)));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT='NUMBER OF MAJOR COMPACTIFIES       ='||COMPACTIFIES(1); (14118)
  {
    descriptor_t *stringRHS;
    stringRHS
        = xsCAT (cToDescriptor (NULL, "NUMBER OF MAJOR COMPACTIFIES       ="),
                 bitToCharacter (getBIT (16, mCOMPACTIFIES + 2 * 1)));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT = 'NUMBER OF REALLOCATIONS            ='||REALLOCATIONS; (14119)
  {
    descriptor_t *stringRHS;
    stringRHS
        = xsCAT (cToDescriptor (NULL, "NUMBER OF REALLOCATIONS            ="),
                 bitToCharacter (getBIT (16, mREALLOCATIONS)));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT='FREE STRING AREA                   ='||FREELIMIT-FREEBASE; (14120)
  {
    descriptor_t *stringRHS;
    stringRHS
        = xsCAT (cToDescriptor (NULL, "FREE STRING AREA                   ="),
                 fixedToCharacter (xsubtract (FREELIMIT (), FREEBASE ())));
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // OUTPUT=BLANK; (14121)
  {
    descriptor_t *stringRHS;
    stringRHS = getCHARACTER (mBLANK);
    OUTPUT (0, stringRHS);
    stringRHS->inUse = 0;
  }
  // T = MONITOR(18); (14122)
  {
    int32_t numberRHS = (int32_t)(MONITOR18 ());
    putFIXED (mPRINTSUMMARYxT, numberRHS);
  }
  // IF CLOCK(1) = 0 THEN (14123)
  if (1 & (xEQ (getFIXED (mCLOCK + 4 * 1), 0)))
    // CLOCK(1), CLOCK(2) = T; (14124)
    {
      int32_t numberRHS = (int32_t)(getFIXED (mPRINTSUMMARYxT));
      putFIXED (mCLOCK + 4 * (1), numberRHS);
      putFIXED (mCLOCK + 4 * (2), numberRHS);
    }
  // ELSE (14125)
  else
    // IF CLOCK(2) = 0 THEN (14126)
    if (1 & (xEQ (getFIXED (mCLOCK + 4 * 2), 0)))
      // CLOCK(2) = T; (14127)
      {
        int32_t numberRHS = (int32_t)(getFIXED (mPRINTSUMMARYxT));
        putFIXED (mCLOCK + 4 * (2), numberRHS);
      }
  // CALL PRINT_DATE_AND_TIME('END OF HAL/S PHASE 2 ',DATE,TIME); (14128)
  {
    putCHARACTERp (mPRINT_DATE_AND_TIMExMESSAGE,
                   cToDescriptor (NULL, "END OF HAL/S PHASE 2 "));
    putFIXED (mPRINT_DATE_AND_TIMExD, DATE ());
    putFIXED (mPRINT_DATE_AND_TIMExT, TIME ());
    PRINT_DATE_AND_TIME (0);
  }
  // CALL PRINT_TIME('TOTAL CPU TIME FOR PHASE 2       ', T-CLOCK); (14129)
  {
    putCHARACTERp (mPRINT_TIMExMESSAGE,
                   cToDescriptor (NULL, "TOTAL CPU TIME FOR PHASE 2       "));
    putFIXED (mPRINT_TIMExT,
              xsubtract (getFIXED (mPRINTSUMMARYxT), getFIXED (mCLOCK)));
    PRINT_TIME (0);
  }
  // CALL PRINT_TIME('CPU TIME FOR PHASE 2 SET UP      ', CLOCK(1)-CLOCK);
  // (14130)
  {
    putCHARACTERp (mPRINT_TIMExMESSAGE,
                   cToDescriptor (NULL, "CPU TIME FOR PHASE 2 SET UP      "));
    putFIXED (mPRINT_TIMExT,
              xsubtract (getFIXED (mCLOCK + 4 * 1), getFIXED (mCLOCK)));
    PRINT_TIME (0);
  }
  // CALL PRINT_TIME('CPU TIME FOR PHASE 2 GENERATION  ', CLOCK(2)-CLOCK(1));
  // (14131)
  {
    putCHARACTERp (mPRINT_TIMExMESSAGE,
                   cToDescriptor (NULL, "CPU TIME FOR PHASE 2 GENERATION  "));
    putFIXED (mPRINT_TIMExT, xsubtract (getFIXED (mCLOCK + 4 * 2),
                                        getFIXED (mCLOCK + 4 * 1)));
    PRINT_TIME (0);
  }
  // CALL PRINT_TIME('CPU TIME FOR PHASE 2 CLEAN UP    ', T-CLOCK(2)); (14132)
  {
    putCHARACTERp (mPRINT_TIMExMESSAGE,
                   cToDescriptor (NULL, "CPU TIME FOR PHASE 2 CLEAN UP    "));
    putFIXED (mPRINT_TIMExT, xsubtract (getFIXED (mPRINTSUMMARYxT),
                                        getFIXED (mCLOCK + 4 * 2)));
    PRINT_TIME (0);
  }
  {
    reentryGuard = 0;
    return 0;
  }
}
