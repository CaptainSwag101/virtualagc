/*
  File CHECK_INVAR.c generated by XCOM-I, 2024-08-09 12:38:53.
*/

#include "runtimeC.h"

descriptor_t *
CHECK_INVAR (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (descriptor_t *)0;
    }
  reentryGuard = guardReentry (reentryGuard, "CHECK_INVAR");
  // IF I_TRACE THEN (5286)
  if (1 & (bitToFixed (getBIT (8, mSTACK_TRACE))))
    // OUTPUT = 'CHECK_INVAR(' || AR_INV || '):  ' || NODE_BEGINNING; (5287)
    {
      descriptor_t *stringRHS;
      stringRHS = xsCAT (
          xsCAT (xsCAT (cToDescriptor (NULL, "CHECK_INVAR("),
                        bitToCharacter (getBIT (8, mCHECK_INVARxAR_INV))),
                 cToDescriptor (NULL, "):  ")),
          bitToCharacter (getBIT (16, mNODE_BEGINNING)));
      OUTPUT (0, stringRHS);
      stringRHS->inUse = 0;
    }
  // CSE_FOUND_INX = 0; (5288)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mCSE_FOUND_INX, bitRHS);
    bitRHS->inUse = 0;
  }
  // INX = NODE_BEGINNING - 1; (5289)
  {
    int32_t numberRHS
        = (int32_t)(xsubtract (COREHALFWORD (mNODE_BEGINNING), 1));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mCHECK_INVARxINX, bitRHS);
    bitRHS->inUse = 0;
  }
  // FORCE_PULL = FALSE; (5290)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (8, mCHECK_INVARxFORCE_PULL, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF AR_INV THEN (5291)
  if (1 & (bitToFixed (getBIT (8, mCHECK_INVARxAR_INV))))
    // IF (NODE(NODE_BEGINNING) &  65535) = EXTN THEN (5292)
    if (1
        & (xEQ (xAND (getFIXED (mNODE + 4 * COREHALFWORD (mNODE_BEGINNING)),
                      65535),
                COREHALFWORD (mEXTN))))
      // DO; (5293)
      {
      rs1:;
        // TEMP = GET_EON(INX) + 1; (5294)
        {
          int32_t numberRHS = (int32_t)(xadd (
              (putBITp (16, mGET_EONxPTR, getBIT (16, mCHECK_INVARxINX)),
               GET_EON (0)),
              1));
          descriptor_t *bitRHS;
          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
          putBIT (16, mCHECK_INVARxTEMP, bitRHS);
          bitRHS->inUse = 0;
        }
        // FORCE_PULL = ARRAYED_ELT(NODE(TEMP),NODE2(TEMP)) = 0; (5295)
        {
          int32_t numberRHS = (int32_t)(xEQ (
              bitToFixed ((
                  putFIXED (
                      mARRAYED_ELTxNODE_WORD,
                      getFIXED (mNODE + 4 * COREHALFWORD (mCHECK_INVARxTEMP))),
                  putBITp (
                      16, mARRAYED_ELTxNODE2_WORD,
                      getBIT (16,
                              mNODE2 + 2 * COREHALFWORD (mCHECK_INVARxTEMP))),
                  ARRAYED_ELT (0))),
              0));
          descriptor_t *bitRHS;
          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
          putBIT (8, mCHECK_INVARxFORCE_PULL, bitRHS);
          bitRHS->inUse = 0;
        }
      es1:;
      } // End of DO block
    // ELSE (5296)
    else
      // IF NODE(NODE_BEGINNING) = DSUB  THEN (5297)
      if (1
          & (xEQ (getFIXED (mNODE + 4 * COREHALFWORD (mNODE_BEGINNING)),
                  COREHALFWORD (mDSUB))))
        // FORCE_PULL = TRUE; (5298)
        {
          int32_t numberRHS = (int32_t)(1);
          descriptor_t *bitRHS;
          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
          putBIT (8, mCHECK_INVARxFORCE_PULL, bitRHS);
          bitRHS->inUse = 0;
        }
  // DO WHILE NODE(INX) ~= END_OF_NODE; (5299)
  while (1
         & (xNEQ (getFIXED (mNODE + 4 * COREHALFWORD (mCHECK_INVARxINX)),
                  getFIXED (mEND_OF_NODE))))
    {
      // IF FORCE_PULL THEN (5300)
      if (1 & (bitToFixed (getBIT (8, mCHECK_INVARxFORCE_PULL))))
        // CALL BUMP_CSE; (5301)
        CHECK_INVARxBUMP_CSE (0);
      // ELSE (5302)
      else
        // IF INVAR(NODE(INX),NODE2(INX),AR_INV) THEN (5303)
        if (1
            & (bitToFixed ((
                putFIXED (
                    mINVARxNODE_WORD,
                    getFIXED (mNODE + 4 * COREHALFWORD (mCHECK_INVARxINX))),
                putBITp (
                    16, mINVARxNODE2_WORD,
                    getBIT (16, mNODE2 + 2 * COREHALFWORD (mCHECK_INVARxINX))),
                putBITp (8, mINVARxAR_INV, getBIT (8, mCHECK_INVARxAR_INV)),
                INVAR (0)))))
          // DO; (5304)
          {
          rs2s1:;
            // CALL BUMP_CSE; (5305)
            CHECK_INVARxBUMP_CSE (0);
          es2s1:;
          } // End of DO block
      // INX = INX - 1; (5306)
      {
        int32_t numberRHS
            = (int32_t)(xsubtract (COREHALFWORD (mCHECK_INVARxINX), 1));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mCHECK_INVARxINX, bitRHS);
        bitRHS->inUse = 0;
      }
    } // End of DO WHILE block
  // IF CSE_FOUND_INX >= 2 & ~NONCOMMUTATIVE OR NONCOMMUTATIVE & CSE_FOUND_INX
  // = NODE_BEGINNING - INX - 1 THEN (5307)
  if (1
      & (xOR (
          xAND (xGE (COREHALFWORD (mCSE_FOUND_INX), 2),
                xNOT (BYTE0 (mNONCOMMUTATIVE))),
          xAND (BYTE0 (mNONCOMMUTATIVE),
                xEQ (COREHALFWORD (mCSE_FOUND_INX),
                     xsubtract (xsubtract (COREHALFWORD (mNODE_BEGINNING),
                                           COREHALFWORD (mCHECK_INVARxINX)),
                                1))))))
    // DO; (5308)
    {
    rs3:;
      // CALL BUMP_CSE; (5309)
      CHECK_INVARxBUMP_CSE (0);
      // TWIN_MATCH,REVERSE = FALSE; (5310)
      {
        int32_t numberRHS = (int32_t)(0);
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (8, mTWIN_MATCH, bitRHS);
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (8, mREVERSE, bitRHS);
        bitRHS->inUse = 0;
      }
      // PREVIOUS_NODE_PTR,PRESENT_NODE_PTR = INX - 1; (5311)
      {
        int32_t numberRHS
            = (int32_t)(xsubtract (COREHALFWORD (mCHECK_INVARxINX), 1));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mPREVIOUS_NODE_PTR, bitRHS);
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mPRESENT_NODE_PTR, bitRHS);
        bitRHS->inUse = 0;
      }
      // PREVIOUS_HALMAT,PRESENT_HALMAT = NODE(PRESENT_NODE_PTR) &  65535;
      // (5312)
      {
        int32_t numberRHS = (int32_t)(xAND (
            getFIXED (mNODE + 4 * COREHALFWORD (mPRESENT_NODE_PTR)), 65535));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mPREVIOUS_HALMAT, bitRHS);
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mPRESENT_HALMAT, bitRHS);
        bitRHS->inUse = 0;
      }
      // PREVIOUS_NODE_OPERAND = NODE_BEGINNING - 1; (5313)
      {
        int32_t numberRHS
            = (int32_t)(xsubtract (COREHALFWORD (mNODE_BEGINNING), 1));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mPREVIOUS_NODE_OPERAND, bitRHS);
        bitRHS->inUse = 0;
      }
      // PREVIOUS_NODE = NODE_BEGINNING; (5314)
      {
        descriptor_t *bitRHS = getBIT (16, mNODE_BEGINNING);
        putBIT (16, mPREVIOUS_NODE, bitRHS);
        bitRHS->inUse = 0;
      }
      // IF AR_INV THEN (5315)
      if (1 & (bitToFixed (getBIT (8, mCHECK_INVARxAR_INV))))
        // OLD_LEVEL = LEVEL; (5316)
        {
          descriptor_t *bitRHS = getBIT (16, mLEVEL);
          putBIT (16, mOLD_LEVEL, bitRHS);
          bitRHS->inUse = 0;
        }
      // ELSE (5317)
      else
        // OLD_LEVEL = LEV-1; (5318)
        {
          int32_t numberRHS = (int32_t)(xsubtract (COREHALFWORD (mLEV), 1));
          descriptor_t *bitRHS;
          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
          putBIT (16, mOLD_LEVEL, bitRHS);
          bitRHS->inUse = 0;
        }
      // OLD_BLOCK# =STACKED_BLOCK#(OLD_LEVEL); (5319)
      {
        descriptor_t *bitRHS = getBIT (
            16, getFIXED (mLEVEL_STACK_VARS) + 11 * (COREHALFWORD (mOLD_LEVEL))
                    + 8 + 2 * (0));
        putBIT (16, mOLD_BLOCKp, bitRHS);
        bitRHS->inUse = 0;
      }
      // IF I_TRACE THEN (5320)
      if (1 & (bitToFixed (getBIT (8, mSTACK_TRACE))))
        // DO; (5321)
        {
        rs3s1:;
          // OUTPUT = '   PREVIOUS_NODE_PTR=' || PREVIOUS_NODE_PTR || ',
          // PREVIOUS_NODE=' || PREVIOUS_NODE ; (5322)
          {
            descriptor_t *stringRHS;
            stringRHS = xsCAT (
                xsCAT (
                    xsCAT (cToDescriptor (NULL, "   PREVIOUS_NODE_PTR="),
                           bitToCharacter (getBIT (16, mPREVIOUS_NODE_PTR))),
                    cToDescriptor (NULL, ", PREVIOUS_NODE=")),
                bitToCharacter (getBIT (16, mPREVIOUS_NODE)));
            OUTPUT (0, stringRHS);
            stringRHS->inUse = 0;
          }
          // OUTPUT = '   OLD_LEVEL='||OLD_LEVEL||', OLD_BLOCK#=' ||
          // OLD_BLOCK#; (5323)
          {
            descriptor_t *stringRHS;
            stringRHS = xsCAT (
                xsCAT (xsCAT (cToDescriptor (NULL, "   OLD_LEVEL="),
                              bitToCharacter (getBIT (16, mOLD_LEVEL))),
                       cToDescriptor (NULL, ", OLD_BLOCK#=")),
                bitToCharacter (getBIT (16, mOLD_BLOCKp)));
            OUTPUT (0, stringRHS);
            stringRHS->inUse = 0;
          }
        es3s1:;
        } // End of DO block
      // RETURN TRUE; (5324)
      {
        reentryGuard = 0;
        return fixedToBit (32, (int32_t)(1));
      }
    es3:;
    } // End of DO block
  // RETURN FALSE; (5325)
  {
    reentryGuard = 0;
    return fixedToBit (32, (int32_t)(0));
  }
}
