/*
  File PREPARE_HALMAT.c generated by XCOM-I, 2024-08-09 12:38:53.
*/

#include "runtimeC.h"

int32_t
PREPARE_HALMAT (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "PREPARE_HALMAT");
  // ROOM = 0; (1307)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mROOM, bitRHS);
    bitRHS->inUse = 0;
  }
  // RESET=CTR; (1308)
  {
    descriptor_t *bitRHS = getBIT (16, mCTR);
    putBIT (16, mRESET, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF BLOCK_FLAG THEN (1309)
  if (1 & (bitToFixed (getBIT (1, mPREPARE_HALMATxBLOCK_FLAG))))
    // SMRK_CTR, NEW = CTR; (1310)
    {
      descriptor_t *bitRHS = getBIT (16, mCTR);
      putBIT (16, mSMRK_CTR, bitRHS);
      putBIT (16, mPREPARE_HALMATxNEW, bitRHS);
      bitRHS->inUse = 0;
    }
  // ELSE (1311)
  else
    // SMRK_CTR, NEW = CTR + NUMOP + 1; (1312)
    {
      int32_t numberRHS = (int32_t)(xadd (
          xadd (COREHALFWORD (mCTR), COREHALFWORD (mNUMOP)), 1));
      descriptor_t *bitRHS;
      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
      putBIT (16, mSMRK_CTR, bitRHS);
      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
      putBIT (16, mPREPARE_HALMATxNEW, bitRHS);
      bitRHS->inUse = 0;
    }
  // LAST_SMRK = SMRK_CTR; (1313)
  {
    descriptor_t *bitRHS = getBIT (16, mSMRK_CTR);
    putBIT (16, mLAST_SMRK, bitRHS);
    bitRHS->inUse = 0;
  }
  // CALL OPDECODE(SMRK_CTR); (1314)
  {
    putBITp (16, mPREPARE_HALMATxOPDECODExCTR, getBIT (16, mSMRK_CTR));
    PREPARE_HALMATxOPDECODE (0);
  }
  // NOT_XREC = TRUE; (1315)
  {
    int32_t numberRHS = (int32_t)(1);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (8, mNOT_XREC, bitRHS);
    bitRHS->inUse = 0;
  }
  // DO WHILE OPRTR ~= XSMRK; (1316)
  while (
      1 & (xNEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR), COREHALFWORD (mXSMRK))))
    {
      // IF OPRTR=XXREC THEN (1317)
      if (1
          & (xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                  COREHALFWORD (mXXREC))))
        // DO; (1318)
        {
        rs1s1:;
          // NOT_XREC = FALSE; (1319)
          {
            int32_t numberRHS = (int32_t)(0);
            descriptor_t *bitRHS;
            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
            putBIT (8, mNOT_XREC, bitRHS);
            bitRHS->inUse = 0;
          }
          // RETURN; (1320)
          {
            reentryGuard = 0;
            return 0;
          }
        es1s1:;
        } // End of DO block
      // SMRK_CTR=SMRK_CTR+OPNUM+1; (1321)
      {
        int32_t numberRHS
            = (int32_t)(xadd (xadd (COREHALFWORD (mSMRK_CTR),
                                    COREHALFWORD (mPREPARE_HALMATxOPNUM)),
                              1));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mSMRK_CTR, bitRHS);
        bitRHS->inUse = 0;
      }
      // CALL OPDECODE(SMRK_CTR); (1322)
      {
        putBITp (16, mPREPARE_HALMATxOPDECODExCTR, getBIT (16, mSMRK_CTR));
        PREPARE_HALMATxOPDECODE (0);
      }
    } // End of DO WHILE block
  // STT# = SHR(OPR(SMRK_CTR + 1),16); (1323)
  {
    int32_t numberRHS = (int32_t)(SHR (
        getFIXED (mOPR + 4 * xadd (COREHALFWORD (mSMRK_CTR), 1)), 16));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mSTTp, bitRHS);
    bitRHS->inUse = 0;
  }
  // CTR = NEW; (1324)
  {
    descriptor_t *bitRHS = getBIT (16, mPREPARE_HALMATxNEW);
    putBIT (16, mCTR, bitRHS);
    bitRHS->inUse = 0;
  }
  // NEST_LEVEL, FUNC_LEVEL, NESTFUNC = 0; (1325)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mPREPARE_HALMATxNEST_LEVEL, bitRHS);
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mFUNC_LEVEL, bitRHS);
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mNESTFUNC, bitRHS);
    bitRHS->inUse = 0;
  }
  // IFLAG = 0; (1326)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (1, mPREPARE_HALMATxIFLAG, bitRHS);
    bitRHS->inUse = 0;
  }
  // DO WHILE CTR < SMRK_CTR; (1327)
  while (1 & (xLT (COREHALFWORD (mCTR), COREHALFWORD (mSMRK_CTR))))
    {
      // CALL OPDECODE(CTR); (1328)
      {
        putBITp (16, mPREPARE_HALMATxOPDECODExCTR, getBIT (16, mCTR));
        PREPARE_HALMATxOPDECODE (0);
      }
      // IF OPRTR = XNOP THEN (1329)
      if (1
          & (xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR), COREHALFWORD (mXNOP))))
        // DO; (1330)
        {
        rs2s1:;
          // CTR = CTR + OPNUM + 1; (1331)
          {
            int32_t numberRHS
                = (int32_t)(xadd (xadd (COREHALFWORD (mCTR),
                                        COREHALFWORD (mPREPARE_HALMATxOPNUM)),
                                  1));
            descriptor_t *bitRHS;
            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
            putBIT (16, mCTR, bitRHS);
            bitRHS->inUse = 0;
          }
          // IF CTR = SMRK_CTR THEN (1332)
          if (1 & (xEQ (COREHALFWORD (mCTR), COREHALFWORD (mSMRK_CTR))))
            // ROOM = OPNUM + 1; (1333)
            {
              int32_t numberRHS
                  = (int32_t)(xadd (COREHALFWORD (mPREPARE_HALMATxOPNUM), 1));
              descriptor_t *bitRHS;
              bitRHS = fixedToBit (32, (int32_t)(numberRHS));
              putBIT (16, mROOM, bitRHS);
              bitRHS->inUse = 0;
            }
        es2s1:;
        } // End of DO block
      // ELSE (1334)
      else
        // IF OPRTR = XSFST | OPRTR = XXXST THEN (1335)
        if (1
            & (xOR (xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                         COREHALFWORD (mXSFST)),
                    xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                         COREHALFWORD (mXXXST)))))
          // DO; (1336)
          {
          rs2s2:;
            // NEST_LEVEL(OPTAG) = NEST_LEVEL; (1337)
            {
              descriptor_t *bitRHS = getBIT (16, mPREPARE_HALMATxNEST_LEVEL);
              putBIT (16,
                      mPREPARE_HALMATxNEST_LEVEL
                          + 2 * (COREHALFWORD (mPREPARE_HALMATxOPTAG)),
                      bitRHS);
              bitRHS->inUse = 0;
            }
            // NEST_LEVEL = OPTAG; (1338)
            {
              descriptor_t *bitRHS = getBIT (16, mPREPARE_HALMATxOPTAG);
              putBIT (16, mPREPARE_HALMATxNEST_LEVEL, bitRHS);
              bitRHS->inUse = 0;
            }
            // IF NEST_LEVEL > 0 THEN (1339)
            if (1 & (xGT (COREHALFWORD (mPREPARE_HALMATxNEST_LEVEL), 0)))
              // START(NEST_LEVEL) = CTR; (1340)
              {
                descriptor_t *bitRHS = getBIT (16, mCTR);
                putBIT (16,
                        mPREPARE_HALMATxSTART
                            + 2 * (COREHALFWORD (mPREPARE_HALMATxNEST_LEVEL)),
                        bitRHS);
                bitRHS->inUse = 0;
              }
            // GO TO CHECK_NEW; (1341)
            goto CHECK_NEW;
          es2s2:;
          } // End of DO block
        // ELSE (1342)
        else
          // IF OPRTR = XSFND | OPRTR = XXXND THEN (1343)
          if (1
              & (xOR (xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                           COREHALFWORD (mXSFND)),
                      xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                           COREHALFWORD (mXXXND)))))
            // DO; (1344)
            {
            rs2s3:;
              // FLAG_LOC = START(OPTAG); (1345)
              {
                descriptor_t *bitRHS = getBIT (
                    16, mPREPARE_HALMATxSTART
                            + 2 * COREHALFWORD (mPREPARE_HALMATxOPTAG));
                putBIT (16, mPREPARE_HALMATxFLAG_LOC, bitRHS);
                bitRHS->inUse = 0;
              }
              // IF OPTAG > 0 THEN (1346)
              if (1 & (xGT (COREHALFWORD (mPREPARE_HALMATxOPTAG), 0)))
                // IF OPCOPT = XN THEN (1347)
                if (1
                    & (xEQ (COREHALFWORD (mPREPARE_HALMATxOPCOPT),
                            COREHALFWORD (mXN))))
                  // OPR(FLAG_LOC) = OPR(FLAG_LOC) | NEGMAX; (1348)
                  {
                    int32_t numberRHS = (int32_t)(xOR (
                        getFIXED (
                            mOPR
                            + 4 * COREHALFWORD (mPREPARE_HALMATxFLAG_LOC)),
                        getFIXED (mNEGMAX)));
                    putFIXED (
                        mOPR + 4 * (COREHALFWORD (mPREPARE_HALMATxFLAG_LOC)),
                        numberRHS);
                  }
              // NEST_LEVEL = NEST_LEVEL(OPTAG); (1349)
              {
                descriptor_t *bitRHS = getBIT (
                    16, mPREPARE_HALMATxNEST_LEVEL
                            + 2 * COREHALFWORD (mPREPARE_HALMATxOPTAG));
                putBIT (16, mPREPARE_HALMATxNEST_LEVEL, bitRHS);
                bitRHS->inUse = 0;
              }
              // CTR = CTR + OPNUM + 1; (1350)
              {
                int32_t numberRHS = (int32_t)(xadd (
                    xadd (COREHALFWORD (mCTR),
                          COREHALFWORD (mPREPARE_HALMATxOPNUM)),
                    1));
                descriptor_t *bitRHS;
                bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                putBIT (16, mCTR, bitRHS);
                bitRHS->inUse = 0;
              }
            es2s3:;
            } // End of DO block
          // ELSE (1351)
          else
            // IF OPRTR = XFBRA THEN (1352)
            if (1
                & (xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                        COREHALFWORD (mXFBRA))))
              // DO; (1353)
              {
              rs2s4:;
                // TMP = SHR(OPR(CTR+2), 16); (1354)
                {
                  int32_t numberRHS = (int32_t)(SHR (
                      getFIXED (mOPR + 4 * xadd (COREHALFWORD (mCTR), 2)),
                      16));
                  putFIXED (mTMP, numberRHS);
                }
              // CHECK_FBRA: (1355)
              CHECK_FBRA:
                // OPRTR = OPR(TMP) &  65521; (1356)
                {
                  int32_t numberRHS = (int32_t)(xAND (
                      getFIXED (mOPR + 4 * getFIXED (mTMP)), 65521));
                  descriptor_t *bitRHS;
                  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                  putBIT (16, mPREPARE_HALMATxOPRTR, bitRHS);
                  bitRHS->inUse = 0;
                }
                // IF OPRTR >= XBNEQ THEN (1357)
                if (1
                    & (xGE (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                            COREHALFWORD (mXBNEQ))))
                  // IF OPRTR <= XILT THEN (1358)
                  if (1
                      & (xLE (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                              COREHALFWORD (mXILT))))
                    // OPR(TMP) = OPR(TMP) |  16777216; (1359)
                    {
                      int32_t numberRHS = (int32_t)(xOR (
                          getFIXED (mOPR + 4 * getFIXED (mTMP)), 16777216));
                      putFIXED (mOPR + 4 * (getFIXED (mTMP)), numberRHS);
                    }
                // GO TO CHECK_NEW; (1360)
                goto CHECK_NEW;
              es2s4:;
              } // End of DO block
            // ELSE (1361)
            else
              // IF OPRTR = XCFOR | OPRTR = XCTST THEN (1362)
              if (1
                  & (xOR (xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                               COREHALFWORD (mXCFOR)),
                          xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                               COREHALFWORD (mXCTST)))))
                // DO; (1363)
                {
                rs2s5:;
                  // TMP = SHR(OPR(CTR+1), 16); (1364)
                  {
                    int32_t numberRHS = (int32_t)(SHR (
                        getFIXED (mOPR + 4 * xadd (COREHALFWORD (mCTR), 1)),
                        16));
                    putFIXED (mTMP, numberRHS);
                  }
                  // GO TO CHECK_FBRA; (1365)
                  goto CHECK_FBRA;
                es2s5:;
                } // End of DO block
              // ELSE (1366)
              else
                // IF OPRTR = XIDEF THEN (1367)
                if (1
                    & (xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                            COREHALFWORD (mXIDEF))))
                  // DO; (1368)
                  {
                  rs2s6:;
                    // IFLAG = 1; (1369)
                    {
                      int32_t numberRHS = (int32_t)(1);
                      descriptor_t *bitRHS;
                      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                      putBIT (1, mPREPARE_HALMATxIFLAG, bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // IF FUNC_LEVEL = 0 THEN (1370)
                    if (1 & (xEQ (COREHALFWORD (mFUNC_LEVEL), 0)))
                      // DO; (1371)
                      {
                      rs2s6s1:;
                        // FUNC_LEVEL = OPTAG; (1372)
                        {
                          descriptor_t *bitRHS
                              = getBIT (16, mPREPARE_HALMATxOPTAG);
                          putBIT (16, mFUNC_LEVEL, bitRHS);
                          bitRHS->inUse = 0;
                        }
                        // START = CTR; (1373)
                        {
                          descriptor_t *bitRHS = getBIT (16, mCTR);
                          putBIT (16, mPREPARE_HALMATxSTART, bitRHS);
                          bitRHS->inUse = 0;
                        }
                      es2s6s1:;
                      } // End of DO block
                    // CTR = CTR + OPNUM + 1; (1374)
                    {
                      int32_t numberRHS = (int32_t)(xadd (
                          xadd (COREHALFWORD (mCTR),
                                COREHALFWORD (mPREPARE_HALMATxOPNUM)),
                          1));
                      descriptor_t *bitRHS;
                      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                      putBIT (16, mCTR, bitRHS);
                      bitRHS->inUse = 0;
                    }
                  es2s6:;
                  } // End of DO block
                // ELSE (1375)
                else
                  // IF OPRTR = XICLS THEN (1376)
                  if (1
                      & (xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                              COREHALFWORD (mXICLS))))
                    // DO; (1377)
                    {
                    rs2s7:;
                      // IF FUNC_LEVEL = OPTAG THEN (1378)
                      if (1
                          & (xEQ (COREHALFWORD (mFUNC_LEVEL),
                                  COREHALFWORD (mPREPARE_HALMATxOPTAG))))
                        // DO; (1379)
                        {
                        rs2s7s1:;
                          // SIZE = CTR - START + 4; (1380)
                          {
                            int32_t numberRHS = (int32_t)(xadd (
                                xsubtract (
                                    COREHALFWORD (mCTR),
                                    COREHALFWORD (mPREPARE_HALMATxSTART)),
                                4));
                            descriptor_t *bitRHS;
                            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                            putBIT (16, mPREPARE_HALMATxROW, bitRHS);
                            bitRHS->inUse = 0;
                          }
                          // IF NEW ~= START THEN (1381)
                          if (1
                              & (xNEQ (COREHALFWORD (mPREPARE_HALMATxNEW),
                                       COREHALFWORD (mPREPARE_HALMATxSTART))))
                            // DO; (1382)
                            {
                            rs2s7s1s1:;
                              // CALL MOVECODE(NEW, START, SIZE); (1383)
                              {
                                putBITp (16, mMOVECODExLOW,
                                         getBIT (16, mPREPARE_HALMATxNEW));
                                putBITp (16, mMOVECODExHIGH,
                                         getBIT (16, mPREPARE_HALMATxSTART));
                                putBITp (16, mMOVECODExBIG,
                                         getBIT (16, mPREPARE_HALMATxROW));
                                MOVECODE (0);
                              }
                              // CALL RELOCATE(NEW, START, SIZE); (1384)
                              {
                                putBITp (16, mRELOCATExNEW,
                                         getBIT (16, mPREPARE_HALMATxNEW));
                                putBITp (16, mRELOCATExSTART,
                                         getBIT (16, mPREPARE_HALMATxSTART));
                                putBITp (16, mRELOCATExROW,
                                         getBIT (16, mPREPARE_HALMATxROW));
                                RELOCATE (0);
                              }
                            es2s7s1s1:;
                            } // End of DO block
                          // FUNC_LEVEL = 0; (1385)
                          {
                            int32_t numberRHS = (int32_t)(0);
                            descriptor_t *bitRHS;
                            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                            putBIT (16, mFUNC_LEVEL, bitRHS);
                            bitRHS->inUse = 0;
                          }
                          // IF NESTFUNC = 0 THEN (1386)
                          if (1 & (xEQ (COREHALFWORD (mNESTFUNC), 0)))
                            // DO; (1387)
                            {
                            rs2s7s1s2:;
                              // CTR = START + SIZE; (1388)
                              {
                                int32_t numberRHS = (int32_t)(xadd (
                                    COREHALFWORD (mPREPARE_HALMATxSTART),
                                    COREHALFWORD (mPREPARE_HALMATxROW)));
                                descriptor_t *bitRHS;
                                bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                                putBIT (16, mCTR, bitRHS);
                                bitRHS->inUse = 0;
                              }
                              // NEW = NEW + SIZE; (1389)
                              {
                                int32_t numberRHS = (int32_t)(xadd (
                                    COREHALFWORD (mPREPARE_HALMATxNEW),
                                    COREHALFWORD (mPREPARE_HALMATxROW)));
                                descriptor_t *bitRHS;
                                bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                                putBIT (16, mPREPARE_HALMATxNEW, bitRHS);
                                bitRHS->inUse = 0;
                              }
                              // DO FLAG_LOC = 1 TO NEST_LEVEL; (1390)
                              {
                                int32_t from31, to31, by31;
                                from31 = 1;
                                to31 = bitToFixed (
                                    getBIT (16, mPREPARE_HALMATxNEST_LEVEL));
                                by31 = 1;
                                for (putBIT (16, mPREPARE_HALMATxFLAG_LOC,
                                             fixedToBit (16, from31));
                                     bitToFixed (
                                         getBIT (16, mPREPARE_HALMATxFLAG_LOC))
                                     <= to31;
                                     putBIT (
                                         16, mPREPARE_HALMATxFLAG_LOC,
                                         fixedToBit (
                                             16,
                                             bitToFixed (getBIT (
                                                 16, mPREPARE_HALMATxFLAG_LOC))
                                                 + by31)))
                                  {
                                    // START(FLAG_LOC) = START(FLAG_LOC) +
                                    // SIZE; (1391)
                                    {
                                      int32_t numberRHS = (int32_t)(xadd (
                                          COREHALFWORD (
                                              mPREPARE_HALMATxSTART
                                              + 2
                                                    * COREHALFWORD (
                                                        mPREPARE_HALMATxFLAG_LOC)),
                                          COREHALFWORD (mPREPARE_HALMATxROW)));
                                      descriptor_t *bitRHS;
                                      bitRHS = fixedToBit (
                                          32, (int32_t)(numberRHS));
                                      putBIT (
                                          16,
                                          mPREPARE_HALMATxSTART
                                              + 2
                                                    * (COREHALFWORD (
                                                        mPREPARE_HALMATxFLAG_LOC)),
                                          bitRHS);
                                      bitRHS->inUse = 0;
                                    }
                                  }
                              } // End of DO for-loop block
                            es2s7s1s2:;
                            } // End of DO block
                          // ELSE (1392)
                          else
                            // DO; (1393)
                            {
                            rs2s7s1s3:;
                              // NESTFUNC, NEST_LEVEL = 0; (1394)
                              {
                                int32_t numberRHS = (int32_t)(0);
                                descriptor_t *bitRHS;
                                bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                                putBIT (16, mNESTFUNC, bitRHS);
                                bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                                putBIT (16, mPREPARE_HALMATxNEST_LEVEL,
                                        bitRHS);
                                bitRHS->inUse = 0;
                              }
                              // CTR = NEW + (SHR(OPR(NEW), 16) &  255) + 1;
                              // (1395)
                              {
                                int32_t numberRHS = (int32_t)(xadd (
                                    xadd (
                                        COREHALFWORD (mPREPARE_HALMATxNEW),
                                        xAND (
                                            SHR (
                                                getFIXED (
                                                    mOPR
                                                    + 4
                                                          * COREHALFWORD (
                                                              mPREPARE_HALMATxNEW)),
                                                16),
                                            255)),
                                    1));
                                descriptor_t *bitRHS;
                                bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                                putBIT (16, mCTR, bitRHS);
                                bitRHS->inUse = 0;
                              }
                            es2s7s1s3:;
                            } // End of DO block
                        es2s7s1:;
                        } // End of DO block
                      // ELSE (1396)
                      else
                        // DO; (1397)
                        {
                        rs2s7s2:;
                          // CTR = CTR + OPNUM + 1; (1398)
                          {
                            int32_t numberRHS = (int32_t)(xadd (
                                xadd (COREHALFWORD (mCTR),
                                      COREHALFWORD (mPREPARE_HALMATxOPNUM)),
                                1));
                            descriptor_t *bitRHS;
                            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                            putBIT (16, mCTR, bitRHS);
                            bitRHS->inUse = 0;
                          }
                          // IF FUNC_LEVEL > 0 THEN (1399)
                          if (1 & (xGT (COREHALFWORD (mFUNC_LEVEL), 0)))
                            // NESTFUNC = FUNC_LEVEL; (1400)
                            {
                              descriptor_t *bitRHS = getBIT (16, mFUNC_LEVEL);
                              putBIT (16, mNESTFUNC, bitRHS);
                              bitRHS->inUse = 0;
                            }
                          // ELSE (1401)
                          else
                            // NEW = CTR; (1402)
                            {
                              descriptor_t *bitRHS = getBIT (16, mCTR);
                              putBIT (16, mPREPARE_HALMATxNEW, bitRHS);
                              bitRHS->inUse = 0;
                            }
                        es2s7s2:;
                        } // End of DO block
                    es2s7:;
                    } // End of DO block
                  // ELSE (1403)
                  else
                    // DO; (1404)
                    {
                    rs2s8:;
                    // CHECK_NEW: (1405)
                    CHECK_NEW:
                      // CTR = CTR + OPNUM + 1; (1406)
                      {
                        int32_t numberRHS = (int32_t)(xadd (
                            xadd (COREHALFWORD (mCTR),
                                  COREHALFWORD (mPREPARE_HALMATxOPNUM)),
                            1));
                        descriptor_t *bitRHS;
                        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                        putBIT (16, mCTR, bitRHS);
                        bitRHS->inUse = 0;
                      }
                      // IF NEST_LEVEL = 0 & FUNC_LEVEL = 0 THEN (1407)
                      if (1
                          & (xAND (
                              xEQ (COREHALFWORD (mPREPARE_HALMATxNEST_LEVEL),
                                   0),
                              xEQ (COREHALFWORD (mFUNC_LEVEL), 0))))
                        // IF OPCOPT = XN THEN (1408)
                        if (1
                            & (xEQ (COREHALFWORD (mPREPARE_HALMATxOPCOPT),
                                    COREHALFWORD (mXN))))
                          // NEW = CTR; (1409)
                          {
                            descriptor_t *bitRHS = getBIT (16, mCTR);
                            putBIT (16, mPREPARE_HALMATxNEW, bitRHS);
                            bitRHS->inUse = 0;
                          }
                    es2s8:;
                    } // End of DO block
    }                 // End of DO WHILE block
  // CTR = RESET; (1410)
  {
    descriptor_t *bitRHS = getBIT (16, mRESET);
    putBIT (16, mCTR, bitRHS);
    bitRHS->inUse = 0;
  }
  // CALL OPDECODE(CTR); (1411)
  {
    putBITp (16, mPREPARE_HALMATxOPDECODExCTR, getBIT (16, mCTR));
    PREPARE_HALMATxOPDECODE (0);
  }
  // IF BLOCK_FLAG THEN (1412)
  if (1 & (bitToFixed (getBIT (1, mPREPARE_HALMATxBLOCK_FLAG))))
    // NEW = CTR; (1413)
    {
      descriptor_t *bitRHS = getBIT (16, mCTR);
      putBIT (16, mPREPARE_HALMATxNEW, bitRHS);
      bitRHS->inUse = 0;
    }
  // ELSE (1414)
  else
    // NEW, CTR = CTR + OPNUM + 1; (1415)
    {
      int32_t numberRHS = (int32_t)(xadd (
          xadd (COREHALFWORD (mCTR), COREHALFWORD (mPREPARE_HALMATxOPNUM)),
          1));
      descriptor_t *bitRHS;
      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
      putBIT (16, mPREPARE_HALMATxNEW, bitRHS);
      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
      putBIT (16, mCTR, bitRHS);
      bitRHS->inUse = 0;
    }
  // FUNC_LEVEL, NEST_LEVEL, NESTFUNC = 0; (1416)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mFUNC_LEVEL, bitRHS);
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mPREPARE_HALMATxNEST_LEVEL, bitRHS);
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mNESTFUNC, bitRHS);
    bitRHS->inUse = 0;
  }
  // DO WHILE CTR < SMRK_CTR; (1417)
  while (1 & (xLT (COREHALFWORD (mCTR), COREHALFWORD (mSMRK_CTR))))
    {
      // CALL OPDECODE(CTR); (1418)
      {
        putBITp (16, mPREPARE_HALMATxOPDECODExCTR, getBIT (16, mCTR));
        PREPARE_HALMATxOPDECODE (0);
      }
      // IF OPRTR = XSFST | OPRTR = XXXST THEN (1419)
      if (1
          & (xOR (xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                       COREHALFWORD (mXSFST)),
                  xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                       COREHALFWORD (mXXXST)))))
        // DO; (1420)
        {
        rs3s1:;
          // NEST_LEVEL(OPTAG) = NEST_LEVEL; (1421)
          {
            descriptor_t *bitRHS = getBIT (16, mPREPARE_HALMATxNEST_LEVEL);
            putBIT (16,
                    mPREPARE_HALMATxNEST_LEVEL
                        + 2 * (COREHALFWORD (mPREPARE_HALMATxOPTAG)),
                    bitRHS);
            bitRHS->inUse = 0;
          }
          // NEST_LEVEL = OPTAG; (1422)
          {
            descriptor_t *bitRHS = getBIT (16, mPREPARE_HALMATxOPTAG);
            putBIT (16, mPREPARE_HALMATxNEST_LEVEL, bitRHS);
            bitRHS->inUse = 0;
          }
          // IF OPR(CTR) < 0 THEN (1423)
          if (1 & (xLT (getFIXED (mOPR + 4 * COREHALFWORD (mCTR)), 0)))
            // IF FUNC_LEVEL = 0 THEN (1424)
            if (1 & (xEQ (COREHALFWORD (mFUNC_LEVEL), 0)))
              // DO; (1425)
              {
              rs3s1s1:;
                // FUNC_LEVEL = OPTAG; (1426)
                {
                  descriptor_t *bitRHS = getBIT (16, mPREPARE_HALMATxOPTAG);
                  putBIT (16, mFUNC_LEVEL, bitRHS);
                  bitRHS->inUse = 0;
                }
                // START = CTR; (1427)
                {
                  descriptor_t *bitRHS = getBIT (16, mCTR);
                  putBIT (16, mPREPARE_HALMATxSTART, bitRHS);
                  bitRHS->inUse = 0;
                }
              es3s1s1:;
              } // End of DO block
          // CTR = CTR + OPNUM + 1; (1428)
          {
            int32_t numberRHS
                = (int32_t)(xadd (xadd (COREHALFWORD (mCTR),
                                        COREHALFWORD (mPREPARE_HALMATxOPNUM)),
                                  1));
            descriptor_t *bitRHS;
            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
            putBIT (16, mCTR, bitRHS);
            bitRHS->inUse = 0;
          }
        es3s1:;
        } // End of DO block
      // ELSE (1429)
      else
        // IF OPRTR = XSFND | OPRTR = XXXND THEN (1430)
        if (1
            & (xOR (xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                         COREHALFWORD (mXSFND)),
                    xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                         COREHALFWORD (mXXXND)))))
          // DO; (1431)
          {
          rs3s2:;
            // NEST_LEVEL = NEST_LEVEL(OPTAG); (1432)
            {
              descriptor_t *bitRHS = getBIT (
                  16, mPREPARE_HALMATxNEST_LEVEL
                          + 2 * COREHALFWORD (mPREPARE_HALMATxOPTAG));
              putBIT (16, mPREPARE_HALMATxNEST_LEVEL, bitRHS);
              bitRHS->inUse = 0;
            }
            // IF OPCOPT = XN & OPTAG > 0 THEN (1433)
            if (1
                & (xAND (xEQ (COREHALFWORD (mPREPARE_HALMATxOPCOPT),
                              COREHALFWORD (mXN)),
                         xGT (COREHALFWORD (mPREPARE_HALMATxOPTAG), 0))))
              // DO; (1434)
              {
              rs3s2s1:;
                // IF FUNC_LEVEL = OPTAG THEN (1435)
                if (1
                    & (xEQ (COREHALFWORD (mFUNC_LEVEL),
                            COREHALFWORD (mPREPARE_HALMATxOPTAG))))
                  // DO; (1436)
                  {
                  rs3s2s1s1:;
                    // SIZE = CTR - START + 1; (1437)
                    {
                      int32_t numberRHS = (int32_t)(xadd (
                          xsubtract (COREHALFWORD (mCTR),
                                     COREHALFWORD (mPREPARE_HALMATxSTART)),
                          1));
                      descriptor_t *bitRHS;
                      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                      putBIT (16, mPREPARE_HALMATxROW, bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // IF NEW ~= START THEN (1438)
                    if (1
                        & (xNEQ (COREHALFWORD (mPREPARE_HALMATxNEW),
                                 COREHALFWORD (mPREPARE_HALMATxSTART))))
                      // DO; (1439)
                      {
                      rs3s2s1s1s1:;
                        // CALL MOVECODE(NEW, START, SIZE); (1440)
                        {
                          putBITp (16, mMOVECODExLOW,
                                   getBIT (16, mPREPARE_HALMATxNEW));
                          putBITp (16, mMOVECODExHIGH,
                                   getBIT (16, mPREPARE_HALMATxSTART));
                          putBITp (16, mMOVECODExBIG,
                                   getBIT (16, mPREPARE_HALMATxROW));
                          MOVECODE (0);
                        }
                        // CALL RELOCATE(NEW, START, SIZE); (1441)
                        {
                          putBITp (16, mRELOCATExNEW,
                                   getBIT (16, mPREPARE_HALMATxNEW));
                          putBITp (16, mRELOCATExSTART,
                                   getBIT (16, mPREPARE_HALMATxSTART));
                          putBITp (16, mRELOCATExROW,
                                   getBIT (16, mPREPARE_HALMATxROW));
                          RELOCATE (0);
                        }
                      es3s2s1s1s1:;
                      } // End of DO block
                    // FUNC_LEVEL = 0; (1442)
                    {
                      int32_t numberRHS = (int32_t)(0);
                      descriptor_t *bitRHS;
                      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                      putBIT (16, mFUNC_LEVEL, bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // IF NESTFUNC = 0 THEN (1443)
                    if (1 & (xEQ (COREHALFWORD (mNESTFUNC), 0)))
                      // DO; (1444)
                      {
                      rs3s2s1s1s2:;
                        // CTR = START + SIZE; (1445)
                        {
                          int32_t numberRHS = (int32_t)(xadd (
                              COREHALFWORD (mPREPARE_HALMATxSTART),
                              COREHALFWORD (mPREPARE_HALMATxROW)));
                          descriptor_t *bitRHS;
                          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                          putBIT (16, mCTR, bitRHS);
                          bitRHS->inUse = 0;
                        }
                        // NEW = NEW + SIZE; (1446)
                        {
                          int32_t numberRHS = (int32_t)(xadd (
                              COREHALFWORD (mPREPARE_HALMATxNEW),
                              COREHALFWORD (mPREPARE_HALMATxROW)));
                          descriptor_t *bitRHS;
                          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                          putBIT (16, mPREPARE_HALMATxNEW, bitRHS);
                          bitRHS->inUse = 0;
                        }
                      es3s2s1s1s2:;
                      } // End of DO block
                    // ELSE (1447)
                    else
                      // DO; (1448)
                      {
                      rs3s2s1s1s3:;
                        // NESTFUNC = 0; (1449)
                        {
                          int32_t numberRHS = (int32_t)(0);
                          descriptor_t *bitRHS;
                          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                          putBIT (16, mNESTFUNC, bitRHS);
                          bitRHS->inUse = 0;
                        }
                        // NEST_LEVEL = OPTAG; (1450)
                        {
                          descriptor_t *bitRHS
                              = getBIT (16, mPREPARE_HALMATxOPTAG);
                          putBIT (16, mPREPARE_HALMATxNEST_LEVEL, bitRHS);
                          bitRHS->inUse = 0;
                        }
                        // CTR = NEW + (SHR(OPR(NEW), 16) &  255) + 1; (1451)
                        {
                          int32_t numberRHS = (int32_t)(xadd (
                              xadd (
                                  COREHALFWORD (mPREPARE_HALMATxNEW),
                                  xAND (
                                      SHR (getFIXED (
                                               mOPR
                                               + 4
                                                     * COREHALFWORD (
                                                         mPREPARE_HALMATxNEW)),
                                           16),
                                      255)),
                              1));
                          descriptor_t *bitRHS;
                          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                          putBIT (16, mCTR, bitRHS);
                          bitRHS->inUse = 0;
                        }
                      es3s2s1s1s3:;
                      } // End of DO block
                  es3s2s1s1:;
                  } // End of DO block
                // ELSE (1452)
                else
                  // DO; (1453)
                  {
                  rs3s2s1s2:;
                    // CTR = CTR + OPNUM + 1; (1454)
                    {
                      int32_t numberRHS = (int32_t)(xadd (
                          xadd (COREHALFWORD (mCTR),
                                COREHALFWORD (mPREPARE_HALMATxOPNUM)),
                          1));
                      descriptor_t *bitRHS;
                      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                      putBIT (16, mCTR, bitRHS);
                      bitRHS->inUse = 0;
                    }
                    // IF FUNC_LEVEL > 0 THEN (1455)
                    if (1 & (xGT (COREHALFWORD (mFUNC_LEVEL), 0)))
                      // NESTFUNC = FUNC_LEVEL; (1456)
                      {
                        descriptor_t *bitRHS = getBIT (16, mFUNC_LEVEL);
                        putBIT (16, mNESTFUNC, bitRHS);
                        bitRHS->inUse = 0;
                      }
                    // ELSE (1457)
                    else
                      // NEW = CTR; (1458)
                      {
                        descriptor_t *bitRHS = getBIT (16, mCTR);
                        putBIT (16, mPREPARE_HALMATxNEW, bitRHS);
                        bitRHS->inUse = 0;
                      }
                  es3s2s1s2:;
                  } // End of DO block
              es3s2s1:;
              } // End of DO block
            // ELSE (1459)
            else
              // CTR = CTR + OPNUM + 1; (1460)
              {
                int32_t numberRHS = (int32_t)(xadd (
                    xadd (COREHALFWORD (mCTR),
                          COREHALFWORD (mPREPARE_HALMATxOPNUM)),
                    1));
                descriptor_t *bitRHS;
                bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                putBIT (16, mCTR, bitRHS);
                bitRHS->inUse = 0;
              }
          es3s2:;
          } // End of DO block
        // ELSE (1461)
        else
          // DO; (1462)
          {
          rs3s3:;
            // CTR = CTR + OPNUM + 1; (1463)
            {
              int32_t numberRHS = (int32_t)(xadd (
                  xadd (COREHALFWORD (mCTR),
                        COREHALFWORD (mPREPARE_HALMATxOPNUM)),
                  1));
              descriptor_t *bitRHS;
              bitRHS = fixedToBit (32, (int32_t)(numberRHS));
              putBIT (16, mCTR, bitRHS);
              bitRHS->inUse = 0;
            }
            // IF NEST_LEVEL = 0 THEN (1464)
            if (1 & (xEQ (COREHALFWORD (mPREPARE_HALMATxNEST_LEVEL), 0)))
              // IF OPCOPT = XN THEN (1465)
              if (1
                  & (xEQ (COREHALFWORD (mPREPARE_HALMATxOPCOPT),
                          COREHALFWORD (mXN))))
                // NEW = CTR; (1466)
                {
                  descriptor_t *bitRHS = getBIT (16, mCTR);
                  putBIT (16, mPREPARE_HALMATxNEW, bitRHS);
                  bitRHS->inUse = 0;
                }
          es3s3:;
          } // End of DO block
    }       // End of DO WHILE block
  // CTR = RESET; (1467)
  {
    descriptor_t *bitRHS = getBIT (16, mRESET);
    putBIT (16, mCTR, bitRHS);
    bitRHS->inUse = 0;
  }
  // FUNC_LEVEL = 0; (1468)
  {
    int32_t numberRHS = (int32_t)(0);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mFUNC_LEVEL, bitRHS);
    bitRHS->inUse = 0;
  }
  // CALL OPDECODE(CTR); (1469)
  {
    putBITp (16, mPREPARE_HALMATxOPDECODExCTR, getBIT (16, mCTR));
    PREPARE_HALMATxOPDECODE (0);
  }
  // IF BLOCK_FLAG THEN (1470)
  if (1 & (bitToFixed (getBIT (1, mPREPARE_HALMATxBLOCK_FLAG))))
    // NEW = CTR; (1471)
    {
      descriptor_t *bitRHS = getBIT (16, mCTR);
      putBIT (16, mPREPARE_HALMATxNEW, bitRHS);
      bitRHS->inUse = 0;
    }
  // ELSE (1472)
  else
    // NEW, CTR = CTR + OPNUM + 1; (1473)
    {
      int32_t numberRHS = (int32_t)(xadd (
          xadd (COREHALFWORD (mCTR), COREHALFWORD (mPREPARE_HALMATxOPNUM)),
          1));
      descriptor_t *bitRHS;
      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
      putBIT (16, mPREPARE_HALMATxNEW, bitRHS);
      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
      putBIT (16, mCTR, bitRHS);
      bitRHS->inUse = 0;
    }
  // DO WHILE CTR < SMRK_CTR; (1474)
  while (1 & (xLT (COREHALFWORD (mCTR), COREHALFWORD (mSMRK_CTR))))
    {
      // CALL OPDECODE(CTR); (1475)
      {
        putBITp (16, mPREPARE_HALMATxOPDECODExCTR, getBIT (16, mCTR));
        PREPARE_HALMATxOPDECODE (0);
      }
      // IF OPRTR = XDLPE THEN (1476)
      if (1
          & (xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                  COREHALFWORD (mXDLPE))))
        // DO; (1477)
        {
        rs4s1:;
          // SIZE = CTR - START(FUNC_LEVEL); (1478)
          {
            int32_t numberRHS = (int32_t)(xsubtract (
                COREHALFWORD (mCTR),
                COREHALFWORD (mPREPARE_HALMATxSTART
                              + 2 * COREHALFWORD (mFUNC_LEVEL))));
            descriptor_t *bitRHS;
            bitRHS = fixedToBit (32, (int32_t)(numberRHS));
            putBIT (16, mPREPARE_HALMATxROW, bitRHS);
            bitRHS->inUse = 0;
          }
          // IF (RESET = 0) & (NEW(FUNC_LEVEL) = 0) THEN (1479)
          if (1
              & (xAND (xEQ (COREHALFWORD (mRESET), 0),
                       xEQ (COREHALFWORD (mPREPARE_HALMATxNEW
                                          + 2 * COREHALFWORD (mFUNC_LEVEL)),
                            0))))
            // NEW(FUNC_LEVEL) = RESET + (SHR(OPR(RESET),16)& 255) + 1; (1480)
            {
              int32_t numberRHS = (int32_t)(xadd (
                  xadd (COREHALFWORD (mRESET),
                        xAND (SHR (getFIXED (mOPR + 4 * COREHALFWORD (mRESET)),
                                   16),
                              255)),
                  1));
              descriptor_t *bitRHS;
              bitRHS = fixedToBit (32, (int32_t)(numberRHS));
              putBIT (16,
                      mPREPARE_HALMATxNEW + 2 * (COREHALFWORD (mFUNC_LEVEL)),
                      bitRHS);
              bitRHS->inUse = 0;
            }
          // CALL MOVECODE(NEW(FUNC_LEVEL), START(FUNC_LEVEL), SIZE); (1481)
          {
            putBITp (16, mMOVECODExLOW,
                     getBIT (16, mPREPARE_HALMATxNEW
                                     + 2 * COREHALFWORD (mFUNC_LEVEL)));
            putBITp (16, mMOVECODExHIGH,
                     getBIT (16, mPREPARE_HALMATxSTART
                                     + 2 * COREHALFWORD (mFUNC_LEVEL)));
            putBITp (16, mMOVECODExBIG, getBIT (16, mPREPARE_HALMATxROW));
            MOVECODE (0);
          }
          // CALL RELOCATE(NEW(FUNC_LEVEL), START(FUNC_LEVEL), SIZE); (1482)
          {
            putBITp (16, mRELOCATExNEW,
                     getBIT (16, mPREPARE_HALMATxNEW
                                     + 2 * COREHALFWORD (mFUNC_LEVEL)));
            putBITp (16, mRELOCATExSTART,
                     getBIT (16, mPREPARE_HALMATxSTART
                                     + 2 * COREHALFWORD (mFUNC_LEVEL)));
            putBITp (16, mRELOCATExROW, getBIT (16, mPREPARE_HALMATxROW));
            RELOCATE (0);
          }
        es4s1:;
        } // End of DO block
      // ELSE (1483)
      else
        // IF OPRTR = XXXST | OPRTR = XSFST THEN (1484)
        if (1
            & (xOR (xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                         COREHALFWORD (mXXXST)),
                    xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                         COREHALFWORD (mXSFST)))))
          // DO; (1485)
          {
          rs4s2:;
            // NEST_LEVEL(OPTAG) = FUNC_LEVEL; (1486)
            {
              descriptor_t *bitRHS = getBIT (16, mFUNC_LEVEL);
              putBIT (16,
                      mPREPARE_HALMATxNEST_LEVEL
                          + 2 * (COREHALFWORD (mPREPARE_HALMATxOPTAG)),
                      bitRHS);
              bitRHS->inUse = 0;
            }
            // FUNC_LEVEL = OPTAG; (1487)
            {
              descriptor_t *bitRHS = getBIT (16, mPREPARE_HALMATxOPTAG);
              putBIT (16, mFUNC_LEVEL, bitRHS);
              bitRHS->inUse = 0;
            }
            // NEW(FUNC_LEVEL) = CTR + OPNUM + 1; (1488)
            {
              int32_t numberRHS = (int32_t)(xadd (
                  xadd (COREHALFWORD (mCTR),
                        COREHALFWORD (mPREPARE_HALMATxOPNUM)),
                  1));
              descriptor_t *bitRHS;
              bitRHS = fixedToBit (32, (int32_t)(numberRHS));
              putBIT (16,
                      mPREPARE_HALMATxNEW + 2 * (COREHALFWORD (mFUNC_LEVEL)),
                      bitRHS);
              bitRHS->inUse = 0;
            }
            // OPR(CTR) = OPR(CTR) & POSMAX; (1489)
            {
              int32_t numberRHS
                  = (int32_t)(xAND (getFIXED (mOPR + 4 * COREHALFWORD (mCTR)),
                                    getFIXED (mPOSMAX)));
              putFIXED (mOPR + 4 * (COREHALFWORD (mCTR)), numberRHS);
            }
          es4s2:;
          } // End of DO block
        // ELSE (1490)
        else
          // IF OPRTR = XXXND | OPRTR = XSFND THEN (1491)
          if (1
              & (xOR (xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                           COREHALFWORD (mXXXND)),
                      xEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                           COREHALFWORD (mXSFND)))))
            // FUNC_LEVEL = NEST_LEVEL(OPTAG); (1492)
            {
              descriptor_t *bitRHS = getBIT (
                  16, mPREPARE_HALMATxNEST_LEVEL
                          + 2 * COREHALFWORD (mPREPARE_HALMATxOPTAG));
              putBIT (16, mFUNC_LEVEL, bitRHS);
              bitRHS->inUse = 0;
            }
          // ELSE (1493)
          else
            // IF OPRTR >= XREAD & OPRTR <= XWRIT THEN (1494)
            if (1
                & (xAND (xGE (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                              COREHALFWORD (mXREAD)),
                         xLE (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                              COREHALFWORD (mXWRIT)))))
              // READCTR = CTR; (1495)
              {
                descriptor_t *bitRHS = getBIT (16, mCTR);
                putBIT (16, mREADCTR, bitRHS);
                bitRHS->inUse = 0;
              }
      // IF (OPCOPT = XN) & (X_BITS(CTR+OPNUM+1) ~= XD) THEN (1496)
      if (1
          & (xAND (
              xEQ (COREHALFWORD (mPREPARE_HALMATxOPCOPT), COREHALFWORD (mXN)),
              xNEQ (bitToFixed ((
                        putBITp (16, mX_BITSxCTR,
                                 fixedToBit (
                                     32, (int32_t)(xadd (
                                             xadd (COREHALFWORD (mCTR),
                                                   COREHALFWORD (
                                                       mPREPARE_HALMATxOPNUM)),
                                             1)))),
                        X_BITS (0))),
                    COREHALFWORD (mXD)))))
        // NEW(FUNC_LEVEL) = CTR + OPNUM + 1; (1497)
        {
          int32_t numberRHS = (int32_t)(xadd (
              xadd (COREHALFWORD (mCTR), COREHALFWORD (mPREPARE_HALMATxOPNUM)),
              1));
          descriptor_t *bitRHS;
          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
          putBIT (16, mPREPARE_HALMATxNEW + 2 * (COREHALFWORD (mFUNC_LEVEL)),
                  bitRHS);
          bitRHS->inUse = 0;
        }
      // ELSE (1498)
      else
        // IF OPCOPT = XD THEN (1499)
        if (1
            & (xEQ (COREHALFWORD (mPREPARE_HALMATxOPCOPT),
                    COREHALFWORD (mXD))))
          // START(FUNC_LEVEL) = CTR; (1500)
          {
            descriptor_t *bitRHS = getBIT (16, mCTR);
            putBIT (16,
                    mPREPARE_HALMATxSTART + 2 * (COREHALFWORD (mFUNC_LEVEL)),
                    bitRHS);
            bitRHS->inUse = 0;
          }
      // IF OPRTR ~= XXXAR THEN (1501)
      if (1
          & (xNEQ (COREHALFWORD (mPREPARE_HALMATxOPRTR),
                   COREHALFWORD (mXXXAR))))
        // DO FOR TEMP = CTR + 1 TO CTR+NUMOP; (1502)
        {
          int32_t from32, to32, by32;
          from32 = xadd (COREHALFWORD (mCTR), 1);
          to32 = xadd (COREHALFWORD (mCTR), COREHALFWORD (mNUMOP));
          by32 = 1;
          for (putBIT (16, mTEMP, fixedToBit (16, from32));
               bitToFixed (getBIT (16, mTEMP)) <= to32; putBIT (
                   16, mTEMP,
                   fixedToBit (16, bitToFixed (getBIT (16, mTEMP)) + by32)))
            {
              // IF VAC_OR_XPT(TEMP) THEN (1503)
              if (1
                  & (bitToFixed (
                      (putBITp (16, mVAC_OR_XPTxPTR, getBIT (16, mTEMP)),
                       VAC_OR_XPT (0)))))
                // OPR(TEMP) = OPR(TEMP) &  4294967283; (1504)
                {
                  int32_t numberRHS = (int32_t)(xAND (
                      getFIXED (mOPR + 4 * COREHALFWORD (mTEMP)), 4294967283));
                  putFIXED (mOPR + 4 * (COREHALFWORD (mTEMP)), numberRHS);
                }
            }
        } // End of DO for-loop block
      // OPR(CTR) = OPR(CTR) &  4294967281; (1505)
      {
        int32_t numberRHS = (int32_t)(xAND (
            getFIXED (mOPR + 4 * COREHALFWORD (mCTR)), 4294967281));
        putFIXED (mOPR + 4 * (COREHALFWORD (mCTR)), numberRHS);
      }
      // CTR = CTR + OPNUM + 1; (1506)
      {
        int32_t numberRHS = (int32_t)(xadd (
            xadd (COREHALFWORD (mCTR), COREHALFWORD (mPREPARE_HALMATxOPNUM)),
            1));
        descriptor_t *bitRHS;
        bitRHS = fixedToBit (32, (int32_t)(numberRHS));
        putBIT (16, mCTR, bitRHS);
        bitRHS->inUse = 0;
      }
    } // End of DO WHILE block
  // OPR(SMRK_CTR) = OPR(SMRK_CTR) &  4294967281; (1507)
  {
    int32_t numberRHS = (int32_t)(xAND (
        getFIXED (mOPR + 4 * COREHALFWORD (mSMRK_CTR)), 4294967281));
    putFIXED (mOPR + 4 * (COREHALFWORD (mSMRK_CTR)), numberRHS);
  }
  // CTR = RESET; (1508)
  {
    descriptor_t *bitRHS = getBIT (16, mRESET);
    putBIT (16, mCTR, bitRHS);
    bitRHS->inUse = 0;
  }
  // NUMOP = SHR(OPR(CTR), 16) &  255; (1509)
  {
    int32_t numberRHS = (int32_t)(xAND (
        SHR (getFIXED (mOPR + 4 * COREHALFWORD (mCTR)), 16), 255));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mNUMOP, bitRHS);
    bitRHS->inUse = 0;
  }
  {
    reentryGuard = 0;
    return 0;
  }
}
