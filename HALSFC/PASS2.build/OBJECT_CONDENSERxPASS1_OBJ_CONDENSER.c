/*
  File OBJECT_CONDENSERxPASS1_OBJ_CONDENSER.c generated by XCOM-I, 2024-08-09
  12:39:31.
*/

#include "runtimeC.h"

int32_t
OBJECT_CONDENSERxPASS1_OBJ_CONDENSER (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard
      = guardReentry (reentryGuard, "OBJECT_CONDENSERxPASS1_OBJ_CONDENSER");
  // MAX_CODE_LINE=CODE_LINE; (14977)
  {
    int32_t numberRHS = (int32_t)(getFIXED (mCODE_LINE));
    putFIXED (mMAX_CODE_LINE, numberRHS);
  }
  // CODE_LINE = 0; (14978)
  {
    int32_t numberRHS = (int32_t)(0);
    putFIXED (mCODE_LINE, numberRHS);
  }
  // GENERATING, EMITTING = TRUE; (14979)
  {
    int32_t numberRHS = (int32_t)(1);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (1, mGENERATING, bitRHS);
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (1, mEMITTING, bitRHS);
    bitRHS->inUse = 0;
  }
  // DO WHILE GENERATING; (14980)
  while (1 & (bitToFixed (getBIT (1, mGENERATING))))
    {
      // CURRENT_LINE = CODE_LINE; (14981)
      {
        int32_t numberRHS = (int32_t)(getFIXED (mCODE_LINE));
        putFIXED (mOBJECT_CONDENSERxCURRENT_LINE, numberRHS);
      }
      // CALL NEXT_REC(0); (14982)
      {
        putBITp (16, mNEXT_RECxI, fixedToBit (32, (int32_t)(0)));
        NEXT_REC (0);
      }
      // IF LHS = 0 THEN (14983)
      if (1 & (xEQ (COREHALFWORD (mLHS), 0)))
        // CALL UPLOC(2); (14984)
        {
          putBITp (16, mOBJECT_CONDENSERxUPLOCxN,
                   fixedToBit (32, (int32_t)(2)));
          OBJECT_CONDENSERxUPLOC (0);
        }
      // ELSE (14985)
      else
        // IF LHS < 32 THEN (14986)
        if (1 & (xLT (COREHALFWORD (mLHS), 32)))
          // CALL ERRORS(CLASS_BI,506,' '||LHS); (14987)
          {
            putBITp (16, mERRORSxCLASS, getBIT (8, mCLASS_BI));
            putBITp (16, mERRORSxNUM, fixedToBit (32, (int32_t)(506)));
            putCHARACTERp (mERRORSxTEXT,
                           xsCAT (cToDescriptor (NULL, " "),
                                  bitToCharacter (getBIT (16, mLHS))));
            ERRORS (0);
          }
        // ELSE (14988)
        else
          // DO CASE LHS-32; (14989)
          {
          rs1s1:
            switch (xsubtract (COREHALFWORD (mLHS), 32))
              {
              case 0:
                // CALL UPLOC(2); (14991)
                {
                  putBITp (16, mOBJECT_CONDENSERxUPLOCxN,
                           fixedToBit (32, (int32_t)(2)));
                  OBJECT_CONDENSERxUPLOC (0);
                }
                break;
              case 1:
                // CALL CONDENSE; (14992)
                OBJECT_CONDENSERxCONDENSE (0);
                break;
              case 2:
                // DO; (14993)
                {
                rs1s1s1:;
                  // CALL UPLOC(4); (14993)
                  {
                    putBITp (16, mOBJECT_CONDENSERxUPLOCxN,
                             fixedToBit (32, (int32_t)(4)));
                    OBJECT_CONDENSERxUPLOC (0);
                  }
                  // CALL SKIP_ADDR; (14994)
                  SKIP_ADDR (0);
                  // CALL SKIP(1); (14995)
                  {
                    putBITp (16, mSKIPxN, fixedToBit (32, (int32_t)(1)));
                    SKIP (0);
                  }
                es1s1s1:;
                } // End of DO block
                break;
              case 3:
                // DELTA = DELTA + RHS; (14997)
                {
                  int32_t numberRHS
                      = (int32_t)(xadd (getFIXED (mOBJECT_CONDENSERxDELTA),
                                        COREHALFWORD (mRHS)));
                  putFIXED (mOBJECT_CONDENSERxDELTA, numberRHS);
                }
                break;
              case 4:
                // CALL VERIFY(SYT_LABEL(RHS)); (14998)
                {
                  putBITp (16, mOBJECT_CONDENSERxVERIFYxLBL,
                           getBIT (16, getFIXED (mSYM_TAB)
                                           + 34 * (COREHALFWORD (mRHS)) + 26
                                           + 2 * (0)));
                  OBJECT_CONDENSERxVERIFY (0);
                }
                break;
              case 5:
                // CALL VERIFY(LABEL_ARRAY(RHS)); (14999)
                {
                  putBITp (16, mOBJECT_CONDENSERxVERIFYxLBL,
                           getBIT (16, getFIXED (mSTMTNUM)
                                           + 2 * (COREHALFWORD (mRHS)) + 0
                                           + 2 * (0)));
                  OBJECT_CONDENSERxVERIFY (0);
                }
                break;
              case 6:
                // DO; (15000)
                {
                rs1s1s2:;
                  // CURRENT_ESDID = RHS; (15000)
                  {
                    descriptor_t *bitRHS = getBIT (16, mRHS);
                    int32_t numberRHS;
                    numberRHS = bitToFixed (bitRHS);
                    putFIXED (mCURRENT_ESDID, numberRHS);
                    bitRHS->inUse = 0;
                  }
                  // IF CURRENT_ESDID = FSIMBASE THEN (15001)
                  if (1
                      & (xEQ (getFIXED (mCURRENT_ESDID),
                              COREHALFWORD (mFSIMBASE))))
                    // CURRENT_ESDID = DATABASE; (15002)
                    {
                      descriptor_t *bitRHS = getBIT (16, mDATABASE);
                      int32_t numberRHS;
                      numberRHS = bitToFixed (bitRHS);
                      putFIXED (mCURRENT_ESDID, numberRHS);
                      bitRHS->inUse = 0;
                    }
                  // CALL NEXT_REC(1); (15003)
                  {
                    putBITp (16, mNEXT_RECxI, fixedToBit (32, (int32_t)(1)));
                    NEXT_REC (0);
                  }
                  // IF TEMP < 0 THEN (15004)
                  if (1 & (xLT (getFIXED (mTEMP), 0)))
                    // DO; (15005)
                    {
                    rs1s1s2s1:;
                      // IF RHS = DATABASE THEN (15006)
                      if (1
                          & (xEQ (COREHALFWORD (mRHS),
                                  COREHALFWORD (mDATABASE))))
                        // DO; (15007)
                        {
                        rs1s1s2s1s1:;
                          // TEMP = TEMP + PROGDELTA; (15008)
                          {
                            int32_t numberRHS = (int32_t)(xadd (
                                getFIXED (mTEMP), COREHALFWORD (mPROGDELTA)));
                            putFIXED (mTEMP, numberRHS);
                          }
                          // CODE(GET_CODE(CODE_LINE-1)) = TEMP; (15009)
                          {
                            int32_t numberRHS = (int32_t)(getFIXED (mTEMP));
                            putFIXED (
                                mCODE
                                    + 4
                                          * ((putFIXED (
                                                  mGET_CODExCTR,
                                                  xsubtract (
                                                      getFIXED (mCODE_LINE),
                                                      1)),
                                              GET_CODE (0))),
                                numberRHS);
                          }
                        es1s1s2s1s1:;
                        } // End of DO block
                      // CURRENT_ADDRESS = TEMP & POSMAX; (15010)
                      {
                        int32_t numberRHS = (int32_t)(xAND (
                            getFIXED (mTEMP), getFIXED (mPOSMAX)));
                        putFIXED (mWORKSEG + 4 * (getFIXED (mCURRENT_ESDID)),
                                  numberRHS);
                      }
                    es1s1s2s1:;
                    } // End of DO block
                es1s1s2:;
                } // End of DO block
                break;
              case 7:
                // DO; (15012)
                {
                rs1s1s3:;
                  // CALL UPLOC(SHL(RHS,2)); (15012)
                  {
                    putBITp (16, mOBJECT_CONDENSERxUPLOCxN,
                             fixedToBit (
                                 32, (int32_t)(SHL (COREHALFWORD (mRHS), 2))));
                    OBJECT_CONDENSERxUPLOC (0);
                  }
                  // CALL SKIP(RHS); (15013)
                  {
                    putBITp (16, mSKIPxN, getBIT (16, mRHS));
                    SKIP (0);
                  }
                es1s1s3:;
                } // End of DO block
                break;
              case 8:
              // ADCON_PROC: (15015)
              ADCON_PROC:
                {
                rs1s1s4:;
                  // CALL UPLOC(4); (15016)
                  {
                    putBITp (16, mOBJECT_CONDENSERxUPLOCxN,
                             fixedToBit (32, (int32_t)(4)));
                    OBJECT_CONDENSERxUPLOC (0);
                  }
                  // IF RHS = DATABASE THEN (15017)
                  if (1
                      & (xEQ (COREHALFWORD (mRHS), COREHALFWORD (mDATABASE))))
                    // DO; (15018)
                    {
                    rs1s1s4s1:;
                      // CALL NEXT_REC; (15019)
                      NEXT_REC (0);
                      // IF RLD_FLAG THEN (15020)
                      if (1
                          & (bitToFixed (
                              getBIT (1, mOBJECT_CONDENSERxRLD_FLAG))))
                        // LHS = LHS - PROGDELTA; (15021)
                        {
                          int32_t numberRHS = (int32_t)(xsubtract (
                              COREHALFWORD (mLHS), COREHALFWORD (mPROGDELTA)));
                          descriptor_t *bitRHS;
                          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                          putBIT (16, mLHS, bitRHS);
                          bitRHS->inUse = 0;
                        }
                      // ELSE (15022)
                      else
                        // LHS = LHS + PROGDELTA; (15023)
                        {
                          int32_t numberRHS = (int32_t)(xadd (
                              COREHALFWORD (mLHS), COREHALFWORD (mPROGDELTA)));
                          descriptor_t *bitRHS;
                          bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                          putBIT (16, mLHS, bitRHS);
                          bitRHS->inUse = 0;
                        }
                      // CODE(GET_CODE(CODE_LINE-1)) = SHL(LHS,16) + (RHS&
                      // 65535); (15024)
                      {
                        int32_t numberRHS = (int32_t)(xadd (
                            SHL (COREHALFWORD (mLHS), 16),
                            xAND (COREHALFWORD (mRHS), 65535)));
                        putFIXED (
                            mCODE
                                + 4
                                      * ((putFIXED (
                                              mGET_CODExCTR,
                                              xsubtract (getFIXED (mCODE_LINE),
                                                         1)),
                                          GET_CODE (0))),
                            numberRHS);
                      }
                    es1s1s4s1:;
                    } // End of DO block
                  // ELSE (15025)
                  else
                    // CALL SKIP(1); (15026)
                    {
                      putBITp (16, mSKIPxN, fixedToBit (32, (int32_t)(1)));
                      SKIP (0);
                    }
                es1s1s4:;
                } // End of DO block
                break;
              case 9:
                // GO TO HADCON_PROC; (15028)
                goto HADCON_PROC;
                break;
              case 10:
                // GO TO ADCON_PROC; (15029)
                goto ADCON_PROC;
                break;
              case 11:
                // RLD_FLAG = SHR(RHS, 15); (15030)
                {
                  int32_t numberRHS = (int32_t)(SHR (COREHALFWORD (mRHS), 15));
                  descriptor_t *bitRHS;
                  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                  putBIT (1, mOBJECT_CONDENSERxRLD_FLAG, bitRHS);
                  bitRHS->inUse = 0;
                }
                break;
              case 12:
                  // ; (15031)
                  ;
                break;
              case 13:
                // DELTA = MAXTEMP(RHS); (15032)
                {
                  int32_t numberRHS = (int32_t)(getFIXED (
                      mMAXTEMP + 4 * COREHALFWORD (mRHS)));
                  putFIXED (mOBJECT_CONDENSERxDELTA, numberRHS);
                }
                break;
              case 14:
                // DO; (15033)
                {
                rs1s1s5:;
                  // CALL UPLOC(RHS); (15033)
                  {
                    putBITp (16, mOBJECT_CONDENSERxUPLOCxN, getBIT (16, mRHS));
                    OBJECT_CONDENSERxUPLOC (0);
                  }
                  // CALL SKIP(SHR(RHS+3,2)); (15034)
                  {
                    putBITp (16, mSKIPxN,
                             fixedToBit (
                                 32, (int32_t)(SHR (
                                         xadd (COREHALFWORD (mRHS), 3), 2))));
                    SKIP (0);
                  }
                es1s1s5:;
                } // End of DO block
                break;
              case 15:
                // DO; (15036)
                {
                rs1s1s6:;
                  // GENERATING = FALSE; (15036)
                  {
                    int32_t numberRHS = (int32_t)(0);
                    descriptor_t *bitRHS;
                    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
                    putBIT (1, mGENERATING, bitRHS);
                    bitRHS->inUse = 0;
                  }
                es1s1s6:;
                } // End of DO block
                break;
              case 16:
                // CALL VERIFY(RHS); (15038)
                {
                  putBITp (16, mOBJECT_CONDENSERxVERIFYxLBL,
                           getBIT (16, mRHS));
                  OBJECT_CONDENSERxVERIFY (0);
                }
                break;
              case 17:
                  // ; (15039)
                  ;
                break;
              case 18:
                // DO; (15040)
                {
                rs1s1s7:;
                  // CALL SHIFT_CONDENSE; (15040)
                  OBJECT_CONDENSERxSHIFT_CONDENSE (0);
                es1s1s7:;
                } // End of DO block
                break;
              case 19:
                // CURRENT_ADDRESS = CURRENT_ADDRESS + RHS & (~RHS); (15042)
                {
                  int32_t numberRHS = (int32_t)(xAND (
                      xadd (
                          getFIXED (mWORKSEG + 4 * getFIXED (mCURRENT_ESDID)),
                          COREHALFWORD (mRHS)),
                      xNOT (COREHALFWORD (mRHS))));
                  putFIXED (mWORKSEG + 4 * (getFIXED (mCURRENT_ESDID)),
                            numberRHS);
                }
                break;
              case 20:
                // CALL SKIP_ADDR; (15043)
                SKIP_ADDR (0);
                break;
              case 21:
              // HADCON_PROC: (15044)
              HADCON_PROC:
                {
                rs1s1s8:;
                  // CALL UPLOC(2); (15045)
                  {
                    putBITp (16, mOBJECT_CONDENSERxUPLOCxN,
                             fixedToBit (32, (int32_t)(2)));
                    OBJECT_CONDENSERxUPLOC (0);
                  }
                  // IF RHS = DATABASE THEN (15046)
                  if (1
                      & (xEQ (COREHALFWORD (mRHS), COREHALFWORD (mDATABASE))))
                    // DO; (15047)
                    {
                    rs1s1s8s1:;
                      // CALL NEXT_REC; (15048)
                      NEXT_REC (0);
                      // IF RLD_FLAG THEN (15049)
                      if (1
                          & (bitToFixed (
                              getBIT (1, mOBJECT_CONDENSERxRLD_FLAG))))
                        // TEMP = TEMP - PROGDELTA; (15050)
                        {
                          int32_t numberRHS = (int32_t)(xsubtract (
                              getFIXED (mTEMP), COREHALFWORD (mPROGDELTA)));
                          putFIXED (mTEMP, numberRHS);
                        }
                      // ELSE (15051)
                      else
                        // TEMP = TEMP + PROGDELTA; (15052)
                        {
                          int32_t numberRHS = (int32_t)(xadd (
                              getFIXED (mTEMP), COREHALFWORD (mPROGDELTA)));
                          putFIXED (mTEMP, numberRHS);
                        }
                      // CODE(GET_CODE(CODE_LINE-1)) = TEMP; (15053)
                      {
                        int32_t numberRHS = (int32_t)(getFIXED (mTEMP));
                        putFIXED (
                            mCODE
                                + 4
                                      * ((putFIXED (
                                              mGET_CODExCTR,
                                              xsubtract (getFIXED (mCODE_LINE),
                                                         1)),
                                          GET_CODE (0))),
                            numberRHS);
                      }
                    es1s1s8s1:;
                    } // End of DO block
                  // ELSE (15054)
                  else
                    // CALL SKIP(1); (15055)
                    {
                      putBITp (16, mSKIPxN, fixedToBit (32, (int32_t)(1)));
                      SKIP (0);
                    }
                es1s1s8:;
                } // End of DO block
                break;
              case 22:
                // LOOKING_AHEAD = RHS; (15057)
                {
                  descriptor_t *bitRHS = getBIT (16, mRHS);
                  putBIT (1, mOBJECT_CONDENSERxLOOKING_AHEAD, bitRHS);
                  bitRHS->inUse = 0;
                }
                break;
              case 23:
                // GOTO ADCON_PROC; (15058)
                goto ADCON_PROC;
                break;
              case 24:
                  // ; (15059)
                  ;
                break;
              case 25:
                  // ; (15060)
                  ;
                break;
              case 26:
                // DO; (15061)
                {
                rs1s1s9:;
                  // CALL LABEL_UPDATE(RHS); (15061)
                  {
                    putBITp (16, mOBJECT_CONDENSERxLABEL_UPDATExLEN,
                             getBIT (16, mRHS));
                    OBJECT_CONDENSERxLABEL_UPDATE (0);
                  }
                  // CALL NEXT_REC; (15062)
                  NEXT_REC (0);
                  // CODE_LINE = TEMP; (15063)
                  {
                    int32_t numberRHS = (int32_t)(getFIXED (mTEMP));
                    putFIXED (mCODE_LINE, numberRHS);
                  }
                es1s1s9:;
                } // End of DO block
                break;
              case 27:
                // DO; (15065)
                {
                rs1s1s10:;
                  // TEMP1=CODE_LINE; (15065)
                  {
                    int32_t numberRHS = (int32_t)(getFIXED (mCODE_LINE));
                    putFIXED (mOBJECT_CONDENSERxTEMP1, numberRHS);
                  }
                  // CODE_LINE=MAX_CODE_LINE; (15066)
                  {
                    int32_t numberRHS = (int32_t)(getFIXED (mMAX_CODE_LINE));
                    putFIXED (mCODE_LINE, numberRHS);
                  }
                es1s1s10:;
                } // End of DO block
                break;
              case 28:
                // DO; (15068)
                {
                rs1s1s11:;
                  // MAX_CODE_LINE=CODE_LINE; (15068)
                  {
                    int32_t numberRHS = (int32_t)(getFIXED (mCODE_LINE));
                    putFIXED (mMAX_CODE_LINE, numberRHS);
                  }
                  // CODE_LINE=TEMP1+RHS-1; (15069)
                  {
                    int32_t numberRHS = (int32_t)(xsubtract (
                        xadd (getFIXED (mOBJECT_CONDENSERxTEMP1),
                              COREHALFWORD (mRHS)),
                        1));
                    putFIXED (mCODE_LINE, numberRHS);
                  }
                es1s1s11:;
                } // End of DO block
                break;
              case 29:
                // DO; (15071)
                {
                rs1s1s12:;
                  // SPLIT_DELTA = RHS; (15071)
                  {
                    descriptor_t *bitRHS = getBIT (16, mRHS);
                    putBIT (16, mSPLIT_DELTA, bitRHS);
                    bitRHS->inUse = 0;
                  }
                es1s1s12:;
                } // End of DO block
                break;
              case 30:
                // DO; (15073)
                {
                rs1s1s13:;
                  // CURRENT_ESDID = RHS; (15073)
                  {
                    descriptor_t *bitRHS = getBIT (16, mRHS);
                    int32_t numberRHS;
                    numberRHS = bitToFixed (bitRHS);
                    putFIXED (mCURRENT_ESDID, numberRHS);
                    bitRHS->inUse = 0;
                  }
                  // CALL NEXT_REC(1); (15074)
                  {
                    putBITp (16, mNEXT_RECxI, fixedToBit (32, (int32_t)(1)));
                    NEXT_REC (0);
                  }
                  // CURRENT_ADDRESS = TEMP& POSMAX; (15075)
                  {
                    int32_t numberRHS = (int32_t)(xAND (getFIXED (mTEMP),
                                                        getFIXED (mPOSMAX)));
                    putFIXED (mWORKSEG + 4 * (getFIXED (mCURRENT_ESDID)),
                              numberRHS);
                  }
                  // CODE(GET_CODE(CODE_LINE-2))=SHL(CSECT,16)|CURRENT_ESDID;
                  // (15076)
                  {
                    int32_t numberRHS = (int32_t)(xOR (
                        SHL (BYTE0 (mCSECT), 16), getFIXED (mCURRENT_ESDID)));
                    putFIXED (
                        mCODE
                            + 4
                                  * ((putFIXED (mGET_CODExCTR,
                                                xsubtract (
                                                    getFIXED (mCODE_LINE), 2)),
                                      GET_CODE (0))),
                        numberRHS);
                  }
                es1s1s13:;
                } // End of DO block
                break;
              }
          } // End of DO CASE block
    }       // End of DO WHILE block
  {
    reentryGuard = 0;
    return 0;
  }
}
