/*
  File GENERATExGEN_CLASS0xBLOCK_CLOSE.c generated by XCOM-I, 2024-08-09
  12:39:31.
*/

#include "runtimeC.h"

int32_t
GENERATExGEN_CLASS0xBLOCK_CLOSE (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard
      = guardReentry (reentryGuard, "GENERATExGEN_CLASS0xBLOCK_CLOSE");
  // INDEX = PROC_LEVEL(INDEXNEST); (12160)
  {
    descriptor_t *bitRHS
        = getBIT (16, mPROC_LEVEL + 2 * COREHALFWORD (mINDEXNEST));
    putBIT (16, mINDEX, bitRHS);
    bitRHS->inUse = 0;
  }
  // TYPE(0) = SYT_TYPE(INDEX); (12161)
  {
    descriptor_t *bitRHS = getBIT (
        8, getFIXED (mSYM_TAB) + 34 * (COREHALFWORD (mINDEX)) + 32 + 1 * (0));
    putBIT (16, getFIXED (mIND_STACK) + 73 * (0) + 50 + 2 * (0), bitRHS);
    bitRHS->inUse = 0;
  }
  // IF ~STOPPERFLAG THEN (12162)
  if (1 & (xNOT (BYTE0 (mSTOPPERFLAG))))
    // IF TYPE(0) < ANY_LABEL THEN (12163)
    if (1
        & (xLT (COREHALFWORD (getFIXED (mIND_STACK) + 73 * (0) + 50 + 2 * (0)),
                BYTE0 (mANY_LABEL))))
      // CALL ERRCALL(14, 'CLOSE REACHED IN FUNCTION'); (12164)
      {
        putBITp (16, mGENERATExERRCALLxERRp, fixedToBit (32, (int32_t)(14)));
        putCHARACTERp (mGENERATExERRCALLxMSG,
                       cToDescriptor (NULL, "CLOSE REACHED IN FUNCTION"));
        GENERATExERRCALL (0);
      }
  // IF TYPE(0) ~= COMPOOL_LABEL THEN (12165)
  if (1
      & (xNEQ (COREHALFWORD (getFIXED (mIND_STACK) + 73 * (0) + 50 + 2 * (0)),
               BYTE0 (mCOMPOOL_LABEL))))
    // DO; (12166)
    {
    rs1:;
      // CALL SET_LABEL(SYT_LABEL(INDEX)+1); (12167)
      {
        putBITp (
            16, mGENERATExSET_LABELxSTMTNO,
            fixedToBit (32, (int32_t)(xadd (
                                COREHALFWORD (getFIXED (mSYM_TAB)
                                              + 34 * (COREHALFWORD (mINDEX))
                                              + 26 + 2 * (0)),
                                1))));
        GENERATExSET_LABEL (0);
      }
      // CALL MARKER; (12168)
      GENERATExMARKER (0);
      // IF CALL#(INDEXNEST) = 4 THEN (12169)
      if (1 & (xEQ (BYTE0 (mCALLp + 1 * COREHALFWORD (mINDEXNEST)), 4)))
        // DO; (12170)
        {
        rs1s1:;
          // CALL EMITRX(SVC, 0, 0, PRELBASE, SYT_ADDR(INDEX)+3); (12171)
          {
            putBITp (16, mGENERATExEMITRXxINST, getBIT (8, mSVC));
            putBITp (16, mGENERATExEMITRXxXREG, fixedToBit (32, (int32_t)(0)));
            putBITp (16, mGENERATExEMITRXxINDEX,
                     fixedToBit (32, (int32_t)(0)));
            putBITp (16, mGENERATExEMITRXxXBASE, getBIT (8, mPRELBASE));
            putBITp (
                16, mGENERATExEMITRXxXDISP,
                fixedToBit (32, (int32_t)(xadd (
                                    getFIXED (getFIXED (mSYM_TAB)
                                              + 34 * (COREHALFWORD (mINDEX))
                                              + 4 + 4 * (0)),
                                    3))));
            GENERATExEMITRX (0);
          }
          // IF TYPE(0) = STMT_LABEL THEN (12172)
          if (1
              & (xEQ (COREHALFWORD (getFIXED (mIND_STACK) + 73 * (0) + 50
                                    + 2 * (0)),
                      BYTE0 (mSTMT_LABEL))))
            // UPDATING = 0; (12173)
            {
              int32_t numberRHS = (int32_t)(0);
              descriptor_t *bitRHS;
              bitRHS = fixedToBit (32, (int32_t)(numberRHS));
              putBIT (16, mUPDATING, bitRHS);
              bitRHS->inUse = 0;
            }
        es1s1:;
        } // End of DO block
      // CALL EMIT_RETURN; (12174)
      GENERATExGEN_CLASS0xEMIT_RETURN (0);
    es1:;
    } // End of DO block
  // CALL EMITC(SMADDR, LINE#); (12175)
  {
    putBITp (16, mEMITCxTYPE, getBIT (8, mSMADDR));
    putBITp (16, mEMITCxINST, fixedToBit (32, (int32_t)(getFIXED (mLINEp))));
    EMITC (0);
  }
  // ADDRS_ISSUED = TRUE; (12176)
  {
    int32_t numberRHS = (int32_t)(1);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (1, mADDRS_ISSUED, bitRHS);
    bitRHS->inUse = 0;
  }
  // MARKER_ISSUED = TRUE; (12177)
  {
    int32_t numberRHS = (int32_t)(1);
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (1, mMARKER_ISSUED, bitRHS);
    bitRHS->inUse = 0;
  }
  // UPPER(PROC_LINK(INDEXNEST)) = -1; (12178)
  {
    int32_t numberRHS = (int32_t)(-1);
    putFIXED (
        mUPPER
            + 4 * (COREHALFWORD (mPROC_LINK + 2 * COREHALFWORD (mINDEXNEST))),
        numberRHS);
  }
  // ERRPTR = ERRPTR(INDEXNEST); (12179)
  {
    descriptor_t *bitRHS
        = getBIT (16, mGENERATExERRPTR + 2 * COREHALFWORD (mINDEXNEST));
    putBIT (16, mGENERATExERRPTR, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF CALL#(INDEXNEST) = 4 THEN (12180)
  if (1 & (xEQ (BYTE0 (mCALLp + 1 * COREHALFWORD (mINDEXNEST)), 4)))
    // DO; (12181)
    {
    rs2:;
      // CALL SET_LOCCTR(DATABASE, SYT_ADDR(INDEX)+2); (12182)
      {
        putBITp (16, mSET_LOCCTRxNEST, getBIT (16, mDATABASE));
        putFIXED (
            mSET_LOCCTRxVALUE,
            xadd (getFIXED (getFIXED (mSYM_TAB) + 34 * (COREHALFWORD (mINDEX))
                            + 4 + 4 * (0)),
                  2));
        SET_LOCCTR (0);
      }
      // IF SYT_TYPE(INDEX) = STMT_LABEL THEN (12183)
      if (1
          & (xEQ (BYTE0 (getFIXED (mSYM_TAB) + 34 * (COREHALFWORD (mINDEX))
                         + 32 + 1 * (0)),
                  BYTE0 (mSTMT_LABEL))))
        // DO; (12184)
        {
        rs2s1:;
          // CALL EMITC(0, SHL(SYT_CONST(INDEX)~<0, 15) + 16); (12185)
          {
            putBITp (16, mEMITCxTYPE, fixedToBit (32, (int32_t)(0)));
            putBITp (
                16, mEMITCxINST,
                fixedToBit (
                    32, (int32_t)(xadd (
                            SHL (xGE (getFIXED (getFIXED (mP2SYMS)
                                                + 12 * (COREHALFWORD (mINDEX))
                                                + 0 + 4 * (0)),
                                      0),
                                 15),
                            16))));
            EMITC (0);
          }
          // CALL EMITC(0, 18); (12186)
          {
            putBITp (16, mEMITCxTYPE, fixedToBit (32, (int32_t)(0)));
            putBITp (16, mEMITCxINST, fixedToBit (32, (int32_t)(18)));
            EMITC (0);
          }
          // CALL EMITC(0, SYT_CONST(INDEX) &  32767); (12187)
          {
            putBITp (16, mEMITCxTYPE, fixedToBit (32, (int32_t)(0)));
            putBITp (
                16, mEMITCxINST,
                fixedToBit (32, (int32_t)(xAND (
                                    getFIXED (getFIXED (mP2SYMS)
                                              + 12 * (COREHALFWORD (mINDEX))
                                              + 0 + 4 * (0)),
                                    32767))));
            EMITC (0);
          }
        es2s1:;
        } // End of DO block
      // ELSE (12188)
      else
        // DO; (12189)
        {
        rs2s2:;
          // CALL EMITC(0, 15); (12190)
          {
            putBITp (16, mEMITCxTYPE, fixedToBit (32, (int32_t)(0)));
            putBITp (16, mEMITCxINST, fixedToBit (32, (int32_t)(15)));
            EMITC (0);
          }
          // CALL EMITC(0, 17); (12191)
          {
            putBITp (16, mEMITCxTYPE, fixedToBit (32, (int32_t)(0)));
            putBITp (16, mEMITCxINST, fixedToBit (32, (int32_t)(17)));
            EMITC (0);
          }
          // CALL EMITADDR(EXCLBASE, SHL(SYT_LINK1(INDEX), 1), HADDR); (12192)
          {
            putBITp (16, mEMITADDRxCTR, getBIT (16, mEXCLBASE));
            putFIXED (mEMITADDRxVAL,
                      SHL (COREHALFWORD (getFIXED (mSYM_TAB)
                                         + 34 * (COREHALFWORD (mINDEX)) + 24
                                         + 2 * (0)),
                           1));
            putBITp (16, mEMITADDRxOP, getBIT (8, mHADDR));
            EMITADDR (0);
          }
        es2s2:;
        } // End of DO block
    es2:;
    } // End of DO block
  // CALL RESUME_LOCCTR(INDEXNEST(NARGINDEX)); (12193)
  {
    putBITp (16, mGENERATExRESUME_LOCCTRxNEST,
             getBIT (16, mINDEXNEST + 2 * COREHALFWORD (mNARGINDEX)));
    GENERATExRESUME_LOCCTR (0);
  }
  // NARGINDEX = INDEXNEST; (12194)
  {
    descriptor_t *bitRHS = getBIT (16, mINDEXNEST);
    putBIT (16, mNARGINDEX, bitRHS);
    bitRHS->inUse = 0;
  }
  // CALL CLEAR_REGS; (12195)
  CLEAR_REGS (0);
  {
    reentryGuard = 0;
    return 0;
  }
}
