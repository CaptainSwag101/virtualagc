/*
  File EMITSTRING.c generated by XCOM-I, 2024-08-09 12:39:31.
*/

#include "runtimeC.h"

int32_t
EMITSTRING (int reset)
{
  static int reentryGuard = 0;
  if (reset)
    {
      reentryGuard = 0;
      return (int32_t)0;
    }
  reentryGuard = guardReentry (reentryGuard, "EMITSTRING");
  // LEN = LENGTH(STRING); (1108)
  {
    int32_t numberRHS = (int32_t)(LENGTH (getCHARACTER (mEMITSTRINGxSTRING)));
    descriptor_t *bitRHS;
    bitRHS = fixedToBit (32, (int32_t)(numberRHS));
    putBIT (16, mEMITSTRINGxLEN, bitRHS);
    bitRHS->inUse = 0;
  }
  // IF LEN > 0 THEN (1109)
  if (1 & (xGT (COREHALFWORD (mEMITSTRINGxLEN), 0)))
    // DO; (1110)
    {
    rs1:;
      {   // (13) CALL INLINE( 88, 1, 0, STRING);
        { /*
           * File:      patch13.c
           * For:       EMITSTRING.c
           * Notes:     1. Page references are from IBM "ESA/390 Principles of
           *               Operation", SA22-7201-08, Ninth Edition, June 2003.
           *            2. Labels are of the form p%d_%d, where the 1st number
           *               indicates the leading patch number of the block, and
           *               the 2nd is the byte offset of the instruction within
           *               within the block.
           *            3. Known-problematic translations are marked with the
           *               string  "* * * F I X M E * * *" (without spaces).
           * History:   2024-07-18 RSB  Auto-generated by XCOM-I --guess=....
           *                            Inspected.
           */

          p13_0:;
      // (13)          CALL INLINE("58", 1, 0, STRING);
      address360B = (mEMITSTRINGxSTRING)&0xFFFFFF;
      // Type RX, p. 7-7:		L	1,mEMITSTRINGxSTRING(0,0)
      detailedInlineBefore (13, "L	1,mEMITSTRINGxSTRING(0,0)");
      GR[1] = COREWORD (address360B);
      detailedInlineAfter ();

    p13_4:;
      // (14)          CALL INLINE("D2", 0, 255, TEMPSTRING, 1, 0);
      address360A = (mEMITSTRINGxTEMPSTRING)&0xFFFFFF;
      address360B = (GR[1] + 0) & 0xFFFFFF;
      // Type SS, p. 7-83:		MVC
      // mEMITSTRINGxTEMPSTRING(255,0),0(1)
      detailedInlineBefore (14, "MVC	mEMITSTRINGxTEMPSTRING(255,0),0(1)");
      mvc (address360A, address360B, 255);
      detailedInlineAfter ();

    p13_10:;
    }
}; // (14) CALL INLINE( 210, 0, 255, TEMPSTRING, 1, 0);
// TEMP = ADDR(DEUTRANS); (1113)
{
  int32_t numberRHS = (int32_t)(ADDR (NULL, 0, "EMITSTRINGxDEUTRANS", 0));
  putFIXED (mEMITSTRINGxTEMP, numberRHS);
}
{   // (15) CALL INLINE( 88, 1, 0, TEMP);
  { /*
     * File:      patch15.c
     * For:       EMITSTRING.c
     * Notes:     1. Page references are from IBM "ESA/390 Principles of
     *               Operation", SA22-7201-08, Ninth Edition, June 2003.
     *            2. Labels are of the form p%d_%d, where the 1st number
     *               indicates the leading patch number of the block, and
     *               the 2nd is the byte offset of the instruction within
     *               within the block.
     *            3. Known-problematic translations are marked with the
     *               string  "* * * F I X M E * * *" (without spaces).
     * History:   2024-07-18 RSB  Auto-generated by XCOM-I --guess=....
     *                            Inspected.
     */

    p15_0:;
// (15)          CALL INLINE("58", 1, 0, TEMP);
address360B = (mEMITSTRINGxTEMP)&0xFFFFFF;
// Type RX, p. 7-7:		L	1,mEMITSTRINGxTEMP(0,0)
detailedInlineBefore (15, "L	1,mEMITSTRINGxTEMP(0,0)");
GR[1] = COREWORD (address360B);
detailedInlineAfter ();

p15_4:;
// (16)          CALL INLINE("DC", 0, 255, TEMPSTRING, 1, 0);
address360A = (mEMITSTRINGxTEMPSTRING)&0xFFFFFF;
address360B = (GR[1] + 0) & 0xFFFFFF;
// Type SS, p. 7-131:		TR	mEMITSTRINGxTEMPSTRING(255,0),0(1)
detailedInlineBefore (16, "TR	mEMITSTRINGxTEMPSTRING(255,0),0(1)");
for (i360 = 0; i360 <= 255; i360++)
  memory[address360A + i360]
      = memory[address360B + memory[address360A + i360]];
detailedInlineAfter ();

p15_10:;
}
}
; // (16) CALL INLINE( 220, 0, 255, TEMPSTRING, 1, 0);
// TEMPSTRING(LEN) = 0; (1116)
{
  int32_t numberRHS = (int32_t)(0);
  descriptor_t *bitRHS;
  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
  putBIT (8, mEMITSTRINGxTEMPSTRING + 1 * (COREHALFWORD (mEMITSTRINGxLEN)),
          bitRHS);
  bitRHS->inUse = 0;
}
// LEN = (LEN+1) & (~1); (1117)
{
  int32_t numberRHS
      = (int32_t)(xAND (xadd (COREHALFWORD (mEMITSTRINGxLEN), 1), 4294967294));
  descriptor_t *bitRHS;
  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
  putBIT (16, mEMITSTRINGxLEN, bitRHS);
  bitRHS->inUse = 0;
}
es1:;
} // End of DO block
// TEMPDESC = ILEN; (1118)
{
  descriptor_t *bitRHS = getBIT (16, mEMITSTRINGxILEN);
  putBIT (8, mEMITSTRINGxTEMPDESC, bitRHS);
  bitRHS->inUse = 0;
}
// TEMPDESC(1) = LENGTH(STRING); (1119)
{
  int32_t numberRHS = (int32_t)(LENGTH (getCHARACTER (mEMITSTRINGxSTRING)));
  descriptor_t *bitRHS;
  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
  putBIT (8, mEMITSTRINGxTEMPDESC + 1 * (1), bitRHS);
  bitRHS->inUse = 0;
}
// LEN = LEN + 2; (1120)
{
  int32_t numberRHS = (int32_t)(xadd (COREHALFWORD (mEMITSTRINGxLEN), 2));
  descriptor_t *bitRHS;
  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
  putBIT (16, mEMITSTRINGxLEN, bitRHS);
  bitRHS->inUse = 0;
}
// CALL EMITC(CSTRING, LEN); (1121)
{
  putBITp (16, mEMITCxTYPE, getBIT (8, mCSTRING));
  putBITp (16, mEMITCxINST, getBIT (16, mEMITSTRINGxLEN));
  EMITC (0);
}
// TEMP = 1; (1122)
{
  int32_t numberRHS = (int32_t)(1);
  putFIXED (mEMITSTRINGxTEMP, numberRHS);
}
// DO WHILE LEN > 0; (1123)
while (1 & (xGT (COREHALFWORD (mEMITSTRINGxLEN), 0)))
  {
    // IF LEN >= 4 THEN (1124)
    if (1 & (xGE (COREHALFWORD (mEMITSTRINGxLEN), 4)))
      // CALL EMITW(TEMP(TEMP)); (1125)
      {
        putFIXED (mEMITWxDATA, getFIXED (mEMITSTRINGxTEMP
                                         + 4 * getFIXED (mEMITSTRINGxTEMP)));
        EMITW (0);
      }
    // ELSE (1126)
    else
      // DO; (1127)
      {
      rs2s1:;
        // CALL EMITW(TEMP(TEMP), 1); (1128)
        {
          putFIXED (mEMITWxDATA, getFIXED (mEMITSTRINGxTEMP
                                           + 4 * getFIXED (mEMITSTRINGxTEMP)));
          putBITp (1, mEMITWxMODIFIER, fixedToBit (32, (int32_t)(1)));
          EMITW (0);
        }
        // LOCCTR(INDEXNEST) = LOCCTR(INDEXNEST) + CS(LEN); (1129)
        {
          int32_t numberRHS = (int32_t)(xadd (
              getFIXED (mLOCCTR + 4 * COREHALFWORD (mINDEXNEST)),
              (putFIXED (mCSxLEN, COREHALFWORD (mEMITSTRINGxLEN)), CS (0))));
          putFIXED (mLOCCTR + 4 * (COREHALFWORD (mINDEXNEST)), numberRHS);
        }
      es2s1:;
      } // End of DO block
    // LEN = LEN - 4; (1130)
    {
      int32_t numberRHS
          = (int32_t)(xsubtract (COREHALFWORD (mEMITSTRINGxLEN), 4));
      descriptor_t *bitRHS;
      bitRHS = fixedToBit (32, (int32_t)(numberRHS));
      putBIT (16, mEMITSTRINGxLEN, bitRHS);
      bitRHS->inUse = 0;
    }
    // TEMP = TEMP + 1; (1131)
    {
      int32_t numberRHS = (int32_t)(xadd (getFIXED (mEMITSTRINGxTEMP), 1));
      putFIXED (mEMITSTRINGxTEMP, numberRHS);
    }
  } // End of DO WHILE block
// ILEN = 0; (1132)
{
  int32_t numberRHS = (int32_t)(0);
  descriptor_t *bitRHS;
  bitRHS = fixedToBit (32, (int32_t)(numberRHS));
  putBIT (16, mEMITSTRINGxILEN, bitRHS);
  bitRHS->inUse = 0;
}
{
  reentryGuard = 0;
  return 0;
}
}
